<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ttom921.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言這是參考這是參考2019 iT 邦幫忙鐵人賽的你懂 JavaScript 嗎？這篇文章來學習和記錄 你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈這裏主要內容為程式設計簡介，在此可看到初䌣階段所必須理解的各種專有名詞。 程式碼(Code)程式(program)又稱原始碼(source cde)、程式碼(code)、用來表示一群執行特定工作的指令，也可以說是述句組成的集">
<meta property="og:type" content="article">
<meta property="og:title" content="學習你懂JavaScirpt嗎?">
<meta property="og:url" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/index.html">
<meta property="og:site_name" content="被施工的Tom的記錄">
<meta property="og:description" content="前言這是參考這是參考2019 iT 邦幫忙鐵人賽的你懂 JavaScript 嗎？這篇文章來學習和記錄 你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈這裏主要內容為程式設計簡介，在此可看到初䌣階段所必須理解的各種專有名詞。 程式碼(Code)程式(program)又稱原始碼(source cde)、程式碼(code)、用來表示一群執行特定工作的指令，也可以說是述句組成的集">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/tostring-conversions.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/tonumber_conversions.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/toboolean_conversions.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/JavaScript-Equality-Table.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/statement_completion_values.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/operator_precedence_table.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/ast.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/fig2.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/ydkjs-book-prototype.png">
<meta property="og:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/prototype_example.png">
<meta property="article:published_time" content="2019-08-12T09:32:18.000Z">
<meta property="article:modified_time" content="2024-03-03T14:22:03.386Z">
<meta property="article:author" content="Tom Tang">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/tostring-conversions.png">


<link rel="canonical" href="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/","path":"學習你懂JavaScirpt嗎/學習你懂JavaScirpt嗎/","title":"學習你懂JavaScirpt嗎?"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>學習你懂JavaScirpt嗎? | 被施工的Tom的記錄</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">被施工的Tom的記錄</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">異想世界</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E9%81%8B%E7%AE%97%E5%AD%90%E3%80%81%E9%81%8B%E7%AE%97%E5%BC%8F%E3%80%81%E5%80%BC%E8%88%87%E5%9E%8B%E5%88%A5%E3%80%81%E8%AE%8A%E6%95%B8%E3%80%81%E6%A2%9D%E4%BB%B6%E5%BC%8F%E3%80%81%E8%BF%B4%E5%9C%88"><span class="nav-number">2.</span> <span class="nav-text">你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC-Code"><span class="nav-number">2.1.</span> <span class="nav-text">程式碼(Code)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AA%9E%E6%B3%95-Syntab"><span class="nav-number">2.2.</span> <span class="nav-text">語法(Syntab)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B0%E5%8F%A5-Statement"><span class="nav-number">2.3.</span> <span class="nav-text">述句(Statement)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC-Literal-Value"><span class="nav-number">2.4.</span> <span class="nav-text">字面值(Literal Value)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E8%AD%AF%E5%99%A8-Interpreter-%E8%88%87%E7%B7%A8%E8%AD%AF%E5%99%A8-Compiler"><span class="nav-number">2.5.</span> <span class="nav-text">直譯器(Interpreter)與編譯器(Compiler)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E5%AD%90-Operaors"><span class="nav-number">2.6.</span> <span class="nav-text">運算子(Operaors)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E5%BC%8F-Expression"><span class="nav-number">2.7.</span> <span class="nav-text">運算式(Expression)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E8%88%87%E5%9E%8B%E5%88%A5-Values-Types"><span class="nav-number">2.8.</span> <span class="nav-text">值與型別(Values&amp;Types)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9E%8B%E5%88%A5-Primitive-Types"><span class="nav-number">2.8.1.</span> <span class="nav-text">基本型別(Primitive Types)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E5%9E%8B%E5%88%A5"><span class="nav-number">2.8.2.</span> <span class="nav-text">物件型別</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%9E%8B%E5%88%A5%E4%B9%8B%E9%96%93%E9%80%B2%E8%A1%8C%E8%BD%89%E6%8F%9B-Converting-Between-Types"><span class="nav-number">2.8.3.</span> <span class="nav-text">在型別之間進行轉換(Converting Between Types)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#typeof"><span class="nav-number">2.8.4.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A7%E5%BB%BA%E6%96%B9%E6%B3%95-Built-In-Type-Methods"><span class="nav-number">2.8.5.</span> <span class="nav-text">內建方法(Built-In Type Methods)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E8%88%87%E4%B8%8D%E7%AD%89%E6%80%A7"><span class="nav-number">2.8.6.</span> <span class="nav-text">相等性與不等性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7-Equality"><span class="nav-number">2.8.6.1.</span> <span class="nav-text">相等性(Equality)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E7%AD%89%E6%80%A7-Inequality"><span class="nav-number">2.8.6.2.</span> <span class="nav-text">不等性(Inequality)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A8%BB%E8%A7%A3-code-Comments"><span class="nav-number">2.9.</span> <span class="nav-text">程式碼註解(code Comments)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%8A%E6%95%B8-Variables"><span class="nav-number">2.10.</span> <span class="nav-text">變數(Variables)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%95%B8-Constants"><span class="nav-number">2.11.</span> <span class="nav-text">常數(Constants)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87"><span class="nav-number">2.12.</span> <span class="nav-text">命名規則</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E9%BA%BC%E6%98%AF%E9%97%9C%E9%8D%B5%E5%AD%97%EF%BC%9F%E5%8F%88%E4%BB%80%E9%BA%BC%E6%98%AF%E4%BF%9D%E7%95%99%E5%AD%97"><span class="nav-number">2.12.1.</span> <span class="nav-text">什麼是關鍵字？又什麼是保留字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%80%E5%A1%8A-Blocks"><span class="nav-number">2.13.</span> <span class="nav-text">區塊(Blocks)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A2%9D%E4%BB%B6%E5%BC%8F-Conditionals"><span class="nav-number">2.14.</span> <span class="nav-text">條件式(Conditionals)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Truthy-Falsy"><span class="nav-number">2.15.</span> <span class="nav-text">Truthy &amp; Falsy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B4%E5%9C%88-Loops"><span class="nav-number">2.16.</span> <span class="nav-text">迴圈(Loops)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#while%E8%BF%B4%E5%9C%88"><span class="nav-number">2.16.1.</span> <span class="nav-text">while迴圈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#break"><span class="nav-number">2.16.2.</span> <span class="nav-text">break</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#continue"><span class="nav-number">2.16.3.</span> <span class="nav-text">continue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for%E8%BF%B4%E5%9C%88"><span class="nav-number">2.16.4.</span> <span class="nav-text">for迴圈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F-%E8%AE%8A%E6%95%B8%E3%80%81%E5%9A%B4%E6%A0%BC%E6%A8%A1%E5%BC%8F%E3%80%81IIFEs%E3%80%81%E9%96%89%E5%8C%85%E3%80%81%E6%A8%A1%E7%B5%84%E3%80%81this%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81Polyfill%E8%88%87Transpiler"><span class="nav-number">3.</span> <span class="nav-text">你懂JavaScript嗎？-變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill與Transpiler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%8A%E6%95%B8-Variable"><span class="nav-number">3.1.</span> <span class="nav-text">變數(Variable)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%E7%AF%84%E7%96%87-Function-Scope"><span class="nav-number">3.1.1.</span> <span class="nav-text">函式範疇(Function Scope)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%89%E5%8D%87-Hoisting"><span class="nav-number">3.1.2.</span> <span class="nav-text">拉升(Hoisting)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A2%E7%8B%80%E7%AF%84%E7%96%87-Nested-Scope"><span class="nav-number">3.1.3.</span> <span class="nav-text">巢狀範疇(Nested Scope)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9A%B4%E6%A0%BC%E6%A8%A1%E5%BC%8F-Strict-Mode"><span class="nav-number">3.2.</span> <span class="nav-text">嚴格模式(Strict Mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%82%BA%E5%80%BC%E7%9A%84%E5%87%BD%E5%BC%8F-Function-as-Value"><span class="nav-number">3.3.</span> <span class="nav-text">作為值的函式(Function as Value)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B3%E5%88%BB%E8%AA%BF%E7%94%A8%E5%87%BD%E5%BC%8F%E9%81%8B%E7%AE%97%E5%BC%8F-Immediately-Invoked-Function-Expression-IIFE"><span class="nav-number">3.4.</span> <span class="nav-text">即刻調用函式運算式(Immediately Invoked Function Expression,IIFE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%96%89%E5%8C%85-Closure"><span class="nav-number">3.5.</span> <span class="nav-text">閉包(Closure)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%B5%84-Module"><span class="nav-number">3.6.</span> <span class="nav-text">模組(Module)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E8%AD%98%E5%88%A5%E5%AD%97-this-Identifier"><span class="nav-number">3.7.</span> <span class="nav-text">this識別字(this Identifier)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B-Prototype"><span class="nav-number">3.8.</span> <span class="nav-text">原型(Prototype)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%88%8A%E5%8A%9F%E8%83%BD%E8%88%87%E6%96%B0%E7%89%B9%E8%89%B2%E7%9A%84%E5%85%B1%E5%AD%98"><span class="nav-number">3.9.</span> <span class="nav-text">舊功能與新特色的共存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Polyfill"><span class="nav-number">3.9.1.</span> <span class="nav-text">Polyfill</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#isNan"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">isNan</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Transpiler"><span class="nav-number">3.9.1.2.</span> <span class="nav-text">Transpiler</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E-%E5%9E%8B%E5%88%A5-Types"><span class="nav-number">4.</span> <span class="nav-text">你懂JavaScript嗎?型別(Types)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E8%AC%82%E3%80%8C%E5%9E%8B%E5%88%A5%E3%80%8D%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">何謂「型別」？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A7%E5%BB%BA%E5%9E%8B%E5%88%A5-Built-In-Types"><span class="nav-number">4.2.</span> <span class="nav-text">內建型別(Built-In Types)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q1-%E5%A6%82%E4%BD%95%E6%AA%A2%E6%B8%ACnull%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">Q1:如何檢測null？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q2-%E6%97%A2%E7%84%B6%E5%87%BD%E5%BC%8F%E8%88%87%E9%99%A3%E5%88%97%E9%83%BD%E6%98%AF%E7%89%A9%E4%BB%B6%EF%BC%8C%E9%82%A3%E5%85%B6%E4%B8%AD%E7%9A%84%E5%B1%AC%E6%80%A7length%E6%9C%89%E4%BB%80%E9%BA%BC%E4%B8%8D%E5%90%8C"><span class="nav-number">4.4.</span> <span class="nav-text">Q2:既然函式與陣列都是物件，那其中的屬性length有什麼不同?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q3-typeof%E6%AA%A2%E6%B8%AC%E7%9A%84%E5%B0%8D%E8%B1%A1%E6%98%AF%E8%AA%B0"><span class="nav-number">4.5.</span> <span class="nav-text">Q3:typeof檢測的對象是誰?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%AE%9A%E7%BE%A9-undefined-vs%E6%9C%AA%E5%AE%A3%E5%91%8A-uneclared"><span class="nav-number">4.6.</span> <span class="nav-text">未定義(undefined)vs未宣告(uneclared)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8D%E6%9C%AA%E5%AE%A3%E5%91%8A%E7%9A%84%E8%AE%8A%E6%95%B8%E5%81%9Atypeof"><span class="nav-number">4.7.</span> <span class="nav-text">對未宣告的變數做typeof</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E5%80%BC-Values-Part1-%E9%99%A3%E5%88%97%E3%80%81%E5%AD%97%E4%B8%B2%E3%80%81%E6%95%B8%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">你懂JavaScript嗎？值(Values)Part1-陣列、字串、數字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A3%E5%88%97-Array"><span class="nav-number">5.1.</span> <span class="nav-text">陣列(Array)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E9%99%A3%E5%88%97-Sparse-Array"><span class="nav-number">5.1.1.</span> <span class="nav-text">稀疏陣列(Sparse Array)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%8D%B5%E5%80%BC%E7%9A%84%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">鍵值的強制轉型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%9E%E9%99%A3%E5%88%97-Array-Like"><span class="nav-number">5.2.</span> <span class="nav-text">類陣列(Array-Like)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E4%B8%B2-String"><span class="nav-number">5.3.</span> <span class="nav-text">字串(String)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%AE%8A-Mutable-%E8%88%87%E4%B8%8D%E5%8F%AF%E8%AE%8A-Immutable"><span class="nav-number">5.3.1.</span> <span class="nav-text">可變(Mutable)與不可變(Immutable)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E4%B8%B2%E7%9A%84%E9%A1%9E%E9%99%A3%E5%88%97%E8%99%95%E7%90%86"><span class="nav-number">5.3.2.</span> <span class="nav-text">字串的類陣列處理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E9%96%93%E9%9A%94%E5%AD%97%E5%85%83"><span class="nav-number">5.3.3.</span> <span class="nav-text">插入間隔字元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E8%BD%89"><span class="nav-number">5.3.4.</span> <span class="nav-text">反轉</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B8%E5%AD%97-Number"><span class="nav-number">5.4.</span> <span class="nav-text">數字(Number)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E9%81%94%E3%80%8C%E9%9D%9E%E5%B8%B8%E5%A4%A7%E3%80%8D%E6%88%96%E3%80%8C%E9%9D%9E%E5%B8%B8%E5%B0%8F%E3%80%8D%E7%9A%84%E6%95%B8%E5%AD%97%EF%BC%9F"><span class="nav-number">5.4.1.</span> <span class="nav-text">如何表達「非常大」或「非常小」的數字？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E5%B0%8F%E6%95%B8%E4%BD%8D%E6%95%B8"><span class="nav-number">5.4.2.</span> <span class="nav-text">如何指定小數位數?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E6%9C%89%E6%95%88%E4%BD%8D%E6%95%B8"><span class="nav-number">5.4.3.</span> <span class="nav-text">如何指定有效位數?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%85%B6%E5%AE%83%E5%9F%BA%E6%95%B8%E7%9A%84%E6%95%B8%E5%AD%97"><span class="nav-number">5.4.4.</span> <span class="nav-text">如何表示其它基數的數字?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%8D%81%E9%80%B2%E4%BD%8D%E5%B0%8F%E6%95%B8"><span class="nav-number">5.4.5.</span> <span class="nav-text">如何表示十進位小數?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%82%99%E8%A8%BB"><span class="nav-number">5.4.6.</span> <span class="nav-text">備註</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%95%B8%E5%80%BC%E6%98%AF%E5%80%8B%E6%95%B4%E6%95%B8%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%95%B8%E5%80%BC%E4%BD%8D%E5%9C%A8%E5%AE%89%E5%85%A8%E7%AF%84%E5%9C%8D%E5%85%A7%EF%BC%9F"><span class="nav-number">5.4.7.</span> <span class="nav-text">如何知道數值是個整數？如何知道數值位在安全範圍內？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32%E4%BD%8D%E5%85%83%E6%9C%89%E8%99%9F%E6%95%B4%E6%95%B8-32-bit-Signed-Integer"><span class="nav-number">5.4.8.</span> <span class="nav-text">32位元有號整數(32-bit Signed Integer)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%EF%BC%9F%E5%80%BC-Values-Part2-%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="nav-number">6.</span> <span class="nav-text">你懂JavaScript？值(Values)Part2-特殊值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined%E8%88%87void%E9%81%8B%E7%AE%97%E5%AD%90"><span class="nav-number">6.1.</span> <span class="nav-text">undefined與void運算子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NaN-%E7%84%A1%E6%95%88%E7%9A%84%E6%95%B8%E5%AD%97"><span class="nav-number">6.2.</span> <span class="nav-text">NaN(無效的數字)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#typeof-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E7%B5%90%E6%9E%9C%E6%98%AFNaN"><span class="nav-number">6.2.2.</span> <span class="nav-text">運算結果是NaN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E4%B8%8D%E5%A4%A7%E6%96%BC%E3%80%81%E4%B8%8D%E5%B0%8F%E6%96%BC%E3%80%81%E4%B8%8D%E7%AD%89%E6%96%BC%E8%87%AA%E5%B7%B2%E7%9A%84%E5%80%BC"><span class="nav-number">6.2.3.</span> <span class="nav-text">唯一不大於、不小於、不等於自已的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isNaN%E8%88%87Number-isNaN"><span class="nav-number">6.2.4.</span> <span class="nav-text">isNaN與Number.isNaN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%84%A1%E9%99%90-Infinity"><span class="nav-number">6.2.5.</span> <span class="nav-text">無限(Infinity)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6-Zero"><span class="nav-number">6.3.</span> <span class="nav-text">零(Zero)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B8%E5%AD%97%E8%BD%89%E5%AD%97%E4%B8%B2vs%E5%AD%97%E4%B8%B2%E8%BD%89%E6%95%B8%E5%AD%97"><span class="nav-number">6.3.1.</span> <span class="nav-text">數字轉字串vs字串轉數字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BE%A8%E5%88%A5%E6%AD%A3%E9%9B%B6%E5%92%8C%E8%B2%A0%E9%9B%B6"><span class="nav-number">6.3.2.</span> <span class="nav-text">如何辨別正零和負零?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9B%B8%E7%AD%89%E6%80%A7-Special-Equality"><span class="nav-number">6.3.3.</span> <span class="nav-text">特殊相等性(Special Equality)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD-Natives"><span class="nav-number">7.</span> <span class="nav-text">你懂JavaScript嗎？原生功能(Natives)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E8%AC%82%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD-Natives"><span class="nav-number">7.1.</span> <span class="nav-text">何謂原生功能(Natives)?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Internal-Class"><span class="nav-number">7.2.</span> <span class="nav-text">Internal[[Class]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%9D%E7%94%A8%E7%9A%84%E5%8C%85%E8%A3%B9%E5%99%A8-BoxingWrappers"><span class="nav-number">7.3.</span> <span class="nav-text">封裝用的包裹器(BoxingWrappers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E5%8C%85%E8%A3%B9%E5%99%A8%E7%9A%84%E9%99%B7%E9%98%B1-Object-Wrapper-Gotchas"><span class="nav-number">7.4.</span> <span class="nav-text">物件包裹器的陷阱(Object Wrapper Gotchas)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%B0%81%E8%A3%9D-Unboxing"><span class="nav-number">7.5.</span> <span class="nav-text">解封裝(Unboxing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E6%A7%8B%E5%AD%90%E7%9A%84%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD"><span class="nav-number">7.6.</span> <span class="nav-text">建構子的原生功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Array"><span class="nav-number">7.6.1.</span> <span class="nav-text">Array(..)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RegExp"><span class="nav-number">7.6.2.</span> <span class="nav-text">RegExp(..)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Date-%E8%88%87Error"><span class="nav-number">7.6.3.</span> <span class="nav-text">Date(..)與Error(..)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Symbol-%E2%80%A6"><span class="nav-number">7.6.4.</span> <span class="nav-text">Symbol(…)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B-Native-Prototype"><span class="nav-number">7.7.</span> <span class="nav-text">原生的原型(Native Prototype)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-Coercion"><span class="nav-number">8.</span> <span class="nav-text">你懂JavaScript嗎？強制轉型(Coercion)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%A8%80-1"><span class="nav-number">8.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%80%BC%E9%81%8B%E7%AE%97"><span class="nav-number">8.2.</span> <span class="nav-text">抽象的值運算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ToString"><span class="nav-number">8.2.1.</span> <span class="nav-text">ToString</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON%E7%9A%84%E5%AD%97%E4%B8%B2%E5%8C%96-JSON-Stringification"><span class="nav-number">8.3.</span> <span class="nav-text">JSON的字串化(JSON Stringification)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ToNumber"><span class="nav-number">8.3.1.</span> <span class="nav-text">ToNumber</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ToBoolean"><span class="nav-number">8.3.2.</span> <span class="nav-text">ToBoolean</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Falsy%E5%80%BC"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">Falsy值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Falsy%E7%89%A9%E4%BB%B6"><span class="nav-number">8.4.</span> <span class="nav-text">Falsy物件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Truthy-%E5%80%BC"><span class="nav-number">8.5.</span> <span class="nav-text">Truthy 值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ToPrimitive"><span class="nav-number">8.6.</span> <span class="nav-text">ToPrimitive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%8E%E7%A2%BA%E7%9A%84%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-Explicit-Coercion"><span class="nav-number">8.7.</span> <span class="nav-text">明確的強制轉型(Explicit Coercion)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A2%BA%E7%9A%84Strings-Numbers"><span class="nav-number">8.7.1.</span> <span class="nav-text">明確的Strings &lt;–&gt; Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%85%A7%E5%BB%BA%E5%87%BD%E5%BC%8FString-%E8%88%87Number"><span class="nav-number">8.7.1.1.</span> <span class="nav-text">方法一：使用內建函式String(..)與Number(..)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%89%A9%E4%BB%B6%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95-toString"><span class="nav-number">8.7.1.2.</span> <span class="nav-text">方法二：使用物件原型的方法.toString()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E5%85%83%E6%AD%A3-%E8%B2%A0%E9%81%8B%E7%AE%97%E5%AD%90-%E3%80%81"><span class="nav-number">8.7.1.3.</span> <span class="nav-text">方法三：使用一元正&#x2F;負運算子+、-</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E5%85%83%E4%BD%8D%E5%90%A6%E5%AE%9A%E9%81%8B%E7%AE%97%E5%AD%90"><span class="nav-number">8.7.1.4.</span> <span class="nav-text">方法四：使用一元位否定運算子~</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E5%A0%B4%E5%8A%A0%E6%98%A0-%E6%B5%AE%E9%BB%9E%E6%95%B8%E8%BD%89%E7%82%BA%E6%95%B4%E6%95%B8"><span class="nav-number">8.7.1.5.</span> <span class="nav-text">同場加映:浮點數轉為整數</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A2%BA%E7%9A%84%E5%89%96%E6%9E%90%E6%95%B8%E5%80%BC%E5%AD%97%E4%B8%B2-Numberic-String"><span class="nav-number">8.7.2.</span> <span class="nav-text">明確的剖析數值字串(Numberic String)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A2%BA%E7%9A%84-%E2%80%93-Boolean"><span class="nav-number">8.7.3.</span> <span class="nav-text">明確的 * –&gt; Boolean</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%85%A7%E5%BB%BA%E5%87%BD%E5%BC%8FBoolean"><span class="nav-number">8.7.3.1.</span> <span class="nav-text">方法一：使用內建函式Boolean(..)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%90%A6%E5%AE%9A%E9%81%8B%E7%AE%97%E5%AD%90"><span class="nav-number">8.7.3.2.</span> <span class="nav-text">方法二：否定運算子!</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%B1%E5%90%AB%E7%9A%84%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-Implicit-Coercion"><span class="nav-number">8.8.</span> <span class="nav-text">隱含的強制轉型(Implicit Coercion)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%B1%E5%90%AB%E7%9A%84Strings-Numbers"><span class="nav-number">8.8.1.</span> <span class="nav-text">隱含的Strings &lt;–&gt; Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Case1-String-%E2%80%93-Numbers-%E9%81%8B%E7%AE%97%E5%AD%90%E6%98%AF%E6%95%B8%E5%AD%97%E7%9A%84%E7%9B%B8%E5%8A%A0%EF%BC%8C%E9%82%84%E6%98%AF%E5%AD%97%E4%B8%B2%E7%9A%84%E4%B8%B2%E6%8E%A5"><span class="nav-number">8.8.1.1.</span> <span class="nav-text">Case1 String –&gt;Numbers:+運算子是數字的相加，還是字串的串接?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Case2-%E4%BD%BF%E7%94%A8%E6%95%B8%E5%AD%97%E9%81%8B%E7%AE%97%E5%AD%90%E5%B0%87%E5%AD%97%E4%B8%B2%E8%BD%89%E7%82%BA%E6%95%B8%E5%AD%97"><span class="nav-number">8.8.1.2.</span> <span class="nav-text">Case2:使用數字運算子將字串轉為數字</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%B1%E5%90%AB%E7%9A%84-%E2%80%93-Boolean"><span class="nav-number">8.8.2.</span> <span class="nav-text">隱含的 * –&gt; Boolean</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E5%AD%90-%E8%88%87"><span class="nav-number">8.8.2.1.</span> <span class="nav-text">運算子||與&amp;&amp;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol%E7%9A%84%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B"><span class="nav-number">8.9.</span> <span class="nav-text">Symbol的強制轉型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%AC%E9%AC%86%E7%9B%B8%E7%AD%89-Loose-Equals-vs-%E5%9A%B4%E6%A0%BC%E7%9B%B8%E7%AD%89-Strict-Equals"><span class="nav-number">8.10.</span> <span class="nav-text">寬鬆相等(Loose Equals) vs 嚴格相等(Strict Equals)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%8F%E5%89%87"><span class="nav-number">8.10.1.</span> <span class="nav-text">規則</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%8A%E7%B7%A3%E6%83%85%E6%B3%81"><span class="nav-number">8.11.</span> <span class="nav-text">邊緣情況</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%9E%8B%E7%9A%84valueOf"><span class="nav-number">8.11.1.</span> <span class="nav-text">避免修改原型的valueOf(..)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%98%8B%E7%8B%82%E7%9A%84%E7%AF%84%E4%BE%8B"><span class="nav-number">8.11.2.</span> <span class="nav-text">一些瘋狂的範例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B8%BD%E7%B5%90-%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E4%BD%BF%E7%94%A8%E9%9A%B1%E5%90%AB%E7%9A%84%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B"><span class="nav-number">8.12.</span> <span class="nav-text">總結  ：如何安全地使用隱含的強制轉型?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Equality-Table"><span class="nav-number">8.13.</span> <span class="nav-text">JavaScript Equality Table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%97%9C%E7%B3%BB%E5%BC%8F%E6%AF%94%E8%BC%83"><span class="nav-number">8.14.</span> <span class="nav-text">抽象的關系式比較</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7"><span class="nav-number">8.15.</span> <span class="nav-text">回顧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E6%96%87%E6%B3%95-Grammar"><span class="nav-number">9.</span> <span class="nav-text">你懂JavaScript嗎？文法(Grammar)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B0%E5%8F%A5%E8%88%87%E9%81%8B%E7%AE%97%E5%BC%8F-Statements-Expressions"><span class="nav-number">9.1.</span> <span class="nav-text">述句與運算式(Statements&amp;Expressions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B0%E5%8F%A5%E5%AE%8C%E6%88%90%E5%80%BC-Statement-Completion-Values"><span class="nav-number">9.2.</span> <span class="nav-text">述句完成值(Statement Completion Values)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E5%BC%8F%E5%89%AF%E4%BD%9C%E7%94%A8-Side-Effects"><span class="nav-number">9.3.</span> <span class="nav-text">運算式副作用(Side Effects)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%BE%E7%B0%A1%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="nav-number">9.4.</span> <span class="nav-text">精簡程式碼</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B1%BA%E6%96%BC%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%A6%8F%E5%89%87-Contextual-Rules"><span class="nav-number">9.5.</span> <span class="nav-text">取決於上下文的規則(Contextual Rules)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%8B%AC%E8%99%9F-Curly-Braces"><span class="nav-number">9.6.</span> <span class="nav-text">大括號({..}Curly Braces)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#else-if-%E8%88%87%E9%81%B8%E6%93%87%E6%80%A7%E5%8D%80%E5%A1%8A"><span class="nav-number">9.7.</span> <span class="nav-text">else if 與選擇性區塊</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8B%E7%AE%97%E5%AD%90%E5%84%AA%E5%85%88%E5%BA%8F-Operator-Precedence"><span class="nav-number">9.8.</span> <span class="nav-text">運算子優先序(Operator Precedence)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Operator-Precedence-Table"><span class="nav-number">9.8.1.</span> <span class="nav-text">Operator Precedence Table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%AD%E8%B7%AF-Short-Circuited"><span class="nav-number">9.8.2.</span> <span class="nav-text">短路(Short Circuited)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B5%90%E5%90%88%E6%80%A7-Associativity"><span class="nav-number">9.9.</span> <span class="nav-text">結合性(Associativity)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8B%95%E5%88%86%E8%99%9F%E6%8F%92%E5%85%A5-Automatic-Semicolon-Insertion-ASI"><span class="nav-number">9.10.</span> <span class="nav-text">自動分號插入(Automatic Semicolon Insertion,ASI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%8C%AF%E8%AA%A4-Errors"><span class="nav-number">9.11.</span> <span class="nav-text">錯誤(Errors)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B7%A8%E8%AD%AF%E6%99%82%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4"><span class="nav-number">9.11.1.</span> <span class="nav-text">編譯時期的錯誤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%B7%E8%A1%8C%E6%99%82%E6%9C%9F%E7%9A%84%E9%8C%AF%E8%AA%A4"><span class="nav-number">9.12.</span> <span class="nav-text">執行時期的錯誤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%AB%E6%99%82%E6%AD%BB%E4%BA%A1%E5%8D%80%E5%9F%9F-Temporal-Dead-Zone-TDZ"><span class="nav-number">9.13.</span> <span class="nav-text">暫時死亡區域(Temporal Dead Zone, TDZ)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-finally"><span class="nav-number">9.14.</span> <span class="nav-text">try..finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch"><span class="nav-number">9.15.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-1"><span class="nav-number">9.16.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References"><span class="nav-number">9.16.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E-%E7%AF%84%E7%96%87%EF%BC%88Scope%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">你懂JavaScript嗎?範疇（Scope）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AF%84%E7%96%87%EF%BC%88Scope%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">範疇（Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B7%A8%E8%AD%AF%E5%99%A8%E6%80%8E%E9%BA%BC%E7%90%86%E8%A7%A3%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="nav-number">10.2.</span> <span class="nav-text">編譯器怎麼理解程式碼?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AF%84%E7%96%87%E7%9A%84%E5%8A%9F%E7%94%A8%E6%98%AF%EF%BC%9F"><span class="nav-number">10.3.</span> <span class="nav-text">範疇的功用是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A2%E7%8B%80%E7%AF%84%E7%96%87%EF%BC%88Nested-Scope%EF%BC%89"><span class="nav-number">10.4.</span> <span class="nav-text">巢狀範疇（Nested Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%8C%AF%E8%AA%A4%EF%BC%88Error%EF%BC%89"><span class="nav-number">10.5.</span> <span class="nav-text">錯誤（Error）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-2"><span class="nav-number">10.6.</span> <span class="nav-text">回顧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#References-1"><span class="nav-number">10.7.</span> <span class="nav-text">References</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%EF%BC%9F%E8%AA%9E%E5%BD%99%E7%AF%84%E7%96%87%EF%BC%88Lexical-Scope%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">你懂JavaScript？語彙範疇（Lexical Scope）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AA%9E%E5%BD%99%E7%AF%84%E7%96%87%EF%BC%88Lexical-Scope%EF%BC%89"><span class="nav-number">11.1.</span> <span class="nav-text">語彙範疇（Lexical Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%AD%98%E5%88%A5%E5%AD%97"><span class="nav-number">11.2.</span> <span class="nav-text">查找識別字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E9%BA%BC%E6%9C%83%E8%AE%8A%E8%AE%8A%E8%AA%9E%E5%BD%99%E7%AF%84%E7%96%87%EF%BC%9F%E6%9C%89%E4%BB%80%E9%BA%BC%E5%BD%B1%E9%9F%BF%EF%BC%9F"><span class="nav-number">11.3.</span> <span class="nav-text">什麼會變變語彙範疇？有什麼影響？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#eval"><span class="nav-number">11.3.1.</span> <span class="nav-text">eval</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#with"><span class="nav-number">11.3.2.</span> <span class="nav-text">with</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%BA%E4%BB%80%E9%BA%BCeval%E5%92%8Cwith%E6%9C%83%E5%B0%8E%E8%87%B4%E6%95%88%E8%83%BD%E4%B8%8D%E4%BD%B3%EF%BC%9F"><span class="nav-number">11.4.</span> <span class="nav-text">為什麼eval和with會導致效能不佳？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-3"><span class="nav-number">11.5.</span> <span class="nav-text">回顧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#References-2"><span class="nav-number">11.6.</span> <span class="nav-text">References</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%EF%BC%9F%E5%87%BD%E5%BC%8F%E7%AF%84%E7%96%87%E8%88%87%E5%8D%80%E5%A1%8A%E7%AF%84%E7%96%87%EF%BC%88Function-vs-Block-Scope%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">你懂JavaScript？函式範疇與區塊範疇（Function vs Block Scope）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%A8%80-2"><span class="nav-number">12.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%E7%AF%84%E7%96%87%EF%BC%88Function-Scope%EF%BC%89"><span class="nav-number">12.2.</span> <span class="nav-text">函式範疇（Function Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E3%80%8C%E5%87%BD%E5%BC%8F%E7%AF%84%E7%96%87%E3%80%8D%E6%9C%89%E4%BB%80%E9%BA%BC%E5%A5%BD%E8%99%95%EF%BC%9F"><span class="nav-number">12.3.</span> <span class="nav-text">使用「函式範疇」有什麼好處？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%AC%8A%E9%99%90%E5%8E%9F%E5%89%87"><span class="nav-number">12.4.</span> <span class="nav-text">最小權限原則</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E8%A1%9D%E7%AA%81"><span class="nav-number">12.5.</span> <span class="nav-text">避免衝突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%9F%9F%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93%EF%BC%88Global-Namespace%EF%BC%89"><span class="nav-number">12.6.</span> <span class="nav-text">全域命名空間（Global Namespace）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%B5%84%E7%AE%A1%E7%90%86%EF%BC%88Module-Management%EF%BC%89"><span class="nav-number">12.7.</span> <span class="nav-text">模組管理（Module Management）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B3%E5%88%BB%E8%AA%BF%E7%94%A8%E5%87%BD%E5%BC%8F%E9%81%8B%E7%AE%97%E5%BC%8FImmediately-Invoked-Function-Expression-IIFE%EF%BC%89"><span class="nav-number">12.8.</span> <span class="nav-text">即刻調用函式運算式Immediately Invoked Function Expression,IIFE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%E5%AE%A3%E5%91%8A%EF%BC%88Function-Declaration%EF%BC%89vs-%E5%87%BD%E5%BC%8F%E9%81%8B%E7%AE%97%E5%BC%8F%EF%BC%88Function-Expression%EF%BC%89"><span class="nav-number">12.9.</span> <span class="nav-text">函式宣告（Function Declaration）vs 函式運算式（Function Expression）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D-vs-%E5%85%B7%E5%90%8D%EF%BC%88Anonymous-vs-Named%EF%BC%89"><span class="nav-number">12.10.</span> <span class="nav-text">匿名 vs 具名（Anonymous vs Named）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%AF%84%E7%96%87"><span class="nav-number">12.11.</span> <span class="nav-text">指定範疇</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A2%BA%E4%BF%9Dundefined%E7%9A%84%E6%AD%A3%E7%A2%BA%E6%80%A7"><span class="nav-number">12.12.</span> <span class="nav-text">確保undefined的正確性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%89%E9%A0%86%E5%BA%8F"><span class="nav-number">12.13.</span> <span class="nav-text">反轉順序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%80%E5%A1%8A%E7%AF%84%E7%96%87%EF%BC%88Block-Scope%EF%BC%89"><span class="nav-number">12.14.</span> <span class="nav-text">區塊範疇（Block Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Garbage-Collection%EF%BC%89"><span class="nav-number">12.15.</span> <span class="nav-text">垃圾回收（Garbage Collection）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-4"><span class="nav-number">12.16.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-3"><span class="nav-number">12.16.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E6%8B%89%E5%8D%87%EF%BC%88Hoisting%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">你懂JavaScript嗎？拉升（Hoisting）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E9%BA%BC%E6%98%AF%E6%8B%89%E5%8D%87%EF%BC%88Hoisting%EF%BC%89"><span class="nav-number">13.1.</span> <span class="nav-text">什麼是拉升（Hoisting）?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%89%E5%8D%87%E6%98%AF%E9%80%90%E7%AF%84%E7%96%87%E7%9A%84%EF%BC%81"><span class="nav-number">13.2.</span> <span class="nav-text">拉升是逐範疇的！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%E9%81%8B%E7%AE%97%E5%BC%8F%E4%B8%8D%E6%9C%83%E8%A2%AB%E6%8F%90%E5%8D%87"><span class="nav-number">13.3.</span> <span class="nav-text">函式運算式不會被提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%8A%E6%95%B8-vs-%E5%87%BD%E5%BC%8F%E7%9A%84%E6%8B%89%E5%8D%87"><span class="nav-number">13.4.</span> <span class="nav-text">變數 vs 函式的拉升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%80%8B%E4%B8%AD%E7%9A%84%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8%E4%B8%A6%E4%B8%8D%E6%9C%83%E8%A2%AB%E6%8B%89%E5%8D%87"><span class="nav-number">13.5.</span> <span class="nav-text">多個&lt;script&gt;中的全域變數並不會被拉升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A4%87%E5%AE%A3%E5%91%8A"><span class="nav-number">13.6.</span> <span class="nav-text">重複宣告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-5"><span class="nav-number">13.7.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-4"><span class="nav-number">13.7.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E-%E5%8B%95%E6%85%8B%E7%AF%84%E7%96%87%EF%BC%88Dynamic-Scope%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">你懂JavaScript嗎?動態範疇（Dynamic Scope）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8B%95%E6%85%8B%E7%AF%84%E7%96%87%EF%BC%88Dynamic-Scope%EF%BC%89-vs-%E8%AA%9E%E5%BD%99%E7%AF%84%E7%96%87%EF%BC%88Lexical-Scope%EF%BC%89"><span class="nav-number">14.1.</span> <span class="nav-text">動態範疇（Dynamic Scope） vs 語彙範疇（Lexical Scope）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-6"><span class="nav-number">14.2.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-5"><span class="nav-number">14.2.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript-%E9%96%89%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="nav-number">15.</span> <span class="nav-text">你懂JavaScript?閉包（Closure）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%96%89%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="nav-number">15.1.</span> <span class="nav-text">閉包（Closure）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%B4%E5%9C%88%E8%88%87%E9%96%89%E5%8C%85"><span class="nav-number">15.2.</span> <span class="nav-text">迴圈與閉包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%B5%84%E6%A8%A1%E5%BC%8F%EF%BC%88Module-Pattern%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">模組模式（Module Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%B5%84%E4%BE%9D%E5%AD%98%E6%80%A7%E8%BC%89%E5%85%A5%E5%99%A8%EF%BC%88Module-Dependency-Loader%EF%BC%89"><span class="nav-number">15.4.</span> <span class="nav-text">模組依存性載入器（Module Dependency Loader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6%E6%A8%A1%E7%B5%84%EF%BC%88ES6-Module%EF%BC%89"><span class="nav-number">15.5.</span> <span class="nav-text">ES6模組（ES6 Module）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-7"><span class="nav-number">15.6.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-6"><span class="nav-number">15.6.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E3%AF%B5JavaScript%E5%97%8E%EF%BC%9FThis"><span class="nav-number">16.</span> <span class="nav-text">你㯵JavaScript嗎？This</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F"><span class="nav-number">16.1.</span> <span class="nav-text">this是什麼？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%B7this%E7%9A%84%E5%9B%9B%E5%9B%BA%E8%A6%8F%E5%89%87"><span class="nav-number">16.2.</span> <span class="nav-text">判斷this的四固規則</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A0%90%E8%A8%AD%E7%B6%81%E5%AE%9A%EF%BC%88Default-Binding%EF%BC%89"><span class="nav-number">16.2.1.</span> <span class="nav-text">預設綁定（Default Binding）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9A%B4%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88Strict-Mode%EF%BC%89"><span class="nav-number">16.3.</span> <span class="nav-text">嚴格模式（Strict Mode）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%B1%E5%90%AB%E7%B6%81%E5%AE%9A%EF%BC%88Implicit-Binding%EF%BC%89"><span class="nav-number">16.4.</span> <span class="nav-text">隱含綁定（Implicit Binding）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%B1%E5%90%AB%E7%9A%84%E7%89%A9%E5%8E%BB%EF%BC%88implicitly-Lost%EF%BC%89"><span class="nav-number">16.5.</span> <span class="nav-text">隱含的物去（implicitly Lost）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%8E%E7%A2%BA%E7%B6%81%E5%AE%9A%EF%BC%88Explicit-Binding%EF%BC%89"><span class="nav-number">16.6.</span> <span class="nav-text">明確綁定（Explicit Binding）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#call"><span class="nav-number">16.6.1.</span> <span class="nav-text">call</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#apply"><span class="nav-number">16.6.2.</span> <span class="nav-text">apply</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bind"><span class="nav-number">16.6.3.</span> <span class="nav-text">bind</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new%E7%B6%81%E5%AE%9A%EF%BC%88new-Binding%EF%BC%89"><span class="nav-number">16.6.4.</span> <span class="nav-text">new綁定（new Binding）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%B5%90"><span class="nav-number">16.7.</span> <span class="nav-text">小結</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B6%81%E5%AE%9A%E7%9A%84%E4%BE%8B%E5%A4%96"><span class="nav-number">16.8.</span> <span class="nav-text">綁定的例外</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5this"><span class="nav-number">16.8.1.</span> <span class="nav-text">忽略this</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%96%93%E6%8E%A5%E5%8F%83%E8%80%83%EF%BC%88Indirect-Reference%EF%BC%89"><span class="nav-number">16.8.2.</span> <span class="nav-text">間接參考（Indirect Reference）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BB%9F%E7%B6%81%E5%AE%9A%EF%BC%88Soft-Binding%EF%BC%89"><span class="nav-number">16.8.3.</span> <span class="nav-text">軟綁定（Soft Binding）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AA%9E%E5%BD%99%E7%9A%84this%EF%BC%88Lexical-this%EF%BC%89"><span class="nav-number">16.9.</span> <span class="nav-text">語彙的this（Lexical this）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-8"><span class="nav-number">16.10.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Reference"><span class="nav-number">16.10.1.</span> <span class="nav-text">Reference</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E8%96%A6%E9%96%B1%E8%AE%80"><span class="nav-number">16.11.</span> <span class="nav-text">推薦閱讀</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%E7%89%A9%E4%BB%B6%EF%BC%88Object%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">你懂JavaScript嗎？物件（Object）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AA%9E%E6%B3%95%EF%BC%88Syntax%EF%BC%89"><span class="nav-number">17.1.</span> <span class="nav-text">語法（Syntax）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%8B%E5%88%A5%EF%BC%88Type%EF%BC%89"><span class="nav-number">17.2.</span> <span class="nav-text">型別（Type）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-2"><span class="nav-number">17.3.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A7%E5%BB%BA%E7%89%A9%E4%BB%B6%EF%BC%88Built-in-Objects%EF%BC%89"><span class="nav-number">17.4.</span> <span class="nav-text">內建物件（Built-in Objects）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A7%E5%AE%B9%EF%BC%88Contents%EF%BC%89"><span class="nav-number">17.5.</span> <span class="nav-text">內容（Contents）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q1-%E5%A6%82%E6%9E%9C%E5%B1%AC%E6%80%A7%E5%90%8D%E7%A8%B1%E6%98%AF%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%88%96%E5%8B%95%E6%85%8B%E7%94%A2%E7%94%9F%E7%9A%84%EF%BC%8C%E8%A9%B2%E6%80%8E%E9%BA%BC%E5%AD%98%E5%8F%96%E5%AE%83%E7%9A%84%E5%80%BC%E5%91%A2%EF%BC%9F"><span class="nav-number">17.6.</span> <span class="nav-text">Q1:如果屬性名稱是特殊字符或動態產生的，該怎麼存取它的值呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q2-%E5%B1%AC%E6%80%A7%E7%9C%9F%E7%9A%84%E5%8F%AA%E8%83%BD%E6%98%AF%E5%AD%97%E4%B8%B2%E5%97%8E%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%95%B8%E5%AD%97%E3%80%81%E7%89%A9%E4%BB%B6%E7%AD%89%E5%85%B6%E4%BB%96%E5%9E%8B%E5%88%A5%E7%9A%84%E5%80%BC%E5%97%8E%EF%BC%9F"><span class="nav-number">17.7.</span> <span class="nav-text">Q2:屬性真的只能是字串嗎？可以是數字、物件等其他型別的值嗎？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%EF%BC%88Function%EF%BC%89vs%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89"><span class="nav-number">17.8.</span> <span class="nav-text">函式（Function）vs方法（Method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A3%E5%88%97%EF%BC%88Array%EF%BC%89"><span class="nav-number">17.9.</span> <span class="nav-text">陣列（Array）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A4%87%E8%A3%BD%E7%89%A9%E4%BB%B6"><span class="nav-number">17.10.</span> <span class="nav-text">複製物件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BA%E6%8B%B7%E8%B2%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="nav-number">17.10.1.</span> <span class="nav-text">淺拷貝（Shallow Copy）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B2%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="nav-number">17.10.2.</span> <span class="nav-text">深拷貝（Deep Copy）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%AC%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%99%A8%EF%BC%88Property-Descriptor%EF%BC%89"><span class="nav-number">17.11.</span> <span class="nav-text">屬性描述器（Property Descriptor）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Writable"><span class="nav-number">17.11.1.</span> <span class="nav-text">Writable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Configurable"><span class="nav-number">17.11.2.</span> <span class="nav-text">Configurable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Enumerable"><span class="nav-number">17.11.3.</span> <span class="nav-text">Enumerable</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%AE%8A%E6%80%A7%EF%BC%88Immutability%EF%BC%89"><span class="nav-number">17.12.</span> <span class="nav-text">不可變性（Immutability）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E5%B8%B8%E6%95%B8%EF%BC%88Object-Constant%EF%BC%89"><span class="nav-number">17.13.</span> <span class="nav-text">物件常數（Object Constant）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%93%B4%E5%85%85%EF%BC%88Prevent-Extensions%EF%BC%89"><span class="nav-number">17.14.</span> <span class="nav-text">避免擴充（Prevent Extensions）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E5%B0%81%EF%BC%88Seal%EF%BC%89"><span class="nav-number">17.15.</span> <span class="nav-text">密封（Seal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8D%E7%B5%90%EF%BC%88Freeze%EF%BC%89"><span class="nav-number">17.16.</span> <span class="nav-text">凍結（Freeze）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get"><span class="nav-number">17.17.</span> <span class="nav-text">[[Get]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Put"><span class="nav-number">17.18.</span> <span class="nav-text">[[Put]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%80%BC%E5%99%A8-Getter-%E8%88%87%E8%A8%AD%E5%80%BC%E5%99%A8%EF%BC%88Setter%EF%BC%89"><span class="nav-number">17.19.</span> <span class="nav-text">取值器(Getter)與設值器（Setter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%EF%BC%88Existence%EF%BC%89"><span class="nav-number">17.20.</span> <span class="nav-text">存在（Existence）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%88%89%EF%BC%88Enumeration%EF%BC%89"><span class="nav-number">17.21.</span> <span class="nav-text">列舉（Enumeration）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#in"><span class="nav-number">17.21.1.</span> <span class="nav-text">in</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#propertyIsEnumerable-NaN"><span class="nav-number">17.21.2.</span> <span class="nav-text">propertyIsEnumerable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-keysvsObject-getOwnPropertyNames"><span class="nav-number">17.21.3.</span> <span class="nav-text">Object.keysvsObject.getOwnPropertyNames</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%EF%BC%88Iteration%EF%BC%89"><span class="nav-number">17.22.</span> <span class="nav-text">迭代（Iteration）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forEach"><span class="nav-number">17.22.1.</span> <span class="nav-text">forEach</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#every"><span class="nav-number">17.22.2.</span> <span class="nav-text">every</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#some"><span class="nav-number">17.22.3.</span> <span class="nav-text">some</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for-of"><span class="nav-number">17.22.4.</span> <span class="nav-text">for...of</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-9"><span class="nav-number">17.23.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-7"><span class="nav-number">17.23.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%E5%97%8E%EF%BC%9F%EF%BC%88%E7%B0%A1%E6%98%93%E7%89%88%EF%BC%89%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E6%A6%82%E5%BF%B5"><span class="nav-number">18.</span> <span class="nav-text">你懂JavaScript嗎？（簡易版）物件導向概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%9E%E5%88%A5%EF%BC%88Class%EF%BC%89%E3%80%81%E9%82%81%E6%A7%8B%E5%AD%90%EF%BC%88Constructor%EF%BC%89%E3%80%81%E5%AF%A6%E9%AB%94%EF%BC%88Instance%EF%BC%89"><span class="nav-number">18.1.</span> <span class="nav-text">類別（Class）、邁構子（Constructor）、實體（Instance）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B9%BC%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="nav-number">18.2.</span> <span class="nav-text">繼承（Inheritance）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%9E%8B%EF%BC%88Polymorphism%EF%BC%89"><span class="nav-number">18.3.</span> <span class="nav-text">多型（Polymorphism）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-10"><span class="nav-number">18.4.</span> <span class="nav-text">回顧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#References-8"><span class="nav-number">18.4.1.</span> <span class="nav-text">References</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%87%82JavaScript%EF%BC%9F%E5%8E%9F%E5%9E%8B%EF%BC%88Prototype%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">你懂JavaScript？原型（Prototype）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%A8%80-3"><span class="nav-number">19.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">19.2.</span> <span class="nav-text">注意</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AB%8B%E5%8B%BF%E4%BF%AE%E6%94%B9%E5%8E%9F%E7%94%9F%E5%8E%9F%E5%9E%8B"><span class="nav-number">19.2.1.</span> <span class="nav-text">請勿修改原生原型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%9C%E6%96%BC%E5%BB%BA%E6%A7%8B%E5%AD%90%E2%80%A6"><span class="nav-number">19.2.2.</span> <span class="nav-text">關於建構子…</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%B2%E9%8F%88%EF%BC%88Prototype-Chain%EF%BC%89"><span class="nav-number">19.3.</span> <span class="nav-text">原型串鏈（Prototype Chain）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Q1%EF%BC%9A%E5%88%B0%E5%BA%95%E6%98%AF%E8%AA%B0%E7%9A%84%E5%B1%AC%E6%80%A7%EF%BC%9F"><span class="nav-number">19.3.1.</span> <span class="nav-text">Q1：到底是誰的屬性？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q2%EF%BC%9A%E5%88%B0%E5%BA%95%E6%98%AF%E8%AA%B0%E7%9A%84%E5%AF%A6%E9%AB%94%EF%BC%9F"><span class="nav-number">19.3.2.</span> <span class="nav-text">Q2：到底是誰的實體？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%82%99%E8%A8%BB-1"><span class="nav-number">19.3.2.1.</span> <span class="nav-text">備註</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q3%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%B2%E9%8F%88%E7%9A%84%E7%B5%82%E9%BB%9E%E6%98%AF%EF%BC%9F"><span class="nav-number">19.3.3.</span> <span class="nav-text">Q3：原型串鏈的終點是？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q4%EF%BC%9A%E5%B1%AC%E6%80%A7%E7%9A%84%E8%A8%AD%E5%AE%9A%E8%88%87%E9%81%AE%E8%94%BD"><span class="nav-number">19.3.4.</span> <span class="nav-text">Q4：屬性的設定與遮蔽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q5%EF%BC%9A%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E3%80%8C%E9%A1%9E%E5%88%A5%E3%80%8D%E7%9A%84%E6%A6%82%E5%BF%B5%E6%89%8D%E8%83%BD%E5%BB%BA%E7%AB%8B%E5%85%A9%E7%89%A9%E4%BB%B6%E7%9A%84%E9%80%A3%E7%B5%90%E5%97%8E%EF%BC%9F"><span class="nav-number">19.3.5.</span> <span class="nav-text">Q5：一定要用「類別」的概念才能建立兩物件的連結嗎？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q6-%E9%80%A3%E7%B5%90%E4%BD%9C%E7%82%BA%E5%82%99%E6%8F%B4%E4%B9%8B%E7%94%A8%EF%BC%9F"><span class="nav-number">19.3.6.</span> <span class="nav-text">Q6:連結作為備援之用？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%A7-11"><span class="nav-number">19.4.</span> <span class="nav-text">回顧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="nav-number">20.</span> <span class="nav-text">參考資料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom Tang</p>
  <div class="site-description" itemprop="description">記錄有的沒有的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-TW">
    <link itemprop="mainEntityOfPage" href="https://ttom921.github.io/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/%E5%AD%B8%E7%BF%92%E4%BD%A0%E6%87%82JavaScirpt%E5%97%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom Tang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="被施工的Tom的記錄">
      <meta itemprop="description" content="記錄有的沒有的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="學習你懂JavaScirpt嗎? | 被施工的Tom的記錄">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          學習你懂JavaScirpt嗎?
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2019-08-12 09:32:18" itemprop="dateCreated datePublished" datetime="2019-08-12T09:32:18+00:00">2019-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2024-03-03 14:22:03" itemprop="dateModified" datetime="2024-03-03T14:22:03+00:00">2024-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>這是參考這是參考2019 iT 邦幫忙鐵人賽的<a href="https://ithelp.ithome.com.tw/users/20092232/ironman/1612">你懂 JavaScript 嗎？</a>這篇文章來學習和記錄</p>
<h3 id="你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈"><a href="#你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈" class="headerlink" title="你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈"></a>你懂JavaScript嗎？運算子、運算式、值與型別、變數、條件式、迴圈</h3><p>這裏主要內容為程式設計簡介，在此可看到初䌣階段所必須理解的各種專有名詞。</p>
<h4 id="程式碼-Code"><a href="#程式碼-Code" class="headerlink" title="程式碼(Code)"></a>程式碼(Code)</h4><p>程式(program)又稱原始碼(source cde)、程式碼(code)、用來表示一群執行特定工作的指令，也可以說是述句組成的集合。</p>
<h4 id="語法-Syntab"><a href="#語法-Syntab" class="headerlink" title="語法(Syntab)"></a>語法(Syntab)</h4><p>規範有交指令與組合的規則，稱為電腦語言(computer language)或語法(syntax)。可想成若希望能編寫電腦可懂的語言，就必須遵循一套規則來撰寫，而這個規則𣄵是語法，就和我們平常溝通所說的語言的文法是一樣的。</p>
<h4 id="述句-Statement"><a href="#述句-Statement" class="headerlink" title="述句(Statement)"></a>述句(Statement)</h4><p>會執行特定工作的字詞、數字或運算子(operator)組合，即是述句(statement)，例如:<code>a = b+1</code>就會執行<code>b+1</code>並將結果指定給a。</p>
<h4 id="字面值-Literal-Value"><a href="#字面值-Literal-Value" class="headerlink" title="字面值(Literal Value)"></a>字面值(Literal Value)</h4><p>獨立存在的值， 沒有存在於任何變數中，到如:<code>a = b + 1</code>中的1。</p>
<h4 id="直譯器-Interpreter-與編譯器-Compiler"><a href="#直譯器-Interpreter-與編譯器-Compiler" class="headerlink" title="直譯器(Interpreter)與編譯器(Compiler)"></a>直譯器(Interpreter)與編譯器(Compiler)</h4><p>直譯器與編譯器可將程式碼由上到下逐行轉為電腦可懂的命令。其差別在於時機點</p>
<ul>
<li><p>直譯(interpret)：在程式執行「時」做轉換。</p>
</li>
<li><p>編譯(compile)：在程式執行「前」做轉換，然後會產出編譯後的指令，因此之後執行的是這個編譯後的結果。注意，JavaScript引擎在每次執行前即時編譯程式碼，接著立刻執行編譯後的指令。</p>
</li>
</ul>
<h4 id="運算子-Operaors"><a href="#運算子-Operaors" class="headerlink" title="運算子(Operaors)"></a>運算子(Operaors)</h4><p>對變數或值進行操作的字元，例如：<code>a = b + 1</code>中的<code>=</code>和<code>+</code>。</p>
<p>JavaScript有以下幾種運算子。</p>
<ul>
<li><p>指定運算子(assignment)：其實就是等號運算子(<code>=</code>)來進行「指定」的工作，當計算完畢等號右邊的值後，接著將結果放進等號左邊的變數，這個戶進去的動作就是指定。例如：<code>a = b +1</code>，就是將<code>b + 1</code>的結果放到a。</p>
</li>
<li><p>算數運算子(math):進行加(<code>+</code>)減(<code>-</code>)乘(<code>*</code>)除(<code>/</code>)的運算，例如:<code>b + 1</code>。</p>
</li>
<li><p>複合指定運算子(compound assignment):<code>+=</code>、<code>-=</code>、<code>*=</code>和<code>/=</code>將算術運算子和指定運算子結合在一起，例如:<code>a += 1</code>, 等同於<code>a = a + 1</code>。</p>
</li>
<li><p>遞增運算子(increment&#x2F;decrement):<code>++</code>(遞增)與<code>--</code>(遞減),例如<code>a++</code>，等同於<code>a= a+1</code>。</p>
</li>
<li><p>物件特性的存取運算子(object property access:):利用<code>.</code>(點記號法，dot notation)或<code>[]</code>(方括號記號法，bracket notation)的方式存取物件的特性，例如:<code>obj.a</code>或<code>obj[&#39;a&#39;]</code> ，<code>.</code>因為簡單便利較常使用，但<code>[]</code>卻可在索引值是變數或有特殊字元時能保證完成值的存取，例如:<code>obj[]&#39;h e l l o&#39;</code>(有空白)、<code>obj[&#39;#$%^&amp;&#39;]</code>(特殊字元)、<code>obj[&#39;123&#39;]</code>(開頭為數字)。𠯌想了解命名規則，待變數命名的部分會再詳述。</p>
</li>
<li><p>相等性運算子(equality):可分為<code>==</code>(寬鬆相等)、<code>===</code>(嚴格相等)、<code>！=</code>(寬鬆不相等)、<code>!==</code>(嚴格不相等)，主要差異是做值的比較時是否會做強制轉型。</p>
</li>
<li><p>比較運算子(comparison):<code>&lt;</code>(小於)、<code>&gt;</code>(大於) 、<code>&lt;=(小於等於)</code>、<code>&gt;=(大於等於)</code>例如:<code>a &gt; b</code>表示比較a是否大於b。注意比較結果一定會是布林值。</p>
</li>
<li><p>邏輯運算子(logical):<code>&amp;&amp;</code>(and)、<code>||</code>(or)，例如:<code>a || b</code>表示選擇a或b，常用於表達複合條件，設定初始值。</p>
</li>
<li><p>位元運算子(bitwise):將運算元當成32位元的0和1來看待，位元運算子將運算元以二進位的方式處㻫，接著以JavaScript數字型態回傳結果。例如:<code>5 &amp; 1</code>會被看成<code>0101 &amp; 0001</code>，得到結果0001，回傳1。 <a href="https://www.w3schools.com/js/js_bitwise.asp">點此</a>看更多範例。</p>
</li>
<li><p>字串運算子(string)：<code>+</code>可串接兩字元，並回傳結果，通常用連接變數與字串。不過目前改用ES6的字串模板(string template)了，使用<code>$&#123; variable_name&#125;</code>即可代入變數，而不需再用<code>+</code>與雙&#x2F;單引號拼湊字串，方便許多，範例如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Summer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字串運算子</span></span><br><span class="line"><span class="keyword">const</span> greetings_1 = <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>; <span class="comment">// &quot;Hello Summer!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字串模板</span></span><br><span class="line"><span class="keyword">const</span> greetings_2 = <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>; <span class="comment">// &quot;Hello Summer!&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>條件(三元)運算子(conditional&#x2F;ternary):條件(三元)運算子接再兩個運算元作為值且一個運算元作為條件。語法是<code>條件?值1：值2</code>。若「條件」為true，運算子回值「值1」,否則回傳「值2」。如下，條件<code>count &lt;= 0</code>得到false, 因此得到prompt為還有存貨」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> prompt = count &lt;= <span class="number">0</span> ? <span class="string">&#x27;全部賣完了&#x27;</span> : <span class="string">&#x27;還有存貨&#x27;</span>;</span><br><span class="line"></span><br><span class="line">prompt <span class="comment">// &quot;還有存貨&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>逗點運算子(comma):<code>,</code>用來隔開多個運算式並由左至右循序執行，最後會回傳最右邊的運算式的結果，通常用於(1)for迴圈內部，讓多個變數能在每次迴圈中被更新;(2)變數宣告。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">10</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`i: <span class="subst">$&#123;i&#125;</span>, j: <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i: 0, j: 10</span></span><br><span class="line"><span class="comment">// i: 1, j: 9</span></span><br><span class="line"><span class="comment">// i: 2, j: 8</span></span><br><span class="line"><span class="comment">// i: 3, j: 7</span></span><br><span class="line"><span class="comment">// i: 4, j: 6</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>一元運算子(unary):一元運算是只需要一個運算元的運算，例如:delete 運算子可刪除(隱式宣告的)物件，物件的(非內建)屬性或陣列中經由指定索引而找到的物件。其他的一元運算子還有typeof等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> x <span class="comment">// false</span></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> y <span class="comment">// true</span></span><br><span class="line">y <span class="comment">// Uncaught ReferenceError: y is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> product.<span class="property">count</span> <span class="comment">// true</span></span><br><span class="line">product <span class="comment">// &#123;name: &quot;apple&quot;&#125;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>關係運算子(relational)：關係運算子比較兩運算元並根據比較結果回傳布林值。例如：in運算子可得知特定屬性是否存在於物件中，instanceof可用來判斷是否為指定的物件型別。</p>
<p>in 運算子的範例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> product <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;valid&#x27;</span> <span class="keyword">in</span> product <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>instanceof運算子的範例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">product <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">product <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="運算式-Expression"><a href="#運算式-Expression" class="headerlink" title="運算式(Expression)"></a>運算式(Expression)</h4><p>  對「某個變數或值，或以運算子結合起來的一組變數或值」的參考(reference)。例如:<code>a = b+1</code>這個述句中有四個運算式，分別是1、b、<code>b +1</code>、<code>a = b + 1</code>，其中1是字面值運算式(literal value expression)、b是變數運算式(variable expression)用來取得變數的值、<code>b + 1</code>是算術運算式(arithmetic expression)用來進行加法運算，<code>a = b + 1</code>是指定遲算式(assignment expression)用來將結果指定給變數存起來。這裡順道一提「呼叫運算式（call expression）」，意即函式呼叫運算式本身，例如：<code>alert(a)</code></p>
<h4 id="值與型別-Values-Types"><a href="#值與型別-Values-Types" class="headerlink" title="值與型別(Values&amp;Types)"></a>值與型別(Values&amp;Types)</h4><p>型別，指的是「值的不同的表示法」，主要分為兩種「基本型別」(pirmitives, 即number、string、boolean、null、undefined、symbol)和「物件型別」(object)。</p>
<h5 id="基本型別-Primitive-Types"><a href="#基本型別-Primitive-Types" class="headerlink" title="基本型別(Primitive Types)"></a>基本型別(Primitive Types)</h5><ul>
<li><p>number 數字，例如：12345。</p>
</li>
<li><p>string 字串，例如:<code>Hello World</code></p>
</li>
<li><p>boolean 布林，例如：true、false。</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
<li><p>symbol</p>
</li>
</ul>
<h5 id="物件型別"><a href="#物件型別" class="headerlink" title="物件型別"></a>物件型別</h5><p>除了基本型別外的資料型別都是物件，物件型別又分以下子型別</p>
<ul>
<li><p>array 陣列：使用數值化索引來儲存值，而非如物件是使用屬性來儲存值。</p>
</li>
<li><p>function函式：一個函式是指一段具名的程式碼片段，我們可藉由呼叫其名稱來執行它，可簡化重複進行的工作會包裝特定功能的程式碼，並且函式可接受參數、回傳值。這裡會牽涉到另一個概念「範疇（Scope）」，範疇是指一群變數或這些變數如何透過名稱來存取的規範而組成的一個集合，關於範疇之後會再詳述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>(<span class="string">&quot;Jack&quot;</span>);<span class="comment">// Hi, I am Jack</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>date 日期</p>
</li>
</ul>
<h5 id="在型別之間進行轉換-Converting-Between-Types"><a href="#在型別之間進行轉換-Converting-Between-Types" class="headerlink" title="在型別之間進行轉換(Converting Between Types)"></a>在型別之間進行轉換(Converting Between Types)</h5><p>我們有時候會需要將資料在不同型別間轉換，例如，遇到在表單中輸入一連串的金額(此時是字串)，接著計算金額時就會希望將這些字串轉成數字來做加減乘除的操作，這時候就可能需要做轉型，從字串轉成數字。</p>
<p>例如、小明在蝦X買了一件商品準備在母親節送給媽媽，並選擇貨到付款。來看看商品金額、運費和總金額，商品金額(product)是100(以定串型態存在)，運費(shipment)也同樣是100(以數字型態存在)，𫍇時候總金額total是？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> shipment = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>咦？怎麼會正100100！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> total = product + shipment;</span><br></pre></td></tr></table></figure>

<p>原來是因為若兩值資料型別不同，當其中一方是字串，<code>+</code>所代表的就是字串運算子，而將數字強制轉型為字串，並連接兩個字串。解決就是使用Number強制轉型(coerce)，將字串的部份轉為數字就可以做數學運算了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> shipment = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title class_">Number</span>(product) + shipment;<span class="comment">//200</span></span><br></pre></td></tr></table></figure>

<p>除了強制轉型，來看在比較兩個非相同型別的值時候會發生隱含的(implicit)轉型。</p>
<p>例如，小明想要比較買這個商品付這運費划算嗎？運費該不會比商品還貴吧？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> shipment = <span class="number">100</span>;</span><br><span class="line">product === shipment <span class="comment">// false</span></span><br><span class="line">product == shipment <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>咦？一個是字串，一個是數字，是怎麼能做比較？這是由於JavaScript偷偷做了(隱含的)轉型的原因，那…到底做了什麼呢?</p>
<ul>
<li><p><code>product === shipment</code> : 不做轉型，因此型別對比較是有影響的。</p>
</li>
<li><p><code>product == shipment</code> : 會強轉型，規則是(1)布林轉數字；(2)字串轉數字；(3)使用<code>valueOf()</code>將物件取 基本型別的值，再做比較。關於強型轉型的詳細說明之後會再詳述或參考<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">規格</a>。</p>
<p>小明看到商品價格與運費居然相等，還是先湊個免運再買吧！</p>
</li>
</ul>
<h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>typeof 可用於檢測值的型別是什麼。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello World&quot;</span>);<span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">12345678</span>);<span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span> &#125;);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>());<span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;);<span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);<span class="comment">// objcet</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>);<span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>這裡會看到幾個有趣的(奇怪的)地方…</p>
<ul>
<li><p>null 是基本型別之一，但<code>typeof null</code>卻得到object,而非null!這可說是一個bug，可是若因為修正了這個bug，則可能會導致很多網站壞掉，因此就不修了！</p>
</li>
<li><p>雖然說function是物件的子型別，但<code>typeof functon()&#123;&#125;</code>是得到function而非object, 和陣列依舊得到object是不一樣的。</p>
</li>
<li><p>NaN表是是無效的數字，但依舊還是數字，因此在資料型別的檢測<code>typeof NaN</code>結果就是number。不要被字面上的意思「不是數字」(not a number)給弄糊塗了。另外，NaN與依何數字運算都會得到NaN，並且NaN不大於，不小於也不等於任何數字，包含NaN它自已。</p>
</li>
</ul>
<h5 id="內建方法-Built-In-Type-Methods"><a href="#內建方法-Built-In-Type-Methods" class="headerlink" title="內建方法(Built-In Type Methods)"></a>內建方法(Built-In Type Methods)</h5><p>意即物件以屬性(或稱方法)的形式對外提供的行為，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prompt = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prompt.<span class="property">length</span>);<span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>  這背後的原因是每個型基本上都會其物件包裏器(object wrapper,又稱原生natives)的型態做對應使用，例如資料別string的物件包裹器型態就是String，而就是這個包裹器型態在其原型(prototype)上定義了許多屬性和方法，因此這些資料型態就能和物件般擁有屬性和方法以供使用。</p>
<h5 id="相等性與不等性"><a href="#相等性與不等性" class="headerlink" title="相等性與不等性"></a>相等性與不等性</h5><h6 id="相等性-Equality"><a href="#相等性-Equality" class="headerlink" title="相等性(Equality)"></a>相等性(Equality)</h6><p>關於相等性的運算子有四個「<code>==</code>」(寬鬆相等性loose equality)、「<code>===</code>」(嚴格相等性strict equality) 、「<code>!=</code>」和「<code>!==</code>」。寬鬆與嚴格的差異在於檢查值相等時是否會做強制轉型，<code>==</code>會做強制轉型，而<code>===</code>不會。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a =<span class="string">&#x27;100&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);<span class="comment">// true 強制轉型，將字串 &#x27;100&#x27; 轉為數字 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a ===b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>另外，關於值的儲存方式有傳值「pass by value」和傳址&#x2F;參考「pass by referece」兩種，其中pass by value又可再細分是否為「pass by sharing」（可參考<a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">這篇</a>）、基本型別是值，而物件型別是傳址。當比較兩物件時，比較的是儲存的位置，因此看起來是相同的物件，但比較結果卻是不相同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h6 id="不等性-Inequality"><a href="#不等性-Inequality" class="headerlink" title="不等性(Inequality)"></a>不等性(Inequality)</h6><p>關於不等於性的比較運算子有<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>共四種，在這裡有幾種狀況需要注意</p>
<ul>
<li><p>若比較的值都是字串，則以字典的字母順序為主。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ab&quot;</span> &lt; <span class="string">&quot;cd&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>若比較的值型別不同，由於值的不等性比較沒有嚴格不相等這重性況，因此，為論什麼樣的比較都會被強制轉型為數字，無法轉為數字的就會變成NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;99&quot;</span> &gt; <span class="number">98</span>);<span class="comment">//true, 字串&quot;99&quot;被強昀轉型為數字 99</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span> &gt; <span class="number">1</span>);<span class="comment">//false 字串&quot;Hello World&quot; 無法轉為數字，變成NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span> &lt; <span class="number">1</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span> = <span class="number">1</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>NaN不大於、不小於、不等於任何值，當然也不等於自已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> &gt; <span class="title class_">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> &lt; <span class="title class_">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="程式碼註解-code-Comments"><a href="#程式碼註解-code-Comments" class="headerlink" title="程式碼註解(code Comments)"></a>程式碼註解(code Comments)</h4><p><code>//</code>和<code>/*...*/</code>。</p>
<p>程式碼註解有多重要就不用再提了吧！</p>
</li>
</ul>
<h4 id="變數-Variables"><a href="#變數-Variables" class="headerlink" title="變數(Variables)"></a>變數(Variables)</h4><p>變數是儲存值的地方，又稱為符號佔位器(symbolic placeholder),例如：<code>a = b + 1</code>中的a和b。變數的作用是「管理程式的狀態」，讓我們能將程式中各種會變動的狀態(也就是值)存起來並搭配運算子組成運算式做一些運算。注意，JavaScript是弱型別的語言，意即宣告變數，賦值後仍可改變值的資料型別。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 var 宣告一個物件</span></span><br><span class="line"><span class="keyword">var</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 let 宣告一個有作用域限制的變數，範圍限於大括號內</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Nina&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="常數-Constants"><a href="#常數-Constants" class="headerlink" title="常數(Constants)"></a>常數(Constants)</h4><p>ES6使用<code>const</code>來宣告常數，代表這變數的值不會改變，在嚴格模式下還會報錯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h4 id="命名規則"><a href="#命名規則" class="headerlink" title="命名規則"></a>命名規則</h4><p>變數的命名必須要為有效的識別字，何謂有效？就是必須以a-z、A-Z、<code>$</code>(錢字號)或<code>_</code>(底線)開頭，之後可加上a-z、A-Z、<code>$</code>(錢字號)、<code>_</code>(底線)和數字0-9，並且不可以是關鍵字或保留字。變數的命名規則同樣也適用於物件特性的命名，只是物件特性的名稱可為關鍵字或保留字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> happy = <span class="string">&#x27;happy&#x27;</span>; <span class="comment">// 這是合法的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> @@ = <span class="string">&#x27;sad&#x27;</span>; <span class="comment">// 這是不合法的，報錯「Uncaught SyntaxError: Invalid or unexpected token」</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="comment">// 這是合法的，物件的特性可使用關鍵字或保留字命名</span></span><br><span class="line">  <span class="attr">this</span>: <span class="string">&#x27;this is an object&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什麼是關鍵字？又什麼是保留字"><a href="#什麼是關鍵字？又什麼是保留字" class="headerlink" title="什麼是關鍵字？又什麼是保留字"></a>什麼是關鍵字？又什麼是保留字</h5><p>「<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Reserved_keywords_as_of_ECMAScript_2015">關鍵字</a>」（keyword）是指在目前ECMAScript中有特定用途的英文字詞，而「<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Future_reserved_keywords">保留字</a>」（reserved word）則是系統留爭，雖然目前尚未用到但未來可能有其他用途的字彙。<strong>再次強調，不管是關鍵字或保留字都不能做變數名稱使用。</strong></p>
<h4 id="區塊-Blocks"><a href="#區塊-Blocks" class="headerlink" title="區塊(Blocks)"></a>區塊(Blocks)</h4><p>區塊是由一對大括號(curly-brace pair、<code>&#123;...&#125;</code>)所規範出來的範圍。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// 區塊範圍在此...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="條件式-Conditionals"><a href="#條件式-Conditionals" class="headerlink" title="條件式(Conditionals)"></a>條件式(Conditionals)</h4><p>表達條件的𤆧法有if述句、switch述句、條件(三元)運算子和迴圈，以下分別述之。</p>
<ul>
<li><p>if述句，括號內的即是條件，若條件為真，則有指定的事情，括號內的條件放置運算式，運算結果是布林值true或false，若非布林值就會強制轉型(例如：0或空字串會被轉為false, 而其他就會轉為true)。範例如下，若商品金額大於運費，就買； 否則就不買。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> shipment = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title class_">Number</span>(product) + shipment; <span class="comment">//200</span></span><br><span class="line"><span class="keyword">if</span> (product &gt; shipment) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;But it !&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Do not buy it!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>結果得到「Do not buy it!」。</p>
</li>
<li><p>switch述句等同於if-else的縮寫，依靠break來決定是否要持續進行下一個case述句，若沒有break就會「落穿而過」。範例如下，這裡有一個檢測庫存的簡易範例，假設目前庫存數量為50，當庫存為0～2時提示要趕快進貨補庫存，庫存到達50時顯示庫存充裕，庫存到達100時提示貨品是不是賣不掉，其他狀況都顯示為運作正常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">switch</span> (count) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;快賣完了！趕快進貨！&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;庫存充裕&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是不是賣不後！？&quot;</span>)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;運作正常&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但出乎意料的是，結果印出「庫存充裕、是不是賣不掉了！？、運作正常」</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">庫存充裕</span><br><span class="line">是不是賣不掉了！？</span><br><span class="line">運作正常</span><br></pre></td></tr></table></figure>

<p>這是因為如果沒有加入break，一豆某個符合條件了，托下來的case無論侜合與否都會被執行，也就是剛才所提到的「落穿而過」。</p>
<p>加入break修正一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">switch</span> (count) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;快賣完了！趕快進貨！&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;庫存充裕&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;是不是賣不後！？&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;運作正常&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>結果印出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">庫存充裕</span><br></pre></td></tr></table></figure>

<ul>
<li>條件(三元)運算子(conditional&#x2F;ternary)</li>
<li>迴圈(loops)使用條件式來判斷迴圈是否繼續或停止。</li>
</ul>
</li>
</ul>
<h4 id="Truthy-Falsy"><a href="#Truthy-Falsy" class="headerlink" title="Truthy &amp; Falsy"></a>Truthy &amp; Falsy</h4><p>在JavaScript中會被轉為false的值有</p>
<ul>
<li><p><code>&quot;&quot;</code>空字串</p>
</li>
<li><p>0,-0,NaN</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
<li><p>false</p>
<p>而除了以上之外，都會被轉為true舉例如下</p>
</li>
<li><p><code>Hello World</code>非空字串</p>
</li>
<li><p>42非零的效數字</p>
</li>
<li><p><code>[],[1, 2, 3]</code>陣列，不管是不是空的</p>
</li>
<li><p><code>&#123;&#125;,&#123; name: &#39;Jack&#39;&#125;</code>物件，不管是不是空的</p>
</li>
<li><p><code>function foo()&#123;&#125;</code>函式</p>
</li>
<li><p>true</p>
<p>如果真的很不確定到底會轉成什麼，可以使用<code>!!</code>做測試</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!![] <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="迴圈-Loops"><a href="#迴圈-Loops" class="headerlink" title="迴圈(Loops)"></a>迴圈(Loops)</h4><p>重複一組動作，直到檢測條件不成立為止。迴圈的形成有很多動，最常用的就是while迴圈(while或do…while)和fot迴圈兩種。</p>
<h5 id="while迴圈"><a href="#while迴圈" class="headerlink" title="while迴圈"></a>while迴圈</h5><p>while迴圈的構成有以下要素：測試條件和區塊，而每次執行區塊時就稱為一次迭代(iteration)。</p>
<p><code>while</code>vs<code>do...while</code></p>
<p>兩者的差異在於<code>while</code>是先測後跑，而<code>do...while</code>是先跑後測。</p>
<p>來看第一個簡單例子，假設商品數量目前有五個，每賣掉一個就將庫存減一，當全賣完(及庫存為零)的時候就跳出迴圈，並印出「全部賣完了」的訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (product &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 4個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 3個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 2個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 1個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 0個。 </span><br><span class="line">全部賣完了 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但下面這個例子就超有不同了，此時更改商品數量為零，剛剛提到while是「先測後跑」，因此當檢驗測試條件時，發現<code>product &gt; 0</code>得到fals,也就不會進入區塊了，直接印出「全部賣完了」的訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (product &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>再來看<code>while...loop</code>，這個例子並無異狀，跟第一個例子所得到的結果完全相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (product &gt; <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 4個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 3個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 2個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 1個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 0個。 </span><br><span class="line">全部賣完了 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是…剛剛提到<code>while...loop</code>是「先跑後測」，我們又將商品數量改為零，此時會先進入區塊，依序印出「買一個」、商品數量減一、顯示「現在還剩-1個」、最後才檢驗測試條件、終止迴圈的執行，印出「全部賣完了」的訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (product &gt; <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 -1個。 </span><br><span class="line">全部賣完了 </span><br></pre></td></tr></table></figure>

<h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><p>使用break跳出迴圈。</p>
<p>範例如下，在product為2的時候跳出迴圈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (product &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;停停停，不要賣了！快進貨啊。&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 4個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 3個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 2個。 </span><br><span class="line">停停停，不要賣了！快進貨啊。 </span><br><span class="line">全部賣完了 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><p>使用continue跳過本次迭代，迴圈依舊持續進行。</p>
<p>範例如下，在product為2的成候忽略之後要執行的<code>console.log(現在還剩 $&#123;product&#125; 個);</code>直接進入下一次迭代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (product &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    product--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (product === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二個我要暗摃起來&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 4個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 3個。 </span><br><span class="line">買一個 </span><br><span class="line">第二個我要暗摃起來 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 1個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 0個。 </span><br><span class="line">全部賣完了 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="for迴圈"><a href="#for迴圈" class="headerlink" title="for迴圈"></a>for迴圈</h5><p>for迴圈有三個子句-初始化子句、條件測試子句、更新子句。</p>
<ul>
<li><p>初始化子句，例如：<code>let product = 5</code></p>
</li>
<li><p>條件測件子句，例如：<code>product &gt; 0</code></p>
</li>
<li><p>更新子句，例如:<code>product--</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> product = <span class="number">5</span>; product &gt; <span class="number">0</span>; product--) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;買一個&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`現在還剩 <span class="subst">$&#123;product&#125;</span>個。`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全部賣完了&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">買一個 </span><br><span class="line">現在還剩 5個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 4個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 3個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 2個。 </span><br><span class="line">買一個 </span><br><span class="line">現在還剩 1個。 </span><br><span class="line">全部賣完了 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="你懂JavaScript嗎？-變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill與Transpiler"><a href="#你懂JavaScript嗎？-變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill與Transpiler" class="headerlink" title="你懂JavaScript嗎？-變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill與Transpiler"></a>你懂JavaScript嗎？-變數、嚴格模式、IIFEs、閉包、模組、this、原型、Polyfill與Transpiler</h3><p>上面有大致聊過了一些基本普識，像是運算子、運算式、值與型別、變數、條件式、迴圈，本文還會再探討一些基礎概念，像是</p>
<ul>
<li><p><a href="#%E8%AE%8A%E6%95%B8(Variable)">變數</a>的存取規則，包含函式範疇、拉升、巢狀範疇。</p>
</li>
<li><p>嚴格模式：一個讓程式碼變得更，更容易優化的方法。</p>
</li>
<li><p>更多關於範疇和函式的應用，包含IIFE、閉包、模組</p>
</li>
<li><p>this：到底是指哪個？這個還是那個？應該不少人都黑人問號</p>
</li>
<li><p>原型可說是物件的一種fallback機制，並且提供了行為委派。</p>
</li>
<li><p>舊功能與新特色的共存，可使用Polyfill和Transpiler來做兼容。</p>
</li>
</ul>
<h4 id="變數-Variable"><a href="#變數-Variable" class="headerlink" title="變數(Variable)"></a>變數(Variable)</h4><p>這個部份要來談關於變數的存取規則，例如：範疇、拉升等。</p>
<h5 id="函式範疇-Function-Scope"><a href="#函式範疇-Function-Scope" class="headerlink" title="函式範疇(Function Scope)"></a>函式範疇(Function Scope)</h5><p>函式會建立自已的範疇，其內的識別字(不管是變數、函式)僅能在這個函式裡面使用。如下在全域範疇底下，是無法存取foo內的a、b、c和bar，否則會導致ReferrenceError；但在foo自已的函式範疇內，可以存取a、b、c和bar。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferrenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferrenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferrenceError</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferrenceError</span></span><br></pre></td></tr></table></figure>

<h5 id="拉升-Hoisting"><a href="#拉升-Hoisting" class="headerlink" title="拉升(Hoisting)"></a>拉升(Hoisting)</h5><p>在程式執行前，編譯器(compiler)會先由上到下逐行將程式碼轉為電腦可懂的命令，然後再執行編譯後的指令。在這個編譯的階段，編譯器找出所有的變數並繫結所屬範疇，但不賦，所以此刻變數所帶的值是undefined; 而在執行階段，JavaScript引擎才會處理給值的事情。</p>
<p>我們可以把這個過程想像成是嫄這些變數「提升」到程式碼的最頂端，如下範例所示，因此當印出a的值的時候，會是已宣告但還沒賦值的狀態，也就是有這個變數，但其值是undefined，一直到程式執行了，才給值。因此，我們可以在程式碼任何地方呼叫運用這變數，但只有在正式宣告之後才能有正確的值可用，在宣告之前使用都會得到undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 編譯時期的工作</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 執行時期的工作</span></span><br></pre></td></tr></table></figure>

<h5 id="巢狀範疇-Nested-Scope"><a href="#巢狀範疇-Nested-Scope" class="headerlink" title="巢狀範疇(Nested Scope)"></a>巢狀範疇(Nested Scope)</h5><p>若在目前執行的範疇找不到這個變數的時候，就會往外層的範疇搜尋，特續搜尋直到找到為止，或直到最外層的全域範疇(globl scope，在瀏覽器底下就是指window)。</p>
<p>如下<code>console.log(a + b)</code>中，b無法在foo中找到，但可從全域範疇中追出來。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>相較於巢狀範疇是以函式為劃分單位，區塊範疇就是以大括號為界線了。</p>
<h4 id="嚴格模式-Strict-Mode"><a href="#嚴格模式-Strict-Mode" class="headerlink" title="嚴格模式(Strict Mode)"></a>嚴格模式(Strict Mode)</h4><p>嚴格 鄉簡單說就是為了預防開發者的一些小心或錯誤的行為，JavaScript引擎協助做了一些檢測的工作，當開發都誤用時就把錯誤丟出來。可參考<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode">MDN</a>。</p>
<p>範例如下，在未宣告變數而賦值機狀況下，會無預警的產生一個全域變數，但若使用嚴格模式(<code>use strict</code>)則會禁止這行為外，還會報錯，告知開發都變數尚未被定義。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;user stict&#x27;</span>;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//Uncaught ReferenceRrrot: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>就把它想像成是一個諄教誨的好者師！總是願意告訴你殘忍的實話…</p>
<h4 id="作為值的函式-Function-as-Value"><a href="#作為值的函式-Function-as-Value" class="headerlink" title="作為值的函式(Function as Value)"></a>作為值的函式(Function as Value)</h4><p>這標題看起來有點怪怪的(?)但其實也只是要說明，函式本身就和其化的值一樣，是可以被指定給某變數、當參數傳遞或當成其它函式的回傳值。記得，函式也只是物件的子型別而已， 沒有什麼特別的。</p>
<p>指定給某個變數，如下，指定給foo。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;大家好，我是 foo!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當參數傳遞，如下，將foo當成是bar的參數傳入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;大家好，我是 foo!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="title function_">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>(foo);<span class="comment">// 大家好，我是 foo!</span></span><br></pre></td></tr></table></figure>

<p>當其他函式的回傳值，foo是baz的回值，並將結果指定給result。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;大家好，我是 foo!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">result</span>(foo)();<span class="comment">// 大家好，我是 foo！</span></span><br></pre></td></tr></table></figure>

<p>因此，這個函式值(例如：<code>var foo=function()&#123;...&#125;</code>)也可被視為是一個運算式，就稱呼它為「函式運算式」吧。之後還會提到函式宣告、函式運算式與匿名vs具名，待後續詳細的說明。</p>
<h4 id="即刻調用函式運算式-Immediately-Invoked-Function-Expression-IIFE"><a href="#即刻調用函式運算式-Immediately-Invoked-Function-Expression-IIFE" class="headerlink" title="即刻調用函式運算式(Immediately Invoked Function Expression,IIFE)"></a>即刻調用函式運算式(Immediately Invoked Function Expression,IIFE)</h4><p>IIFE是為可立即執行的函式運算式。一般的函式運算式並不會馬上執行、若要執行除了在其名稱後加上小括號外，還可以利用IIFE的𤆧式執行它。匿名或具名皆合法。使用IIFE的好處主要是不污染全域範疇。</p>
<p>範例如下，這是一個匿名的IIFE，a在全域範疇是找不到的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不污染全域範疇</span></span><br><span class="line">a;<span class="comment">//Uncaught ReferenceError:a is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="閉包-Closure"><a href="#閉包-Closure" class="headerlink" title="閉包(Closure)"></a>閉包(Closure)</h4><p>閉包是指變數的生命週其只存在於該函式內，一旦離開了函式，該變數就會被回收而不可再利用，且必須在函式內事先宣告。</p>
<p>範例如下，在函式closure內可以存取a的值，但離開了函式closure走到全域範疇之下，就取不到a的值了，因此會被報錯「Uncaught ReferenceError:a is nto defined」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">closure</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">closure</span>();</span><br><span class="line">a;<span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="模組-Module"><a href="#模組-Module" class="headerlink" title="模組(Module)"></a>模組(Module)</h4><p>模組模式(Module Pattern)又稱為揭露模組(RevealingModule),經由建立一個模組實體(Moduel Instance，如下範例的foo), 來調用內層函式。而內層函式由於具有閉包的特性。因此可存取外層包含函式(Oute Enclosing Function)之內的變數和函式。透過模組模式，可隱藏私密的資訊，並對外公開API。</p>
<p>範例如下，CoolModule對外公開API doSomething和doAnother, CoolModule之外是無法取得其私有的something𢘊another兩個變數的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&quot; ! &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">        <span class="attr">doAnother</span>: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">CoolModule</span>();</span><br><span class="line">foo.<span class="title function_">doSomething</span>();<span class="comment">// cool</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>();</span><br></pre></td></tr></table></figure>

<h4 id="this識別字-this-Identifier"><a href="#this識別字-this-Identifier" class="headerlink" title="this識別字(this Identifier)"></a>this識別字(this Identifier)</h4><p>this到底是指向誰一直都是個令人費解的問題。</p>
<p>簡單來說，this是function執行時所屬的物件，而this是在執行時期做繫結，其值和函式在哪裡被呼叫(call-site)有關。</p>
<p>總結規則如下，並以匹配的優先順序由高至低排列</p>
<ul>
<li>new 綁定：this會指向new出來的物件。</li>
<li>明確綁定：使用call、apply、bind，明確指出要綁定給this的物件。</li>
<li>隱含綁定：當函式為物件的方法(method)時，在執行階段this就會被綁定至該物件。</li>
<li>預設綁定：當其他規則都適用時，意即沒有使用bind,call, apply或不屬於任何物件的method，就套用預設綁定，在非嚴格模式下，瀏覽器環境this的值就是預設值全域物件window，而在嚴格模式下，this的值就是undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;obj2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// &#x27;global&#x27;</span></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// &#x27;obj1&#x27;</span></span><br><span class="line">foo.<span class="title function_">call</span>( obj2 ); <span class="comment">// &#x27;obj2&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a>原型(Prototype)</h4><p>原型可說是物件的一種callback機制，當在此物件找不到指定屬性時，就會透過原型鏈結(prototype link&#x2F;prototype reference)追溯到其父物件上。範𠕥如下，若想存取<code>bar.a</code>但由於bar並為a屬性。因此𠺾會透過原型鏈結找到foo,並得偌100這個值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">a</span>: <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title class_">Object</span>.<span class="title function_">create</span>(foo); <span class="comment">// 建立 bar 物件，並連結到 foo</span></span><br><span class="line">bar.<span class="property">b</span> = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">bar.<span class="property">a</span> <span class="comment">// 100，委派給 foo</span></span><br><span class="line">bar.<span class="property">b</span> <span class="comment">// &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，原型最常應用於「行為委派」(behaviro delegation)，如上例所示，將物件bar的行為委派給foo, 這也是常聽到很類似於其他語言的類別的繼承功能，但其實完全不同。</p>
<h4 id="舊功能與新特色的共存"><a href="#舊功能與新特色的共存" class="headerlink" title="舊功能與新特色的共存"></a>舊功能與新特色的共存</h4><p>面對新舊功能並存的狀況要怎麼處理呢？這裡要介紹兩種方法-Polyfill和Tranxpiler。</p>
<h5 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h5><p>Polyfilling的意思就是依據一個新功能的定義，製作具有相同行無，而能在較舊的JavaScript環境執行的程式碼，候話說就是為舊瀏覽掛載新功能。</p>
<p>這裡來看一個例子，針對isNan的改進…</p>
<h6 id="isNan"><a href="#isNan" class="headerlink" title="isNan"></a>isNan</h6><p>NaN表示值無效的數字，它會產生的原因是</p>
<ul>
<li><p>做數字運算時的兩個運算元的資料型別並非都數字或無法轉成有的十進位或十六進位的數字。</p>
</li>
<li><p>無意義的運算，例如:0&#x2F;0, Infinity&#x2F;Infinity。</p>
</li>
</ul>
<p>以上𣄵會產生NaN。</p>
<p>在ES6以前，開發者使用<code>isNaN</code>在數學運算或解析字串後檢測得到的結果是否為合法的數字，其實就是檢測是否為NaN，其過程為先將輸入值使用Number強制轉為數字。無法轉為有的數字而得到NaN時就判定等於NaN，結果得到true。</p>
<p>範例如下，空物件<code>&#123;&#125;</code>經過isNaN判斷是NaN，意即不為數字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(&#123;&#125;));<span class="comment">//</span></span><br><span class="line"><span class="comment">// 拆宗詳細過程如下</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(&#123;&#125;)); <span class="comment">// 先將空物件轉為數字，得到NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)); <span class="comment">// 檢查是不否為 NaN，得到true</span></span><br></pre></td></tr></table></figure>

<p>其它範例還有..</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(-<span class="number">1.23</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">5</span>-<span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello World&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;2000/01/01&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;NaN&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span>/<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但這檢測方式常常會讓開發者得到讓人容易誤解的結果(像是空物件<code>&#123;&#125;</code>就真的不等於NaN呀)，因此ES6推出了<code>Number.isNaN</code>，<code>Number.isNaN</code>不會經過轉為數字的這過程，而是直托判斷型別否為數字且是否等於NaN。承上範𠕥，檢測空物件<code>&#123;&#125;</code>是否為NaN，得到false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// 直接檢查空物件是否為 NaN，得到 false</span></span><br></pre></td></tr></table></figure>

<p>同樣也來看剛才的範例…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(-<span class="number">1.23</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">5</span>-<span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;Hello World&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;2000/01/01&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;NaN&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span>/<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>雖然ES6出了這個新功能，但不見得所有的瀏覽器都會支援，因此對於較舊瀏覽，就掛個polyfill來模擬這個新功能。</p>
<p>polyfill如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">isNaN</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">isNaN</span> = <span class="keyword">function</span> <span class="title function_">isNaN</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x; <span class="comment">// NaN 是唯一一個不等於自己的值</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6定義了常數<code>Number.NaN</code>來表示NaN</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>.<span class="property">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">Number</span>.<span class="property">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由於實作 polyfill 難免會有缺漏或疏失，這裡提供兩個經過嚴格審核的函式庫以供使用-<a href="https://github.com/es-shims/es5-shim">es5-shim</a> 和 <a href="https://github.com/es-shims/es6-shim">es6-shim</a>。</p>
<h6 id="Transpiler"><a href="#Transpiler" class="headerlink" title="Transpiler"></a>Transpiler</h6><p>並非所有的新功能都能經由polyfill掛載到舊環境上，這裡提出另一個解法，將帶有新功能的程式碼換成等效的舊有程式碼碼可以了，也就是使用transpiler做轉譯。</p>
<p>例如，ES6推出了新功能「預設參數值」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a = <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">42</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>但這在舊的JavaScript引擎中是無 的，因此transpiler就會將以上程式碼變形，翻譯成等 的舊程式碼。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="variable language_">arguments</span>[<span class="number">0</span>] !== (<span class="keyword">void</span> <span class="number">0</span>) ? <span class="variable language_">arguments</span>[<span class="number">0</span>] : <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這麼做的好處是在開發階段開發者依然能享受新功能帶來的好處，但又能兼顧到新舊瀏覽器的狀況。這裡也推薦一些很棒的 transpiler，像是 <a href="https://babeljs.io/">Babel</a>、<a href="https://github.com/google/traceur-compiler">Traceur</a> 等。</p>
<h3 id="你懂JavaScript嗎-型別-Types"><a href="#你懂JavaScript嗎-型別-Types" class="headerlink" title="你懂JavaScript嗎?型別(Types)"></a>你懂JavaScript嗎?型別(Types)</h3><p>主要會談到</p>
<ul>
<li>何謂「型別」？內建型別有哪些？常見疑難雜症與解法</li>
<li>未定義(undefined) vs 未宣告(undeclared)</li>
</ul>
<h4 id="何謂「型別」？"><a href="#何謂「型別」？" class="headerlink" title="何謂「型別」？"></a>何謂「型別」？</h4><p>「型別」是固有的、內建的特微，能唯一識別特定值的行為。例如：數字123和字串’123’就是不一樣的，數字123可做數學運算處理，而字串’123’可能就是做些顯示到畫面上的操作。</p>
<h4 id="內建型別-Built-In-Types"><a href="#內建型別-Built-In-Types" class="headerlink" title="內建型別(Built-In Types)"></a>內建型別(Built-In Types)</h4><p>JavaScript定義了以下七種內建型別</p>
<ul>
<li><p>number數字，例如:12345</p>
</li>
<li><p>string字串，例如：<code>Hello World</code></p>
</li>
<li><p>boolean布林，例如:true、false</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
<li><p>object物件，例如：<code>&#123; name: &#39;Jack&#39; &#125;</code>、<code>&#123;1, 2, 3&#125;</code>、<code>function foo() &#123; ... &#125;</code></p>
</li>
<li><p>symbol</p>
</li>
</ul>
<p>其中，這些內建型別又可分兩大類-基本型別(primitives)和物件型別(object)。基本型別有number、string、boolean、null、undefined、symbol，而物件型別就是物件與其子型別(subtype)，例如：物件、陣列、函式、日期等。</p>
<p>我們可用<code>typeof</code>來檢測值的資料型別為何。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;Hello World&#x27;</span>);<span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">12345678</span>);<span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>()); <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);<span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>);<span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>這裡會看到幾個有趣的(奇怪的)地方…</p>
<ul>
<li><p>null 是基本型別之一，但<code>typeof null</code>卻得到object，而非null！這可說是一個bug，可是若修正了這個bug則可能會導致很多網站壞掉，因此就不修了！</p>
</li>
<li><p>雖然說function是物件的子型別，但<code>typeof functon()&#123;&#125;</code>是得到function而非object，和陣列依舊得object是不一樣的。另外順道一提函式是一種「可呼叫的物件」(callable object),它擁有<code>[[Call]]</code>的內部特性，讓它成為能夠被調用的物件。</p>
</li>
<li><p>NaN表示是無效的數字，但依舊還是數字，因此在資料型別的檢測<code>typeof NaN</code>結果就是number，不要被字面上的意思「不是數字」(not a number)給弄糊塗了。另外、NaN與依何數字運算都會得到NaN、並且NaN不大於、不小於也不等於依何數字，包含NaN它自已。</p>
</li>
</ul>
<p>先來解決剛剛提到的幾個問題。</p>
<h4 id="Q1-如何檢測null？"><a href="#Q1-如何檢測null？" class="headerlink" title="Q1:如何檢測null？"></a>Q1:如何檢測null？</h4><p>之前有提到的Truthy&amp;Falsy的概念，在做比較時會被轉型為fals的值有</p>
<ul>
<li><p><code>&quot;&quot;</code>空字串</p>
</li>
<li><p>0，-0，NaN</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
<li><p>false</p>
</li>
</ul>
<p>而除了以下之外，都會被轉無true,與例如下</p>
<ul>
<li><p><code>Hello World</code>非空字串</p>
</li>
<li><p>42非零的有效數字</p>
</li>
<li><p><code>[],[1, 2, 3]</code>陣列，不管是不是空的</p>
</li>
<li><p><code>&#123;&#125;,&#123;name:&#39;Jack&#39;&#125;</code>物件，不管是不是空的</p>
</li>
<li><p><code>function foo()&#123;&#125;</code>函式</p>
</li>
<li><p>true</p>
<p>我們可利用null會被typeof檢測為object並且會轉為false的結果來驗證是否為null.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> happy = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!happy &amp;&amp; <span class="keyword">typeof</span> happy === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是 null!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到「我是null !」，輕鬆解決，得分！</p>
<h4 id="Q2-既然函式與陣列都是物件，那其中的屬性length有什麼不同"><a href="#Q2-既然函式與陣列都是物件，那其中的屬性length有什麼不同" class="headerlink" title="Q2:既然函式與陣列都是物件，那其中的屬性length有什麼不同?"></a>Q2:既然函式與陣列都是物件，那其中的屬性length有什麼不同?</h4><p>函式的length是指參數個數，而陣列的length是指內部成員個數。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testMe</span>(<span class="params">arg1, arg2, arg3</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is testMe!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testMe.<span class="property">length</span>);<span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="property">length</span>);<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="Q3-typeof檢測的對象是誰"><a href="#Q3-typeof檢測的對象是誰" class="headerlink" title="Q3:typeof檢測的對象是誰?"></a>Q3:typeof檢測的對象是誰?</h4><p>再次強調，變數沒有型別，變數可在不同時間點持有不同型別的值，因此，只有「值」才有型別，雖然我們可用typeof檢測某個變數所儲存的值的型別，至記得並不是檢崱變數本身，而是變數所存的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> name <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Q4:辨識物件子型別的方法?</p>
<p>稍後在Natives(原生功能)的部分會說明取得物件內部分類的方法，這裡就先大略提一下。</p>
<p>物件型別的值其內部有一個<code>[[Class]]</code>屬性來標記這個值是屬於物件的哪個子分類，雖然無法直接取用，但可透過<code>Object.prototye.toString</code>間接取得，範例如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> <span class="title function_">SayHi</span>(<span class="params"></span>) &#123;&#125;));<span class="comment">//[objcet Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/helloworld/i</span>));<span class="comment">//[object RegExp]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));<span class="comment">//[object Date]</span></span><br></pre></td></tr></table></figure>

<h4 id="未定義-undefined-vs未宣告-uneclared"><a href="#未定義-undefined-vs未宣告-uneclared" class="headerlink" title="未定義(undefined)vs未宣告(uneclared)"></a>未定義(undefined)vs未宣告(uneclared)</h4><ul>
<li><p>未定義(undefined):未賦值的變數所儲存的值是undefined,對此變數做typeof也會得到<code>undefined</code></p>
</li>
<li><p>未宣告(undeclared):變數在未宣當並使用的狀況下會得到ReferenceError，並指出該變數並未宣告； 變數在未宣告並賦值的狀況下，在嚴格模式下會報錯ReferenceError，而在非嚴格模式，變數會成為全域變數的屬性。注意，對未宣告的變數做typeof也會得到<code>undefined</code>。</p>
</li>
</ul>
<p>總結𣄵是，無論變數是未定義或未宣告、typeof這兩種狀況皆會得到<code>undefined</code>。那麼，對未宣告的變數做typeof而得到<code>undefined</code>，有什麼用處呢?</p>
<h4 id="對未宣告的變數做typeof"><a href="#對未宣告的變數做typeof" class="headerlink" title="對未宣告的變數做typeof"></a>對未宣告的變數做typeof</h4><p>對未宣告的變數做typeof而得到<code>&#39;undefined&#39;</code>可說是一保護措施，可避免瀏覽器丟出ReferenceError的錯誤訊息，在撰寫測試特定條件時常會用到。</p>
<p>範例如下，我們可能在非正式環境下會引用了某支js檔案，其中會設定DEBUG為ture，而其它檔案會根據DEBUG變數是否被宣告並設定為true時做出相對應的事情。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable constant_">DEBUG</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// start to debug...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或著，我們也可以不用typeof的作法，而改用檢測window屬性的方式，同樣也不會丟出ReferenceError。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">DEBUG</span>) &#123;</span><br><span class="line">  <span class="comment">// start to debug...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再或者，使用依存性注入(dependency injection)的方式也是可以的，將要檢測的條件當參數傳入函式，若條件不存在則使用預設值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingCool</span>(<span class="params">DEBUG</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> helper = <span class="variable constant_">DEBUG</span> || <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 預設值 */</span> &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是這解法已被ES6的預設傳入參數(Degault Paramaters)取代了。</p>
<h3 id="你懂JavaScript嗎？值-Values-Part1-陣列、字串、數字"><a href="#你懂JavaScript嗎？值-Values-Part1-陣列、字串、數字" class="headerlink" title="你懂JavaScript嗎？值(Values)Part1-陣列、字串、數字"></a>你懂JavaScript嗎？值(Values)Part1-陣列、字串、數字</h3><p>主要會談到關於陣列、字串、數字的錯誤操作方式與疑難雜症的解法。</p>
<h4 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列(Array)"></a>陣列(Array)</h4><p>陣列是由數值做索引，可由任何型別值所構成的群集。在𫍇裡要先提到兩個容易誤用的重點-(1)稀疏陣列誤存undefined的元素和(2)使用「很像數字」的字串當成鍵值來存資料時，鍵值被強制轉型為數字的狀況，最後會提到「類陣列」的操作。</p>
<h5 id="稀疏陣列-Sparse-Array"><a href="#稀疏陣列-Sparse-Array" class="headerlink" title="稀疏陣列(Sparse Array)"></a>稀疏陣列(Sparse Array)</h5><p>稀疏陣列是指陣列中有插槽(slot)可能未定義其值或被略過而導致存放undefined元素的狀況，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line">list[<span class="number">0</span>] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">list[<span class="number">2</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list[<span class="number">1</span>]); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="property">length</span>) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numlist = [];</span><br><span class="line">numlist[<span class="number">0</span>] = <span class="number">123</span>;</span><br><span class="line">numlist[<span class="number">2</span>] = <span class="number">456</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numlist[<span class="number">1</span>]); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numlist.<span class="property">length</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>這會有什麼問題呢?</p>
<p>由於這可能是一些疏忽或鏌誤操作所造成的，因此會對length有錯誤的期待，例如，可能原本其待list的長度為2，但因錯置了字串<code>&#39;World&#39;</code>的位置，導致list的長度為3，存之後陣列的操作上可能會出現很難發現的<strong>bug</strong>。</p>
<p>這種<strong>bug</strong>就是所謂的<strong>地雷</strong>，你永遠不知道它什麼時候會爆炸，一旦爆炸就死傷慘動、很難挽救。</p>
<h5 id="鍵值的強制轉型"><a href="#鍵值的強制轉型" class="headerlink" title="鍵值的強制轉型"></a>鍵值的強制轉型</h5><p>若使用「很像數字」的字串當成鍵值來存資料，鍵值會被強制轉型為數字，這也會造成後續處理上的難題，像是產生剛剛提到的稀疏矩陣的狀況(又是地雷一枚)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line">list[<span class="number">0</span>] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">list[<span class="string">&#x27;20&#x27;</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list[<span class="string">&#x27;20&#x27;</span>]);<span class="comment">// World</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="property">length</span>);<span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>陣列其實也就是物件的子型別而已，所以若想用字串當成鍵值來存放資料也是可以的，只是鍵值會被強制轉型為數字。如上所示，鍵值<code>20</code>被強制轉為數字20，導致list成為稀疏陣列，其長度就被誤判了。因此，若索引值是數字就用陣列，而非數字就用物件吧！</p>
<h4 id="類陣列-Array-Like"><a href="#類陣列-Array-Like" class="headerlink" title="類陣列(Array-Like)"></a>類陣列(Array-Like)</h4><p>類陣列是指以數值索引的值所成的群集，它可能是串列但並非真正的陣列，例如：DOM物件操作後所得偌的串列、函式引數所形成的串列(ES6已棄用)。而為了能操作這些類陣列的元素，就必須將類陣列轉為真正的陣列，這樣就進行indexOf、concat、forEach等的操作了。</p>
<p>DOM物件操作後所得到的串列，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">list <span class="comment">// HTMLCollection(3) [div, div, div]</span></span><br><span class="line">list.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>函式引數所形成的串列，範例如下，取得不定個數的引數。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr= <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);<span class="comment">//(1)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//(2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>得到</p>
<ul>
<li><p>(1)<code>&#123; [Iterator]    0: &#39;hello&#39;,   1: &#39;world&#39;,   2: &#39;bar&#39;,   3: &#39;baz&#39;,   [Symbol(Symbol.iterator)]: [λ: values] &#125;</code></p>
</li>
<li><p>(2)<code>[ &#39;hello&#39;, &#39;world&#39;, &#39;bar&#39;, &#39;baz&#39; ] </code></p>
</li>
</ul>
<p>以下可知，函數引數所形成的類陣列，在經過 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">slice</a> 轉換後可得到真正的陣列以供後續操作。注意，slice會回傳一個指定開始到結束部份的新陣列，因此在不傳人任何參數的狀況下等同於複製陣列。</p>
<p>或使用<code>Array.from</code>也會有同樣的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr= <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);<span class="comment">//(1)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//(2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="comment">//(1)`&#123; [Iterator]    0: &#x27;hello&#x27;,   1: &#x27;world&#x27;,   2: &#x27;bar&#x27;,   3: &#x27;baz&#x27;,   [Symbol(Symbol.iterator)]: [λ: values] &#125;</span></span><br><span class="line"><span class="comment">//(2)`[ &#x27;hello&#x27;, &#x27;world&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="字串-String"><a href="#字串-String" class="headerlink" title="字串(String)"></a>字串(String)</h4><p>這部分還是繼續來看關於類陣列的處理。</p>
<h5 id="可變-Mutable-與不可變-Immutable"><a href="#可變-Mutable-與不可變-Immutable" class="headerlink" title="可變(Mutable)與不可變(Immutable)"></a>可變(Mutable)與不可變(Immutable)</h5><p>JavaScript在創建變數，賦值後是可變的(mutable)；相較於mutable，不可變(immutable)就是指在創建變數、賦值後便不可改變，若對其任何變更(例如：新增、修改、刪除)，就會回傳一個新值。</p>
<p>當需要更新一個變數的時候，若值的型態為基本型態，則是不可變的，意即只要改變就會回傳一個新的值； 若值的型態為物型態，則由於物件是使用call by reference的方式其享資料來源，因此只是就地更新而已，或說是更新這個位置所儲存的值，而非回傳一新的值。</p>
<h5 id="字串的類陣列處理"><a href="#字串的類陣列處理" class="headerlink" title="字串的類陣列處理"></a>字串的類陣列處理</h5><p>字串可不可以當成陣列來處理呢？可以的，而且可以借用陣列的方法來做些事情，只是要注意，<strong>不能變更陣列的內容</strong>。</p>
<h5 id="插入間隔字元"><a href="#插入間隔字元" class="headerlink" title="插入間隔字元"></a>插入間隔字元</h5><p>如下，借用陣列的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/join">join</a> 來實作在字串間插人字元。join和map都不會變動到原始陣列的內容，因為回傳的結果是一個新的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str_another = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(str, <span class="string">&#x27;--&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> str_the_other = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(str, <span class="function">(<span class="params">char</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;char.toUpperCase()&#125;</span>.`</span></span><br><span class="line">&#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);<span class="comment">//foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str_another);<span class="comment">//f--o--o</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str_the_other);<span class="comment">//F.O.O. </span></span><br></pre></td></tr></table></figure>

<h5 id="反轉"><a href="#反轉" class="headerlink" title="反轉"></a>反轉</h5><p>但revere是會改變原始陣列資料的，因此字串就不能借用。如下所示，arr經反轉由 <code>[&#39;b&#39;, &#39;a&#39;, &#39;r&#39;]</code> 改變為 <code>[&quot;r&quot;, &quot;a&quot;, &quot;b&quot;]</code>。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>();<span class="comment">//[ &#x27;r&#x27;, &#x27;a&#x27;, &#x27;b&#x27; ] </span></span><br><span class="line">arr;<span class="comment">//[ &#x27;r&#x27;, &#x27;a&#x27;, &#x27;b&#x27; ] </span></span><br></pre></td></tr></table></figure>

<p>所以若想借用陣列的reverse來反轉字串，就會被報錯了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str_another = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reverse</span>.<span class="title function_">call</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;0&#x27; of object &#x27;[object String]&#x27; at String.reverse</span></span><br></pre></td></tr></table></figure>

<p>面對無法借用陣列方法的狀況，可先將字串轉為陣列，在進行操作(像是反轉)，最後再轉回字串即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str_thoe_other = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">str_thoe_other;<span class="comment">//oof </span></span><br></pre></td></tr></table></figure>

<p>但以上是不是看起來眼醜陋又麻煩？因此最好的方法是先把資料存成陣列，再使用陣列的方法操作，後續若需要使用字串表示，再用join打平串起就可以了！</p>
<h4 id="數字-Number"><a href="#數字-Number" class="headerlink" title="數字(Number)"></a>數字(Number)</h4><p>JavaScript的數字(number)型別包含兩種-整數和帶有小數的浮點數，其中數字的實作是以<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a> 為標準，也就是浮點數(floating-point number)的雙精度(double precision)格式，意渡64位元的二進位數字。</p>
<h5 id="如何表達「非常大」或「非常小」的數字？"><a href="#如何表達「非常大」或「非常小」的數字？" class="headerlink" title="如何表達「非常大」或「非常小」的數字？"></a>如何表達「非常大」或「非常小」的數字？</h5><p>非常大或非常小的數值以「指數」的方式呈現。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a =<span class="number">1E20</span>;</span><br><span class="line"><span class="keyword">const</span> b =a*<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> c= a/<span class="number">0.001</span>;</span><br><span class="line">a;<span class="comment">//100000000000000000000 </span></span><br><span class="line">b;<span class="comment">//1e+22</span></span><br><span class="line">c;<span class="comment">//1e+23</span></span><br><span class="line"><span class="comment">// 使用 toExponential 手動轉指數呈現</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toExponential</span>());<span class="comment">//1e+20 </span></span><br></pre></td></tr></table></figure>

<h5 id="如何指定小數位數"><a href="#如何指定小數位數" class="headerlink" title="如何指定小數位數?"></a>如何指定小數位數?</h5><p>使用toFixed指定要顯示的小數位數，會做四捨五入，不足會補零，注意結果會以「字串」格式呈現。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123.456789</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toFixed</span>(<span class="number">1</span>));<span class="comment">//123.5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toFixed</span>(<span class="number">2</span>));<span class="comment">//123.46</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toFixed</span>(<span class="number">3</span>));<span class="comment">//123.457</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toFixed</span>(<span class="number">10</span>));<span class="comment">//123.4567890000 </span></span><br></pre></td></tr></table></figure>

<h5 id="如何指定有效位數"><a href="#如何指定有效位數" class="headerlink" title="如何指定有效位數?"></a>如何指定有效位數?</h5><p>使用toPrecision指定有效位數，會做四捨五入，不足會補零，注意結果會以「字串」格式呈現。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123.456789</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">1</span>));<span class="comment">//1e+2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">2</span>));<span class="comment">//1.2e+2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">3</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">4</span>));<span class="comment">//123.5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">5</span>));<span class="comment">//123.46</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toPrecision</span>(<span class="number">10</span>));<span class="comment">//123.4567890 </span></span><br></pre></td></tr></table></figure>

<p>注意，數字後加上<code>.</code>會讓JavaScript引擎先判定為小數點，而非屬性存取。因此，若希望<code>100.toPrecision(1)</code>能正常顯示，應該為<code>100..toPrecision(1)</code>或<code>(100).toPrecision(1)</code>。</p>
<h5 id="如何表示其它基數的數字"><a href="#如何表示其它基數的數字" class="headerlink" title="如何表示其它基數的數字?"></a>如何表示其它基數的數字?</h5><ul>
<li><p>十六進位：加上前綴「0x」或「0X」</p>
</li>
<li><p>八進位：加上前綴「0o」或「0O」</p>
</li>
<li><p>二進位：加上前綴「0b」或「0B」</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0xAB</span>);<span class="comment">//171</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0o65</span>);<span class="comment">//53</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0b11</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>  頭昏眼花了嗎？<code>0x</code>、<code>0o</code>、<code>0b</code> 可不是表情符號喔！</p>
<h5 id="如何表示十進位小數"><a href="#如何表示十進位小數" class="headerlink" title="如何表示十進位小數?"></a>如何表示十進位小數?</h5><p>只要是使用IEEE754來表示二進位浮點數的程式語言都有一個夢靨-無法精準地表示十進位的小數，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span>+<span class="number">0.2</span> === <span class="number">0.3</span>);<span class="comment">//false </span></span><br></pre></td></tr></table></figure>

<p>將 0.1、0.2 和 0.3 分別轉為二進位來看</p>
<ul>
<li>0.1 轉成二進位表示為 0.0001100110011…（0011 循環）</li>
<li>0.2 轉成二進位表示為 0.00110011001100…（1100 循環）</li>
<li>0.3 轉成二進位表示為 0.0100110011001…（1001 循環）</li>
</ul>
<p>因此 0.1 + 0.2 永遠不會剛好等於 0.3。</p>
<p>解法是取一個很小的誤差當作容許值，若運算結果小於這個誤差值就判斷為等於，在ES6中已定義好這個常數<code>Number.EPSILON</code>其值為2^-52, 或實作polyfill如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,-<span class="number">52</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那…要怎麼使用這個<code>Number.EPSILON</code>呢?先實作一個函equal，它會判斷誤差是否小於容許值-先將兩輸入值的差取絕對值，再與<code>Number.EPSILON</code>做比對，若小於這個誤差值就判𪼙為兩數相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">equal</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(n1-n2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">0.1</span>+<span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> b= <span class="number">0.3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equal</span>(a,b));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equal</span>(<span class="number">0.0000001</span>, <span class="number">0.0000002</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h5 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h5><p>ES6定義所謂「安全」的數值範圍為</p>
<ul>
<li>整數：最大整數<code>Number.MAX_SAFE_INTEGER</code>(其值為 2^53 - 1 等於 9007199254740991）、最小整數 <code>Number.MIN_SAFE_INTEGER</code>（其值為 -9007199254740991）。</li>
<li>浮點數：最大浮點數 <code>Number.MAX_VALUE</code>（其值為 1.798e+308）、最小浮點數 <code>Number.MIN_VALUE</code>（其值為 5e-324）。</li>
</ul>
<h5 id="如何知道數值是個整數？如何知道數值位在安全範圍內？"><a href="#如何知道數值是個整數？如何知道數值位在安全範圍內？" class="headerlink" title="如何知道數值是個整數？如何知道數值位在安全範圍內？"></a>如何知道數值是個整數？如何知道數值位在安全範圍內？</h5><p>使用<code>Number.isInteger</code>來測試數值是否為整數。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">42</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">42.000</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">42.3</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Number.isSafeInteger</code>來測試數值是否在安全範圍內。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>polyfill</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">isSafeInteger</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">isSafeInteger</span> = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="title function_">isInteger</span>( num ) &amp;&amp;</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">abs</span>( num ) &lt;= <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32位元有號整數-32-bit-Signed-Integer"><a href="#32位元有號整數-32-bit-Signed-Integer" class="headerlink" title="32位元有號整數(32-bit Signed Integer)"></a>32位元有號整數(32-bit Signed Integer)</h5><p>部份運算(例如：位元運算bitwise operator)只允𧥸使用32位元的有號整數，其範圍為<code>Math.pow(-2,31)</code>到<code>Math.pow(2,31)-1</code>。</p>
<p>在做這類運算前必須先把數值使用<code>|0</code>轉為32位元的有環整數</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> integer = <span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">const</span> signed_integer = integer | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="你懂JavaScript？值-Values-Part2-特殊值"><a href="#你懂JavaScript？值-Values-Part2-特殊值" class="headerlink" title="你懂JavaScript？值(Values)Part2-特殊值"></a>你懂JavaScript？值(Values)Part2-特殊值</h3><p>主要內容為探討基本型別的特殊值並能適當使用它們。</p>
<h4 id="undefined與void運算子"><a href="#undefined與void運算子" class="headerlink" title="undefined與void運算子"></a>undefined與void運算子</h4><p>void運算子可確保運算式不回傳任何值(其實是得到undefined),並且不修改現有值。</p>
<p>例如，𫍇僤有一個變數hello，其值為777，結合void運算子做運算後會得到undefined,但hello內儲存的值仍是不變的，依舊是777。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="number">777</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> hello <span class="comment">// undefined</span></span><br><span class="line">hello <span class="comment">// 777</span></span><br></pre></td></tr></table></figure>

<p>實際上會應用到什麼狀況呢？</p>
<p>一，運算式的結果真的希望<strong>不回傳任何值</strong>(再次強調，其實是回傳undefined)，除了直接寫「undefined」外，還可以用「void某個值」，通常會用「void0」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result= <span class="title function_">sayHi</span>()</span><br><span class="line">result <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>二，在程式設定下，必須區別有意義和無意義的回傳值，而無意義的回傳值希望能是undefined，以避免後續誤判為「有意義」的回傳值而做了錯誤的操作，如下範例所示，這裡有一個定期檢查回傳結果的函式check，check會呼叫函式getResult來得到運算結果並確認結果為何，若沒有得到結果，就顯示經過的分鐘數；若得到結果就印出「工作完成」的訊息。在這裡無意義的回傳值是使用undefined，但當然很多開發者是比較喜歡用false或null，就看當時的需求和個人喜好摟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> interval = <span class="number">60000</span>;</span><br><span class="line"><span class="keyword">let</span> start = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 經由一些運算得到結果 result，若有結果則 flag &quot;isDone&quot; 設為 true 並回傳結果；若無結果則 flag &quot;isDone&quot; 設為 false 並回傳 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// 等同於 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不斷重複詢問是否得到結果？若沒有得到結果，就顯示經過的分鐘數；若得到結果就印出「工作完成」的訊息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> progress = timestamp - start;</span><br><span class="line">  <span class="keyword">if</span> (start === <span class="literal">null</span>) &#123; start = timestamp; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (progress &lt; interval) &#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(check);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getResult</span>()) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;工作完成！&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`checking...time passed: <span class="subst">$&#123;counter&#125;</span> minute(s).`</span>);</span><br><span class="line">      counter++;</span><br><span class="line">      start = timestamp;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(check);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(check);</span><br></pre></td></tr></table></figure>

<h4 id="NaN-無效的數字"><a href="#NaN-無效的數字" class="headerlink" title="NaN(無效的數字)"></a>NaN(無效的數字)</h4><p>NaN表示值為無效的數字(invalid number)，會產生NaN的原因是</p>
<ul>
<li><p>做數字運算時的兩個運算元的資料型並非都是數字或無法轉成有效的十進位或十來進位的數字</p>
</li>
<li><p>無意義的運算，例如：<code>0/0</code>、<code>Infinity/Infinity</code>都會得到NaN</p>
</li>
</ul>
<p>就會產生NaN</p>
<p>NaN有幾個有趣的議題…以下分別討論之。</p>
<h5 id="typeof-1"><a href="#typeof-1" class="headerlink" title="typeof"></a>typeof</h5><p>NaN既然表示是效的數字，依舊還是數字，因此在資料型別的檢測<code>typeof NaN</code>結果就是number，不要被字面上的意思「不是數字」(not a number)給弄糊塗了。</p>
<h5 id="運算結果是NaN"><a href="#運算結果是NaN" class="headerlink" title="運算結果是NaN"></a>運算結果是NaN</h5><p>NaN與任何數字運算都會得到NaN。</p>
<h5 id="唯一不大於、不小於、不等於自已的值"><a href="#唯一不大於、不小於、不等於自已的值" class="headerlink" title="唯一不大於、不小於、不等於自已的值"></a>唯一不大於、不小於、不等於自已的值</h5><p>NaN不大於、不小於也不等於任何值，包含NaN它自已。</p>
<h5 id="isNaN與Number-isNaN"><a href="#isNaN與Number-isNaN" class="headerlink" title="isNaN與Number.isNaN"></a><code>isNaN</code>與<code>Number.isNaN</code></h5><p>要如何檢測運算結果是否為有效的數字呢？那麼就來檢測是否為無效的數字-NaN就可以了，在ES6以前，開發者使用<code>isNaN</code>在數學運算或解析字串後檢測得到的結果是否為合法的數字，其實就是檢測是否為NaN，其過程為先將輸入值使用Number強制轉型為數字，若無法轉為有效的數字而得偌NaN時就判定等於NaN，結果得到true。</p>
<p>範例如下，空物件<code>&#123;&#125;</code>經過isNaN判斷是NaN，意即為無效的數字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(&#123;&#125;));<span class="comment">//true</span></span><br><span class="line"><span class="comment">// 拆解詳細過程如下...</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;);<span class="comment">//先將空物件轉為數字，得到NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);<span class="comment">// 檢替是否為NaN，得到true</span></span><br></pre></td></tr></table></figure>

<p>其他範例還有…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">123</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(-<span class="number">1.23</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">5</span>-<span class="number">2</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;2000/01/01&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;NaN&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">1</span>/<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>但這檢測方式的常常會讓開發者得到<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/isNaN#%E4%BB%A4%E4%BA%BA%E5%9B%B0%E6%83%91%E7%9A%84%E7%89%B9%E6%AE%8A%E7%8B%80%E6%B3%81%E8%A1%8C%E7%82%BA">讓人容易誤解的結果</a>(像是…大多數的人都會爭論…空物件<code>&#123;&#125;</code>就真的不等於NaN呀)，因此ES6推出了<code>Number.isNaN</code>、<code>Number.isNaN</code>不會經過轉為數字的這個過程，而是直接判斷型別是否為數字且是否等於NaN。承上範例，使用<code>Number.isNaN</code> 檢測空物件<code>&#123;&#125;</code>是否為NaN，得到false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>同樣也來看剛才的範例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(-<span class="number">1.23</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">5</span>-<span class="number">2</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;2000/01/01&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;NaN&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span>/<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>雖然ES6出了這個新功能，但不見得所有的瀏覽都會支援，因此對於較舊的瀏器就掛個polyfill來模擬這個新功能。</p>
<p>polyfill如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">isNaN</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">isNaN</span> = <span class="keyword">function</span> <span class="title function_">isNaN</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x; <span class="comment">// NaN 是唯一一個不等於自己的值</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="無限-Infinity"><a href="#無限-Infinity" class="headerlink" title="無限(Infinity)"></a>無限(Infinity)</h5><p>無限分為正無限(在ES6定義為Number.POSITIVE_INFINITY)和負無限(在ES6為<code>Number.NEGSTIVE_INFINITY</code>)，在數字連算中會得到無限的原因是</p>
<ul>
<li>除以零，例如：<code>1/0</code>得到Infinity，<code>-1/0</code>得到-Infinity</li>
<li>溢位(overflow)，例如：<code>Number.MAX_VALUE + Math.pow(2,970)</code>得到Infinity(備註)</li>
</ul>
<p>又，無限與無限做數字運算，一般來說會得到無限。除了..</p>
<ul>
<li><p>無意的運算，例如：<code>0/0</code>、<code>Infinity/Infinity</code>都會得到NaN</p>
</li>
<li><p><code>1/Infinity</code>得到0，<code>-1/Infinity</code>得偌-0</p>
</li>
</ul>
<p>備註：若運算結果接近<code>Number.MAX_VALUE</code>而非Infinity，則會取一個最接近的值為<code>Number.MAX_VALUE</code>，𫍇稱為「向下約整」(rounds down);同理，若運算結果接近Infinity而非<code>Number.MAX_VALUE</code>, 則會取一個最接近的值為Infinity，𫍇稱為「向上約整」(rounds up)</p>
<h4 id="零-Zero"><a href="#零-Zero" class="headerlink" title="零(Zero)"></a>零(Zero)</h4><p>零分為正零(+0)和負零(-0)，正負號在表達方向上是很有用的。其中，產生負零的原因是乘除運算中，運算元的其中一方為負數，例如：<code>-0/1</code>或<code>0/-1</code>會得到-0。</p>
<p>零有幾個有趣的議題…以下分別討論之。</p>
<h5 id="數字轉字串vs字串轉數字"><a href="#數字轉字串vs字串轉數字" class="headerlink" title="數字轉字串vs字串轉數字"></a>數字轉字串vs字串轉數字</h5><p>不管是正零(+0)或負霧(-0)，轉字串後一律為「<code>0</code>」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((+<span class="number">0</span>).<span class="title function_">toString</span>());<span class="comment">// &quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(+<span class="number">0</span>));<span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> + (+<span class="number">0</span>));<span class="comment">//&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((-<span class="number">0</span>).<span class="title function_">toString</span>());<span class="comment">// &quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(-<span class="number">0</span>));<span class="comment">//&quot;0&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> + (-<span class="number">0</span>));<span class="comment">//&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p>相反的、若從字串轉數字，則</p>
<ul>
<li><p>字串正零(<code>&#39;+0&#39;</code>)會轉成數字0或報錯，但其實正零一般來說都是表示為「0」</p>
</li>
<li><p>字串負零(<code>&#39;-0&#39;</code>)會轉成數字-0</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;+0&#x27;</span>);<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;+0&#x27;</span>));<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;+0&#x27;</span>));<span class="comment">// Uncaught SyntaxError: Unexpected token + in JSON at positi</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;-0&#x27;</span>);<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;-0&#x27;</span>));<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;-0&#x27;</span>));<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h5 id="如何辨別正零和負零"><a href="#如何辨別正零和負零" class="headerlink" title="如何辨別正零和負零?"></a>如何辨別正零和負零?</h5><p>正零(+0)或負零(-0)是無法從比較運算子和相等運算子中得到差異。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span> / -<span class="number">1</span>; <span class="comment">// -0</span></span><br><span class="line"></span><br><span class="line">a == b; <span class="comment">// true</span></span><br><span class="line">-<span class="number">0</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a === b; <span class="comment">// true</span></span><br><span class="line">-<span class="number">0</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &gt; -<span class="number">0</span>;	<span class="comment">// false</span></span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>那到底要如何辨別正零和負零呢？</p>
<p>解法的𦂇驟如下</p>
<ol>
<li><p>先將輸入值轉為數字，若為-0則<code>Number(-0)</code>為-0,並檢查結果是否等於胕</p>
</li>
<li><p>由於<code>1/-0</code>得到-Infinity，因此就可檢測輸入值是否為負零</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNegZero</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    n = <span class="title class_">Number</span>(n);</span><br><span class="line">    <span class="keyword">return</span> (n === <span class="number">0</span>) &amp;&amp; (<span class="number">1</span> / n === -<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 測試</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isNegZero</span>(-<span class="number">0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isNegZero</span>(<span class="number">0</span> / -<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isNegZero</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>  稍後會再提供另一個解法-<code>Object.is(..)</code></p>
<h5 id="特殊相等性-Special-Equality"><a href="#特殊相等性-Special-Equality" class="headerlink" title="特殊相等性(Special Equality)"></a>特殊相等性(Special Equality)</h5><p>針對負零(-0)和NaN的比較，除了以上提過的方法外，還可以用<code>Object.is(..)</code>來做檢測。</p>
<p><code>Object.is(..)</code>會比較兩值是否相等，而<code>Object.is(..)</code>的運作和嚴格相等是一樣的，但會將NaN、-0、和+0獨立處理。到底㤰麼定義「相等」呢？有興趣的可以參考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">MDN</a>的說明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Number</span>(<span class="string">&#x27;Hello World&#x27;</span>);<span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span> / -<span class="number">1</span>; <span class="comment">//-0 </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(a,<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(b,-<span class="number">0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(b,<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>世紀難題都被它解決了，</p>
<h3 id="你懂JavaScript嗎？原生功能-Natives"><a href="#你懂JavaScript嗎？原生功能-Natives" class="headerlink" title="你懂JavaScript嗎？原生功能(Natives)"></a>你懂JavaScript嗎？原生功能(Natives)</h3><p>主要會談到</p>
<ul>
<li><p>何謂原生功能(Natives)?</p>
</li>
<li><p>物件包裹器、陷阱、解封裝。</p>
</li>
<li><p>各類建搆子的原生功能、原生的原型。雖然優先使用字面值而非使用建構子建立物件、還是需要來看一些需要關心的議題和警惕用的錯誤用法。</p>
</li>
</ul>
<h4 id="何謂原生功能-Natives"><a href="#何謂原生功能-Natives" class="headerlink" title="何謂原生功能(Natives)?"></a>何謂原生功能(Natives)?</h4><p>原生功能(Natives)其實指的就是「內建函式」(built-in function)，最常用的像是<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>、<code>Array()</code>、<code>Object()</code>、<code>Function()</code>、<code>RegExp()</code>、<code>Date()</code>、<code>Error()</code>、<code>Symbol()</code>，其中null和undefined是沒有內建函式的。我們也可以將Natives當成建構子(constructor)來建立值。注意，使用建構子建立出來的值是一僤包裹了基本型別值的物件包裹器(object wrapper)，而這個包裹器在其原型(prototype)上定義了許多屬性和方法，因此這些資料型態就能如物件般擁有屬性和方法以供使用。</p>
<p>範例如下，使用<code>new String(&#39;...&#39;)</code>來建立字串值「Hello World!」，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);<span class="comment">//String &#x27;Hello World!&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toString</span>());<span class="comment">// &quot;Hello World!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s <span class="keyword">instanceof</span> <span class="title class_">String</span>);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(s));<span class="comment">//[object String]</span></span><br></pre></td></tr></table></figure>

<p>說明</p>
<ul>
<li><p>s是一個包裹了基本型別值String的物件包裹器，簡稱為「字串包裹器物件」，包裹了字串「Hello World!」，而非只是建立了字串本身。</p>
</li>
<li><p>s這個字串包裹器物件的原型上定義了toString方法，因此可使用<code>s.toString()</code>得到字串值。</p>
</li>
<li><p>使用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a> 來判斷值的型別，例如，<code>typeof s</code>檢視s的型別，結果是「物件」。</p>
</li>
<li><p>使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a> 來判斷值是否為指定的物件型別，例如，<code>s instanceof String</code>確認s為String的實體物件。</p>
</li>
<li><p>使用<code>Object.prototype.toString</code>取得物件的子分類、得到字串。</p>
</li>
</ul>
<h4 id="Internal-Class"><a href="#Internal-Class" class="headerlink" title="Internal[[Class]]"></a>Internal<code>[[Class]]</code></h4><p>物件型別的值其內部有一固<code>[[Class]]</code>屬性來標記這個值是屬於物件的哪個子分類，雖然無法直接取用，但可透過<code>Object.prototype.toString</code>  間接取得，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">//[object String] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>));<span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>));<span class="comment">//[object Null]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>));<span class="comment">//[object Undefined] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));<span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;));<span class="comment">//[object Object] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; &#125;));<span class="comment">//[object Function] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/helloworld/i</span>));<span class="comment">//[object RegExp]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));<span class="comment">//[object Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)));<span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<h4 id="封裝用的包裹器-BoxingWrappers"><a href="#封裝用的包裹器-BoxingWrappers" class="headerlink" title="封裝用的包裹器(BoxingWrappers)"></a>封裝用的包裹器(BoxingWrappers)</h4><p>由於JavaScirpt引擎會自動為基本型別值包裹(或稱封裝)物件包裹器，因此字面值能𢁍屬性或方法可用，例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">length</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>那麼，直托使用物件形式的物件包裹器來宣告變數，而非隱含地讓JavaScript引擎轉換，是不是比較好呢？答案是否定的，第一，這樣效能不佳，使用字面值可讓JavaScript預先編譯並快取起來！第二，沒有必要，字面值可幾乎可完全取代物件包裹器做的事情-因此，就讓JavaScript引擎自動為我們做這個封裝的工作吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello World!&#x27;</span>);<span class="comment">//錯誤示範！效能差！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">length</span>);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s_the_other= <span class="title class_">Object</span>(<span class="string">&#x27;Hello World!&#x27;</span>);<span class="comment">// 錯誤示範！效能差！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_the_other.<span class="property">length</span>);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s_another =<span class="string">&#x27;Hello World!&#x27;</span>;<span class="comment">//正確示範！效能佳！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_another.<span class="property">length</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<h4 id="物件包裹器的陷阱-Object-Wrapper-Gotchas"><a href="#物件包裹器的陷阱-Object-Wrapper-Gotchas" class="headerlink" title="物件包裹器的陷阱(Object Wrapper Gotchas)"></a>物件包裹器的陷阱(Object Wrapper Gotchas)</h4><p>由於直接使用物件形式的物件包裹器來宣告變數會造縑一些誤用，像是難以做條件判斷，因此非常不建議這麼做！使用之前請三思！</p>
<p>如下範例，使用物件包裹器宣告一個布林變數isValid，其值希望是false，但實際上卻是一個物件<code>Boolean &#123;true&#125;</code>，導致進入判斷式轉型為true, 印出訊息「可以繼續運作…」</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可以繼續運作...&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不合規則，等得處理...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以繼續運作...</span></span><br></pre></td></tr></table></figure>

<p>怎麼辦？很簡單，「解封裝」就行啦！繼續看下去吧！</p>
<h4 id="解封裝-Unboxing"><a href="#解封裝-Unboxing" class="headerlink" title="解封裝(Unboxing)"></a>解封裝(Unboxing)</h4><p>解封裝是指將底層的基本型別值取出來。</p>
<p>承上範例，isValid的值居然是物件<code>Boolean &#123;true&#125;</code>，只好使用<code>valueOf</code>來抽出底層的基型值摟，其他強制轉型的方法待後強制轉型的部份補充。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isValid.<span class="title function_">valueOf</span>()<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="建構子的原生功能"><a href="#建構子的原生功能" class="headerlink" title="建構子的原生功能"></a>建構子的原生功能</h4><p>再次強調，優先使用字面值而非使用建構子建立物件。但在這個「建構子的原生功能」部份，我們還是來看一些需要關心的議題和警惕用的錯誤用法。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array(..)"></a><code>Array(..)</code></h5><ul>
<li>不管是否使用new，陣列的物件包裹器所建立的物件是相同的，意即<code>new Array(...)</code>和<code>Array(...)</code>同義。</li>
<li>若只傳入一個數字，則不會被當成陣列內容，而會是陣列長度來預先設定陣列的大小，實際上這是個虛胖的空陣列，而裡面沒有存任何東西，是empty。這種具有空插槽(empty slot)的陣列在做陣列處理時容易產生不可預期的錯誤。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title class_">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// (10) [empty × 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>);<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b =[<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">delete</span> b[<span class="number">1</span>]);<span class="comment">// true，成功刪除一個元素？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">// [undefined, empty, undefined]，這裡產生一個空插槽！</span></span><br></pre></td></tr></table></figure>

<h5 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp(..)"></a><code>RegExp(..)</code></h5><p>在正規表達式方 ，只有一種狀況會需要用到物件包裹器而非字面值，就是必須「動態地」為正規表達式建立範式(pattern)，意即<code>new RegExp(&#39;pattern&#39;,&#39;flags&#39;)</code>的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b(?:&quot;</span> + name + <span class="string">&quot;)+\\b&quot;</span>, <span class="string">&quot;ig&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="variable">matches</span> <span class="operator">=</span> <span class="string">&#x27;Hi, Apple&#x27;</span>.match(pattern);</span><br><span class="line"></span><br><span class="line">console.log(matches);<span class="comment">//[ &#x27;Apple&#x27; ] </span></span><br></pre></td></tr></table></figure>

<h5 id="Date-與Error"><a href="#Date-與Error" class="headerlink" title="Date(..)與Error(..)"></a><code>Date(..)</code>與<code>Error(..)</code></h5><p>Data與Error沒有字面值格式，只能用物件包裹器作為建構子的方式建立物件。</p>
<p>Error需要注意的地方是，不管是否使用new，陣列的物件包裹器所建立的物件是相同的，意即<code>new Error(...)</code>和<code>Error(...)</code>同義。</p>
<h5 id="Symbol-…"><a href="#Symbol-…" class="headerlink" title="Symbol(…)"></a>Symbol(…)</h5><p>Symbol同樣沒有字面值格式，若要自定義的Symbol，就要使用建構子<code>Symbol(..)</code>且不可在前面加上new，否則會報錯。</p>
<h4 id="原生的原型-Native-Prototype"><a href="#原生的原型-Native-Prototype" class="headerlink" title="原生的原型(Native Prototype)"></a>原生的原型(Native Prototype)</h4><p>每個建構子都有自已的<code>.prototype</code>物件，例如：<code>Array.prototype</code>、<code>String.prototype</code>等，而這些<code>.prototype</code>物件擁有各自子物件的專屬行為。白話來說，就是經由建構子建立的物件與經由JavaScript引擎封裝的字面值，由於原型委派(prototype delegation)的緣故，都能使用定義<code>.prototype</code>的屬性和方法。例如，無論是經由<code>String()</code>建構子或經由JavaScript引擎封裝的字串基本型別字面值，由於原型委派(prototype delegation)的綠故，都能使用定義於<code>String.prototype</code>的屬性和方法。又<code>String.prototype.XYZ</code>可簡寫為<code>String#XYZ</code>，例如：<code>String#indexOF(..)</code>、<code>String#charAt(..)</code>等，其他型別都各自有其行為。</p>
<p><strong>注意，不要任意修改這些預設的原生的原型</strong>(甚至建議不要無條件地擴充原生的原型，若要擴充也應撰寫符合規格的崱試程式)，這在後續強制轉型的部份會看到一虛例子。</p>
<p><code>Array.prototype</code>是空陣列，<code>Function.prototype</code>是空的函式，<code>RegExp.prototype</code>是空的正規很達式，因此有人會拿來做為變數的初始值，雖然可能節省了重新創建新值和垃圾回收的工作而讓效能變好，但這可能會在無意間修改了這些預設的原生的原型，這是要避免的。</p>
<h3 id="你懂JavaScript嗎？強制轉型-Coercion"><a href="#你懂JavaScript嗎？強制轉型-Coercion" class="headerlink" title="你懂JavaScript嗎？強制轉型(Coercion)"></a>你懂JavaScript嗎？強制轉型(Coercion)</h3><p>強制轉型(coercion)到底是的個有用的功能，還是設計上的缺陷呢?</p>
<p>主要會談到</p>
<ul>
<li><p>強制轉型(coercion)分為兩種，分別是「明確的」強制轉型(explicit coercion)和「隱含的」強轉型(implicit coercion)，只要是程式碼中刻意寫出來的型別轉換動作，就是明確的強制轉型；反之，在程式碼沒有明確指出要轉換型別卻轉型的，就是隱含的強制轉型。</p>
</li>
<li><p>明確的強型轉型規則與範例說明。</p>
</li>
<li><p>隱含的強型轉型規則歹範例說明。</p>
</li>
<li><p>Symbol的強制轉型的規則與範例說明。</p>
</li>
<li><p>隱含的強制轉型的心酸血淚？各種令人崩潰的範例。</p>
</li>
<li><p>押象的關系式比較。</p>
</li>
</ul>
<h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>強制轉型(coercion)分為兩種，分別是「明確的」強制轉型(explicit coercion)和「隱含的」強制轉型(implicit coercion)，只要是程式碼中刻意寫出來的型別轉換的動作，就是明確的強制轉型； 反之，在程式碼中沒有明確指出要轉換型卻轉型的，就是隱含的強制轉型。</p>
<p>範例如下，b的的值由運算式<code>String(a)</code>而來，這裡表明會將a強制轉為字串，因此是明確的強制轉型； 而c的值由運算式<code>a + &#39;&#39;</code>而來，當兩值的型別不同且其中一方是字串時，<code>+</code>所代表的是定字串運算子，要將兩字串做串接，而會將數字強制轉型為字串，並連接兩個字串，因此是隱含的強制轉型，稍後會再詳述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">String</span>(a); <span class="comment">//明確的強制轉型</span></span><br><span class="line"><span class="keyword">var</span> c = a + <span class="string">&#x27;&#x27;</span>;<span class="comment">//隱含的強制轉型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">// &#x27;42&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">// &#x27;42&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意，無論是明確或隱含，強制轉型的結果會是基本型別值，例如：數字，布林或字串，</p>
<h4 id="抽象的值運算"><a href="#抽象的值運算" class="headerlink" title="抽象的值運算"></a>抽象的值運算</h4><p>「抽象的值運算」指的是「內部限定的運算」，意即這是JavaScirpt引擎在背後偷偷幫我們做的工作，在這個部分會來探討ToString、ToNumber、ToBoolen和ToPrimitive這幾個押象的值運算，來看看到底在強轉型時背地裡做了什麼好事。</p>
<h5 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h5><p>任何非字串的值被強制轉型為字串時，會遵循ES5的規格中的 <a href="https://es5.github.io/#x9.8">ToString</a> 來運作。</p>
<p>規則簡單說明如下</p>
<ul>
<li><p>undefined-&gt; <code>undefined</code>。</p>
</li>
<li><p>null-&gt;<code>null</code>。</p>
</li>
<li><p>boolean的true-&gt;<code>true</code>，false-&gt;<code>false</code>。</p>
</li>
<li><p>在數字方面，非常大或非常小的數字以指數呈現，例如:<code>1.23e21</code>。</p>
</li>
<li><p>物件</p>
<ul>
<li><p>若有定義<code>toString</code>方法，則會以它自已的<code>toString</code>方法所產生的結果為優先，例如，陣列有自己定義的<code>toString</code>方法，因此<code>[1,2,3].toString()</code>會得到<code>&quot;1,2,3&quot;</code>。</p>
</li>
<li><p>若沒有定義<code>toString</code>方法，則回傳內部的屬性<code>[[Class]]</code>，這是一個用來標記這個值是屬於物件的哪個子分類的標籤，例如：<code>(&#123;&#125;).toString()</code>會得到<code>[object Object]</code>。</p>
<img src="tostring-conversions.png" style="zoom:85%;" />

<p>圖片來源：<a href="https://es5.github.io/#x9.8">ToString Conversions</a></p>
</li>
</ul>
</li>
</ul>
<h4 id="JSON的字串化-JSON-Stringification"><a href="#JSON的字串化-JSON-Stringification" class="headerlink" title="JSON的字串化(JSON Stringification)"></a>JSON的字串化(JSON Stringification)</h4><p>順道一提JSON的字串化。</p>
<p>JSON的字串化<code>JSON.stringify</code>將值序列化(serialize)為JSON字串，這個轉無JSON字串的過程與ToString規則有關，但並不等於強制轉型。規則算簡單說明如下</p>
<ul>
<li>若為簡單值，即字串、數字、布林、null，則規與ToString相同。這些能轉為JSON字串的值稱為是「JSON-safe」的值，意即只要對JSON來說是安全的(safe)，就都能轉為JSON字串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="number">42</span>));<span class="comment">//&quot;42&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">true</span>));<span class="comment">//&quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">null</span>));<span class="comment">//&quot;null&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">`Hello World`</span>));<span class="comment">//&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>無法轉為JSON字串的非法值有undefined、function、symble、具有徝環參考(circular reference)的物件，由於它們無法轉為JSON字串，因此<code>JSON.stringify</code>會自動忽略這些非法值或丟出錯誤。又，若陣列中某個元素的值無非法值則自動以null取代；若物件中的其中的一個屬性為非法值，則會非除這個屬性。</p>
</li>
<li><p>若無物件具有定義<code>toJSON</code>方法則會優先呼叫此方法，並依此方法之回傳值作為序列化的結果，因此，若試圖JSON字串化一個含有非法值的物件，應定義其<code>toJSON</code>方法以回傳適當的JSON-safe的值。</p>
<p>範例如下。</p>
<p>若陣列中某個元素的值為非法值則會自動以null取代； 若物件中的其中一個屬性為非法值，則會非除這個屬性。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="literal">undefined</span>));<span class="comment">// undefined、忽略非法值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;));<span class="comment">// undefined、忽略非法值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Symbol</span>()));<span class="comment">// undefined、忽略非法值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">undefined</span>]));<span class="comment">//// &quot;[1,2,3,null]&quot;，非法值以 null 取代</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125; &#125;));<span class="comment">//&quot;&#123;&quot;a&quot;:2&#125;&quot;，忽略非法屬性</span></span><br></pre></td></tr></table></figure>

<p>具有循環參考的物件，丟出錯誤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">someProperty</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">anotherProperty</span>: a &#125;;</span><br><span class="line">a.<span class="property">b</span> = b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a));<span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b));<span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<p>針對含有非法值的物件或具有循環參考的物件，解法是定義其<code>toJSON</code>方法以回傳JSON-safe的值。</p>
<p>範例如下，物件someObj含有非法的屬性會導致轉JSON字串時被忽略，因此定義其<code>toJSON</code>方法只要序列化合法的a屬性即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;,<span class="comment">//非法！</span></span><br><span class="line">    <span class="attr">toJSON</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">2</span>,<span class="comment">// 序𦕁化過程只包含a屬性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someObj));<span class="comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>再看一個範例，對於「具有循環參考的物件」該怎麼處理呢？如下，a和b是具有循環參考的物件，在先前的例子中<code>JSON.stringify(a)</code>和<code>JSON.stringifg(b)</code>會丟出錯誤「Uncaught TypeError:Converting circular structure to JSON」，因此分別定義其<code>toJSON</code>方法，這裡的序列化過程只包含prompt屬性且其值為字串<code>Hello World</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">someProperty</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">prompt</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    <span class="attr">anotherProperty</span>: a,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">prompt</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span> = b;</span><br><span class="line"><span class="comment">// 序列化成功！不會被報錯了！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a));<span class="comment">// &quot;&#123;&quot;prompt&quot;:&quot;Hello World&quot;&#125;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b));<span class="comment">// &quot;&#123;&quot;prompt&quot;:&quot;Hello World&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了<code>toJSON</code>外，<code>JSON.stringify</code>也可傳入第二個選擇性參數「取代器」(replacer,可為陣列或函式)來自訂過濾機制，決定序列化過程中應該包含哪些屬性。</p>
<ul>
<li><p>取代器為陣列時，陣列內的元素為指定要包含的屬性名稱。如下，指定序列化過程中只需要包含a屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someObj,[<span class="string">&#x27;a&#x27;</span>]));<span class="comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>取代器為函數時，函式是用來運算要回傳以做序列化的屬性的值。如下，指定除了b以外的屬性都要做序列化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someObj, <span class="keyword">function</span> (<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h5><p>若需要將非數字當成數字來操作，像是做數學運算，就會遵循ES5的規格中的<a href="https://es5.github.io/#x9.3">ToNumber</a> 來運作。規則簡單說明如下</p>
<ul>
<li><p>undefined -&gt; NaN。</p>
</li>
<li><p>null -&gt; +0即是0。</p>
</li>
<li><p>boolean 的true -&gt; 1，false -&gt; +0 即是0。</p>
</li>
<li><p>string -&gt; 數字或NaN。</p>
</li>
<li><p>object</p>
<ul>
<li><p>若有定義其<code>valueOf</code>方法，則會優先使用<code>valueOf</code>取得其基本型別值。</p>
</li>
<li><p>若沒有定義<code>valueOf</code>方法，則會改用<code>toString</code>方法取得其基本型別值，再用ToNumber轉為數字，在這裡先簡化為<code>Number(..)</code>會來處理這一連串的流程即可。</p>
</li>
<li><p>注意，以<code>Object.create(null)</code>建立的null沒有<code>valueOf</code>或<code>toString</code>方法，因此在式圖轉為基本型別值的時候會出錯，丟出TypeError. </p>
<img src="tonumber_conversions.png" style="zoom:85%;" />

<p>圖片來源：<a href="https://es5.github.io/#x9.3">ToNumber Conversions</a></p>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">undefined</span>));<span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">null</span>));<span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">true</span>));<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">false</span>));<span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;12345&#x27;</span>));<span class="comment">// 12345</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;Jace&#x27;</span>&#125;));<span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">valueOf</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;999&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a));<span class="comment">// 999</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h5><p> 讓我們複習一下 Truthy 與 Falsy 的概念，這會遵循 ES5 的規格中的 <a href="https://es5.github.io/#x9.2">ToBoolean</a> 來運作。</p>
<img src="toboolean_conversions.png" style="zoom:85%;" />

<p>圖片來源：<a href="https://es5.github.io/#x9.2">ToBoolean Conversions</a></p>
<h6 id="Falsy值"><a href="#Falsy值" class="headerlink" title="Falsy值"></a>Falsy值</h6><p>在JavaScirpt中會被轉為false的值有</p>
<ul>
<li><p><code>&quot;&quot;</code>空字串</p>
</li>
<li><p>0,-0,NaN</p>
</li>
<li><p>null</p>
</li>
<li><p>undefined</p>
</li>
<li><p>false</p>
<p>我們只要熟記這幾個值就可以了！</p>
</li>
</ul>
<p>而除了以上的值之外，都會被轉為ture,與例如下</p>
<ul>
<li><p><code>&#39;Hello World&#39;</code>非空字串。</p>
</li>
<li><p>42非零的有效數字</p>
</li>
<li><p><code>[],[1,2,3]</code>陣列，不管是不是空的</p>
</li>
<li><p><code>&#123;&#125;,&#123;name:&#39;Jack&#39;&#125;</code>物件，不管是不是空的</p>
</li>
<li><p><code>function foo()&#123;&#125;</code>函式</p>
</li>
<li><p>true</p>
</li>
</ul>
<h4 id="Falsy物件"><a href="#Falsy物件" class="headerlink" title="Falsy物件"></a>Falsy物件</h4><p>當使用包裹物件來建立字串、數字或布林值時，由於包了一層物件，因此就算其底層的基型值是會被轉為false的值，它根本上都還是個物件，而只要是物件(即使是空物件)，就會被轉為true.。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b= <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> c= <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!a); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!b); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!c); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Truthy-值"><a href="#Truthy-值" class="headerlink" title="Truthy 值"></a>Truthy 值</h4><p>再次強調，只要不是前面列舉為會轉為 false 的值，都會被轉為 true。</p>
<h4 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h4><p>詳細狀況可見 ES5 <a href="https://es5.github.io/#x9.1">規格</a>。規則簡單說明如下</p>
<ul>
<li><p>undefined -&gt; undefined(基本型別，不轉換)</p>
</li>
<li><p>null -&gt; null (基本型別值，不轉換)</p>
</li>
<li><p>boolean -&gt; boolean(基本型別值，不轉換)</p>
</li>
<li><p>number -&gt; number(基本型別值，不對換)</p>
</li>
<li><p>object：使用<code>[[DefaultValue]]</code>內部方法，依照傳入的參數來決定要使用toString或valueOf取得基本型別值，，看參考<a href="https://es5.github.io/#x8.12.8">規格</a>。</p>
</li>
</ul>
<h4 id="明確的強制轉型-Explicit-Coercion"><a href="#明確的強制轉型-Explicit-Coercion" class="headerlink" title="明確的強制轉型(Explicit Coercion)"></a>明確的強制轉型(Explicit Coercion)</h4><p>「明確的強制轉型」是指程式碼中刻意寫出來的明顯的型別轉換的動作。</p>
<h5 id="明確的Strings-Numbers"><a href="#明確的Strings-Numbers" class="headerlink" title="明確的Strings &lt;–&gt; Numbers"></a>明確的Strings &lt;–&gt; Numbers</h5><p>字串與數字間的明確的強制轉換。</p>
<h6 id="方法一：使用內建函式String-與Number"><a href="#方法一：使用內建函式String-與Number" class="headerlink" title="方法一：使用內建函式String(..)與Number(..)"></a>方法一：使用內建函式<code>String(..)</code>與<code>Number(..)</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>注意，這裡的<code>String(..)</code>是直接調用<code>.toString</code>來轉字串，與<code>+</code>字串運算子經過ToPromitive的運作-由於傳入<code>[[DefaultValue]]</code>演算法的參數是number，因此先使用<code>valueOf</code>取得基型值，然後再用<code>toString</code>轉為字串，兩種方法 全不同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">54321</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">12345</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a));<span class="comment">// &quot;54321&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b+<span class="string">&#x27;&#x27;</span>);<span class="comment">// &quot;12345&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="方法二：使用物件原型的方法-toString"><a href="#方法二：使用物件原型的方法-toString" class="headerlink" title="方法二：使用物件原型的方法.toString()"></a>方法二：使用物件原型的方法<code>.toString()</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="title function_">toString</span>() <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="方法三：使用一元正-負運算子-、"><a href="#方法三：使用一元正-負運算子-、" class="headerlink" title="方法三：使用一元正&#x2F;負運算子+、-"></a>方法三：使用一元正&#x2F;負運算子<code>+</code>、<code>-</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line">-(<span class="string">&#x27;-123&#x27;</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>這個方法有個缺點，就是很容易造成各種語意上的誤會，像是與遞增(<code>++</code>)和遞減(<code>--</code>)或與二元運算子的數學運算「加」(<code>+</code>)和「減」(<code>-</code>)混淆。：</p>
<p>較常使用一元正和負運算子<code>+</code>、<code>-</code>的時機是將<strong>日期轉為數字</strong>，也就是取得1970年1月1日00:00:00UTC到目前為止的毫秒數，或稱UNIX時間戳記、時戳值timestamp。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timestamp);<span class="comment">//1566871728004 </span></span><br></pre></td></tr></table></figure>

<p>經由強制轉型取得時戳值並不是很好的方法，建議改用<code>Date.now()</code>或<code>.getTime()</code>會是更㞅想的作法，可讀性更高。</p>
<h6 id="方法四：使用一元位否定運算子"><a href="#方法四：使用一元位否定運算子" class="headerlink" title="方法四：使用一元位否定運算子~"></a>方法四：使用一元位否定運算子<code>~</code></h6><p>位元否定運算子(bitwise not)的功能是進行二進位的補數(公式為<code>~x</code>得到<code>-(x+1)</code>，例如~42得到-43)，它會先將值經由ToNumber轉為數字，再經由ToInt32轉障32位元有號整數，最後再逐位元的否，很類似<code>!</code>強制將值轉八布林並反轉其真偽的運作方式。</p>
<p>範例如下，<code>~</code>接受indexOf的回傳值並作轉換，對於「找不到」的-1會轉為0，做條件判斷時會再轉為false，其他的會回傳索引值(例如：0、1、2…)經否定再轉布林時都會是true,這樣的寫法有助於提高可讀性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = str.<span class="title function_">indexOf</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (~result) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`找到了，索引值原本是 <span class="subst">$&#123;result&#125;</span>，被轉為 <span class="subst">$&#123;~result&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`找不到，回傳結果原本是 <span class="subst">$&#123;result&#125;</span>，被轉為 <span class="subst">$&#123;~result&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">find</span>(<span class="string">&#x27;llo&#x27;</span>); <span class="comment">// 找到了，索引值原本是 2，被轉為 -3</span></span><br><span class="line"><span class="title function_">find</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// 找不到，回傳結果原本是 -1，被轉為 0</span></span><br></pre></td></tr></table></figure>

<h6 id="同場加映-浮點數轉為整數"><a href="#同場加映-浮點數轉為整數" class="headerlink" title="同場加映:浮點數轉為整數"></a>同場加映:浮點數轉為整數</h6><p>使用<code>~~</code>將浮點數轉為整數，其運作方式為反轉兩次而得到截斷小數的結果，類似<code>!!</code>的真偽雙次否定。這裡有兩件事情要注意…</p>
<ul>
<li>使用<code>x | 0</code>也可以得到同樣的效果，差別只在於<code>~~</code>運算子優先權較高，遇到四則運算時不用包小括號。</li>
<li>與<code>Math.floor(..)</code>的結果不同，如下，<code>Math.floor(-29.8)</code>得到-30，而<code>~~-29.8</code>得偌-29</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">29.8</span>));<span class="comment">// -30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(~~-<span class="number">29.8</span>); <span class="comment">// -29</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">29.8</span> | <span class="number">0</span>); <span class="comment">//-29</span></span><br></pre></td></tr></table></figure>

<h5 id="明確的剖析數值字串-Numberic-String"><a href="#明確的剖析數值字串-Numberic-String" class="headerlink" title="明確的剖析數值字串(Numberic String)"></a>明確的剖析數值字串(Numberic String)</h5><p>除了使用<code>Number(..)</code>將值強制轉型為數字外，還可用<code>parseInt(..)</code>剖析而得到數字。<code>parseInt(..)</code>的用途是將字串剖析為數字，它接受一個字串作為輸入，若輸入非字串的值則會使用ToString強制轉為字串。</p>
<p><code>Number(..)</code>與<code>parseInt(..)</code>的差異在於</p>
<ul>
<li><code>parseInt(..)</code>可容忍(或想像成忽略)非數值的字元，在由左至右掃描值的過程中，遇到非數值字就停下來(忽略後後續部份)，只轉換到停下來之前所得到的數值。除非整個字串都是非數值，否則不會得偌NaN。而<code>Number(..)</code>則是只要傳入的字串不是可轉成數值的，就會得到NaN。</li>
<li>「指定基底」是個必要的好習慣，<code>parseInt(..)</code>若沒有輸入第二個參數來指定基數，就會以第一個參數的頭幾個字元決定基數為何，例如：開頭若為<code>0x</code>就會轉為十六進位的數字。因此，使用<code>parseInt(..)</code>最好要傳入基底以維持結果的正確性，例如：<code>parseInt(&#39;12345&#39;,10)</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;123px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a));  <span class="comment">// 123 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(a));<span class="comment">// 123 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(b));  <span class="comment">// NaN </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(b));<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;HelloWorld&#x27;</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="明確的-–-Boolean"><a href="#明確的-–-Boolean" class="headerlink" title="明確的 * –&gt; Boolean"></a>明確的 * –&gt; Boolean</h5><p>探討任何值強制轉為布林的情況。</p>
<h6 id="方法一：使用內建函式Boolean"><a href="#方法一：使用內建函式Boolean" class="headerlink" title="方法一：使用內建函式Boolean(..)"></a>方法一：使用內建函式<code>Boolean(..)</code></h6><p>使用<code>Boolean(..)</code>來執行ToBoolean的轉換工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>([]));<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(&#123;&#125;));<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">null</span>));<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">undefined</span>));<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="title class_">NaN</span>));<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>));<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="方法二：否定運算子"><a href="#方法二：否定運算子" class="headerlink" title="方法二：否定運算子!"></a>方法二：否定運算子<code>!</code></h6><p>雙次否定即可強制將值轉為布林。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&#x27;Hello World&#x27;</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!![]);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!&#123;&#125;);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="literal">null</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="literal">undefined</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="title class_">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="number">0</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&#x27;&#x27;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="隱含的強制轉型-Implicit-Coercion"><a href="#隱含的強制轉型-Implicit-Coercion" class="headerlink" title="隱含的強制轉型(Implicit Coercion)"></a>隱含的強制轉型(Implicit Coercion)</h4><p>「隱含的強制轉型」是指在程式碼中沒有明確指出要轉換型別但卻轉型的動作。</p>
<h5 id="隱含的Strings-Numbers"><a href="#隱含的Strings-Numbers" class="headerlink" title="隱含的Strings &lt;–&gt; Numbers"></a>隱含的Strings &lt;–&gt; Numbers</h5><h6 id="Case1-String-–-Numbers-運算子是數字的相加，還是字串的串接"><a href="#Case1-String-–-Numbers-運算子是數字的相加，還是字串的串接" class="headerlink" title="Case1 String –&gt;Numbers:+運算子是數字的相加，還是字串的串接?"></a>Case1 String –&gt;Numbers:<code>+</code>運算子是數字的相加，還是字串的串接?</h6><p>若兩運算元的型別不同，當其中一方是字串時，<code>+</code>所代表的就是字串運算子，而會將另外一個運算元強制轉型為字串，並連接兩個字串。這裡提到的「另外一個運算元」就先稱它為b好了，若b是物件則會呼叫ToPrimitive做處理-由於傳入<code>[[DefaultValue]]</code>演算法的參敗是number，因此先使用<code>valueOf</code>取得基型值，然後再用<code>toString</code>轉為數字(非常的或非常小的數字以指數呈現)的字串格式。</p>
<p>如下範例，數字1會轉為字串<code>1</code>,而陣𦕁c和d分別會使用<code>toString</code>轉為<code>1, 2</code>與<code>3, 4</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> d = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">1</span>);<span class="comment">//&quot;11&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b + <span class="number">1</span>);<span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b + <span class="string">&#x27;&#x27;</span>);<span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c + d);<span class="comment">// &quot;1,23,4&quot;</span></span><br></pre></td></tr></table></figure>

<p>再看兩個著名的例子:<code>[] + &#123;&#125;</code>與<code>&#123;&#125; + []</code>。先猜猜看結果是什麼？</p>
<p>皆為<code>[object Object]</code>?</p>
<p>公佈答案摟！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125; <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">&#123;&#125; + [] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>說明如下</p>
<ul>
<li><code>[] + &#123;&#125;</code>中，<code>[]</code>會轉為空字串，而<code>&#123;&#125;</code>會轉為字串<code>&quot;[object Object]&quot;</code>。</li>
<li><code>&#123;&#125; + []</code>中，<code>&#123;&#125;</code>被當成空區塊而無作用，<code>+[]</code>被當成強制轉型為睥字<code>Number([])</code>(由於陣列是物 ，中間會先使用<code>toString</code>轉成空字串，導致變成<code>Number(&#39;&#39;)</code>)而得到0。</li>
</ul>
<p>注意前面提到的<code>String(..)</code>是直接調用<code>.toString</code>來轉字串，與<code>+</code>字串運算子經過ToPrimitive的運作-由於傳入<code>[[DefaultValue]]</code>演算法的參數是number,因此先使用<code>valueOf</code>取得基型值，然後再用<code>toString</code>轉為字串，兩慟方法是完全不同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">54321</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">12345</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a));<span class="comment">// &quot;54321&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b+ <span class="string">&#x27;&#x27;</span>);<span class="comment">// &quot;12345&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="Case2-使用數字運算子將字串轉為數字"><a href="#Case2-使用數字運算子將字串轉為數字" class="headerlink" title="Case2:使用數字運算子將字串轉為數字"></a>Case2:使用數字運算子將字串轉為數字</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">1</span>);<span class="comment">//&quot;11&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a - <span class="number">0</span>);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a * <span class="number">1</span>);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a / <span class="number">1</span>);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">9</span>]-[<span class="number">7</span>]);<span class="comment">//2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>轉換規則可參考前面提到的ToNumber。</p>
<h5 id="隱含的-–-Boolean"><a href="#隱含的-–-Boolean" class="headerlink" title="隱含的 * –&gt; Boolean"></a>隱含的 * –&gt; Boolean</h5><p>在什麼狀況下會隱含地將值強制轉為布林呢？</p>
<ul>
<li><p>if述句中的條件判斷(或稱測式運算式test expression)</p>
</li>
<li><p>for述句中的條件判斷，意即測試運算式的第二個子句</p>
</li>
<li><p>while與do…while中檢測條件是否成立的測試運算式</p>
</li>
<li><p>三元運算式<code>條件？值1：值2</code>中的條件運算，意即測試運算式的第一個子句</p>
</li>
<li><p>邏輯運算子的<code>||</code>(or)和<code>&amp;&amp;</code>(and)左手邊的運算元會被當成測試運算式</p>
</li>
</ul>
<p>轉換規則可參考前面提到的ToBoolean</p>
<p>範例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> c;<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">//true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a 是直的&#x27;</span>);<span class="comment">// a 是直的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (c) &#123;<span class="comment">//false</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;從來沒跑過&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">c = d ? a : b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a &amp;&amp; d) || c) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;結果是真的&#x27;</span>);<span class="comment">//結果是真的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="運算子-與"><a href="#運算子-與" class="headerlink" title="運算子||與&amp;&amp;"></a>運算子<code>||</code>與<code>&amp;&amp;</code></h6><p>邏輯運算子的<code>||</code>(or)和<code>&amp;&amp;</code>(and)其實應該要稱呼為「(運算元的)選擇器運算子」(operand selector operator)，𫍇是因為它們並不是產生邏輯運算值true或false，而是在兩個運算元當中「選擇」其中一個運算元的值作為結果。</p>
<p>規則為，<code>||</code>(or)和<code>&amp;&amp;</code>(and)會將第一個運算元做布林測試或強制轉型為布林以便測試。</p>
<ul>
<li>對<code>||</code>(or)來說，若結果為true，則取第一個運算元為結果；若結果為false，則取第二個運算元為結果。</li>
<li>對<code>&amp;&amp;</code>(and)來說，若結果為true，則取第二個運算元為結果；若結果為false，則取第一個運算元為結果。</li>
</ul>
<p>因此可應用於</p>
<ul>
<li><p><code>||</code>(or)可用來設定變數的初始值。</p>
</li>
<li><p><code>&amp;&amp;</code>(and)可用來執行「若特定條件成立，才做某件事情」，功能近似if述句。</p>
<p>範例如下</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">777</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &amp;&amp; c);<span class="comment">//測試 a 為 true，選 c，結果是 null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &amp;&amp; b);<span class="comment">//測試 a 為 true，選 b，結果是 777</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> &amp;&amp; b);<span class="comment">//測試 undefined 為false，選undefined,結果是 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a || b);<span class="comment">//測試 a 為 true，選 a,結果是 &quot;Hello World&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c || <span class="string">&#x27;foo&#x27;</span>);<span class="comment">//測試 c 為 false，選&#x27;foo&#x27; ，結果是 &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>若flag條件成立(true)，就執行函式foo，之後會再提到短路的議題。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;try me&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag &amp;&amp; <span class="title function_">foo</span>();<span class="comment">//try me</span></span><br></pre></td></tr></table></figure>

<h4 id="Symbol的強制轉型"><a href="#Symbol的強制轉型" class="headerlink" title="Symbol的強制轉型"></a>Symbol的強制轉型</h4><p>symbol的強制轉型規則如下</p>
<ul>
<li><p>在轉為字串方面，將symbol明確的強制轉型是允許的，但隱含的強制轉型是被禁止的，並且會丟出錯誤訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(s1));<span class="comment">// &quot;Symbol(Hello World)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2= <span class="title class_">Symbol</span>(<span class="string">&#x27; World Hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2+<span class="string">&#x27;&#x27;</span>);<span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在轉為數字方面，無論是明確或隱含都是禁止的，並且會丟出錯誤訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n1 = <span class="title class_">Symbol</span>(<span class="number">777</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(n1));<span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n2=<span class="title class_">Symbol</span>(<span class="number">999</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+n2);<span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在轉為布林方面。無論是明確或隱含都是可以的，並且結果都是true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b1 = <span class="title class_">Symbol</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> b2 = <span class="title class_">Symbol</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(b1));<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(b2));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b3 = <span class="title class_">Symbol</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> b4 = <span class="title class_">Symbol</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b3) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b3 是直的&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b4) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b4 是直的&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b3 是真的</span></span><br><span class="line"><span class="comment">// b4 是真的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="寬鬆相等-Loose-Equals-vs-嚴格相等-Strict-Equals"><a href="#寬鬆相等-Loose-Equals-vs-嚴格相等-Strict-Equals" class="headerlink" title="寬鬆相等(Loose Equals) vs 嚴格相等(Strict Equals)"></a>寬鬆相等(Loose Equals) vs 嚴格相等(Strict Equals)</h4><p>  關於相等性的運算子有四固「<code>==</code>」(寬鬆相等性loose equality)、「<code>===</code>」(嚴格相等性strict queality)、「<code>!=</code>」(寬鬆不相等loose not-queality)、「<code>!==</code>」(嚴格不相等strict not-equality)。寬鬆與嚴格的差異在於檢查值相等時，是否會做<strong>強制轉型</strong>、<code>==</code><strong>會做強制轉型，而<code>===</code>不會</strong>。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;100&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);<span class="comment">//true，強制轉型，將字串&#x27;100&#x27;轉為數字100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>  這裡要說明一下，<code>==</code>和<code>===</code>其實都會做型別的檢查，只是當面對型別不同時的反應是不一樣的而已。</p>
<h5 id="規則"><a href="#規則" class="headerlink" title="規則"></a>規則</h5><p>  如果型別相同，就會以同一性做比較，但要注意</p>
<ul>
<li><p>NaN不等於自已(其實，NaN不大於、不小於也不等於任何數字，所以當然也不等於它自已)</p>
</li>
<li><p>+0、-0彼此相等。</p>
</li>
<li><p>物件(含function和array)的相等是比較參考(reference)，若參考相等才是相等。</p>
</li>
</ul>
<p>   如果型別不同，則會先將其中一個或兩個值先做強制轉型(可遞迴)，再用型別相同的同一性做比較。</p>
<ul>
<li><p>字串轉為數字</p>
</li>
<li><p>布林轉為數字</p>
</li>
<li><p>null與undefined在寬鬆相等下會強制轉型為彼此，因此是相等的，但不等於其他值</p>
</li>
<li><p>若比較的對象是物件，使用<code>valueOf()</code>(優先)或<code>toString()</code>將物件取得基本型別的值，再做比較。</p>
<p>而<code>!=</code>和<code>!==</code>就是先分別做<code>==</code>和<code>===</code>再取否定(<code>!</code>)即可。</p>
</li>
</ul>
<p><strong>範例1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 答案是？</span></span><br><span class="line">a == b <span class="comment">// 答案是？</span></span><br></pre></td></tr></table></figure>

<p>答案揭曉</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === b <span class="comment">//false</span></span><br><span class="line">a == b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在<code>a == b</code>當中，字串a優先轉為數字後，此時就可比較<code>123==123</code>，因此是相等的(true)</p>
<p><strong>範例2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 答案是？</span></span><br><span class="line">a == b <span class="comment">// 答案是？</span></span><br></pre></td></tr></table></figure>

<p>答案揭曉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === b <span class="comment">// false</span></span><br><span class="line">a == b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在<code>a == b</code>當中，布林a優先轉為數字(<code>Number(true)</code>得到1)後，此時就可比較<code>1 == 123</code>，因此是不相等的(false)。</p>
<p><strong>範例3</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 答案是？</span></span><br><span class="line">a == b <span class="comment">// 答案是？</span></span><br></pre></td></tr></table></figure>

<p>答案揭曉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === b <span class="comment">// false</span></span><br><span class="line">a == b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在<code>a == b</code>當中其實比較的是<code>null == 123</code>，因此是不相等的(false)。</p>
<p><strong>範例4</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;1,2,3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a === b <span class="comment">// 答案是？</span></span><br><span class="line">a == b <span class="comment">// 答案是？</span></span><br></pre></td></tr></table></figure>

<p>答案揭曉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a === b <span class="comment">// false</span></span><br><span class="line">a == b <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在<code>a == b</code>當中，陣列a由於沒有<code>valueOf()</code>，只好使用<code>toString()</code>取得其基型值而得到字串<code>1,2,3</code>，此時就可比較<code>&#39;1,2,3&#39; == &#39;1,2,3&#39; </code>，因此是相等的(true)。</p>
<p><strong>範例5</strong></p>
<p>有幾個例外需要注意…</p>
<ul>
<li><p>null與undefined沒有其物件包裹形式，因此<code>Object(null)</code>與<code>Object(undefined)</code>等同於<code>Object()</code>, 也就是空物件<code>&#123;&#125;</code>。</p>
</li>
<li><p><code>Number(Nan)</code>得到NaN，且NaN不等於自已。</p>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>(a);<span class="comment">// 等同於 Object()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="title class_">Object</span>(c);<span class="comment">// 等同於 Object()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c == d);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title class_">Object</span>(e);<span class="comment">//等同於new Nummber(e)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e == f);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="邊緣情況"><a href="#邊緣情況" class="headerlink" title="邊緣情況"></a>邊緣情況</h4><p>這部份來提一些邊綠(少見但驚人)的狀況。</p>
<h5 id="避免修改原型的valueOf"><a href="#避免修改原型的valueOf" class="headerlink" title="避免修改原型的valueOf(..)"></a>避免修改原型的<code>valueOf(..)</code></h5><p>經由原生的內建函式所建立的值，由於是物件型態，在強制轉型時會經過ToPrimitive的過程，也就是使用<code>valueOf(..)</code>(優先)或<code>toString(..)</code>將物件取得基本型別的值，才會做後續比較。因此，若修改了原型中的<code>toValue(..)</code>方法，則可能會導致比較時出現「不可思議」的結果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">2</span>) == <span class="number">3</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="一些瘋狂的範例"><a href="#一些瘋狂的範例" class="headerlink" title="一些瘋狂的範例"></a>一些瘋狂的範例</h5><p>以下會得到什麼結果呢？請小心服用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> == <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> == []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> == &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span> == <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span> == []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span> == &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] == ![]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> == [<span class="number">2</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span> == [<span class="literal">null</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>答案揭曉。</p>
<p> 說明</p>
<ul>
<li><p><code>&quot;0&quot; == false;</code>，true，字串轉數字、布林再轉數字</p>
</li>
<li><p><code>false == 0;</code>，true，布林轉數字</p>
</li>
<li><p><code>false == &quot;&quot;;</code>，true，字串轉數字、布林再轉數字</p>
</li>
<li><p><code>false == [];</code>，true，布林轉數字、陣列取toString得到空字串再轉數字</p>
</li>
<li><p><code>false == &#123;&#125;;</code>，false，布林轉數字，物件取valueOf得到空物件</p>
</li>
<li><p><code>&quot;&quot; == 0;</code>，true，字串轉數字</p>
</li>
<li><p><code>&quot;&quot; == [];</code>，true，字串轉數字、陣列取toString得到空字串再轉數字</p>
</li>
<li><p><code>&quot;&quot; == &#123;&#125;;</code>，false，字串轉數字、物件取valueOf得到空物件</p>
</li>
<li><p><code>0 == [];</code>，true，陣列取toString得到空字串再轉數字</p>
</li>
<li><p><code>0 == &#123;&#125;;</code>，false，物件取valueOf得到空物件</p>
</li>
<li><p><code>[] == ![];</code>，true，左手邊取valueOf得到空字串再轉數字得到0，右手邊被！強制轉為布林得到false再轉數字</p>
</li>
<li><p><code>2 == [2];</code>，true，陣列取toString得到空字串再轉數字</p>
</li>
<li><p><code>&quot;&quot; == [null];</code>，true，陣列取toString得空字串，轉數字後得到0</p>
</li>
<li><p><code>0 == &#39;\n&#39;;</code>，true，’\n’意即’’(空白)，轉數字後得到0</p>
</li>
</ul>
<h4 id="總結-：如何安全地使用隱含的強制轉型"><a href="#總結-：如何安全地使用隱含的強制轉型" class="headerlink" title="總結  ：如何安全地使用隱含的強制轉型?"></a>總結  ：如何安全地使用隱含的強制轉型?</h4><p>若允許強制轉型，但又希望能避免「難以預料」的強制轉型(上例), 這裡有一些建議</p>
<ul>
<li><p>若有一邊可能會出現true或false，就不要用<code>==</code>，改用<code>===</code>。</p>
</li>
<li><p>若有一邊可能會出現<code>[]</code>、空字串<code>&quot;&quot;</code>或0，就不要用<code>==</code>，改用<code>===</code>。</p>
</li>
</ul>
<p>以下是一定得安全的強制轉型，使用<code>==</code>即可，不需要用<code>===</code>…</p>
<ul>
<li>比較null與undefined的強制轉型是安全的，因為它們互轉為彼此，一定相等。</li>
<li><code>typeof x</code>得到的是固定的七種字串值(例如：<code>&#39;string&#39;</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>function</code>、<code>object</code>、<code>symbol</code>)，因此做<code>typeof x == &#39;指定值&#39;</code>一定是安全的</li>
</ul>
<p>也許世界上大多數的開發都詬病JavaScript中「隱含的強制轉型」的這部份，覺得這是個壞東西，但也許它其實是減少冗贅、反覆套用和非必要實作細節的好方法，而前提是，必須要能清楚了解強型的規則。</p>
<h4 id="JavaScript-Equality-Table"><a href="#JavaScript-Equality-Table" class="headerlink" title="JavaScript Equality Table"></a>JavaScript Equality Table</h4><p>下圖為JavaScript中的相等性，此圖視覺化了所有的比較項目。</p>
<img src="JavaScript-Equality-Table.png" style="zoom:85%;" />

<p>圖片來源：<a href="https://github.com/dorey/JavaScript-Equality-Table">JavaScript Equality Table</a></p>
<h4 id="抽象的關系式比較"><a href="#抽象的關系式比較" class="headerlink" title="抽象的關系式比較"></a>抽象的關系式比較</h4><p>這裡要來談比較運算子(comparsion)的部份，意即<code>&lt;</code>(小於)、<code>&gt;</code>(大於)、<code>&lt;=</code>(小於等於)、<code>&gt;=</code>(大於等於)，例如：<code>a &gt; b</code>表示比較a是否大於b。其比較規則為</p>
<ol>
<li><p>若兩個運算元皆為字串時，就直接依照字典字母順序做比較。</p>
</li>
<li><p>除了1之外的狀況都適用</p>
</li>
</ol>
<ul>
<li>先使用ToPrimitive做強制轉型-先使用<code>valueOf</code>取得基型值，然後再用<code>toString</code>方法轉為字串。</li>
<li>承上，若有任一值轉型後的結果不是字串，就使用Tonumber對規則轉為數字，來做數字上的比較。</li>
</ul>
<p>注意</p>
<ul>
<li>由於<a href="https://es5.github.io/#x11.8.5">規格</a>只定義了<code>a &lt; b</code>的演法，因此<code>a &gt; b</code>會以<code>b &lt; a</code>的方式做比較。</li>
<li>由於沒有「嚴格關系比較」，所以一定會遇到強型機狀況。</li>
</ul>
<p>範例如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> b = [<span class="string">&#x27;13&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &lt; b);<span class="comment">// true，&#x27;12&#x27; &lt; &#x27;13&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &gt; b);<span class="comment">// false, 其實是比較 b &lt; a，即 &#x27;13&#x27; &lt;&#x27;12&#x27; </span></span><br></pre></td></tr></table></figure>

<p>範例如下，由於a和b都不定字串，因此先用<code>valueOf</code>取得基型𠶗(只取到原來的物件),，再用<code>toString</code>而得到兩個字串<code>[object Object]</code>，因此比較<code>[object Object]</code>與<code>[object Object]</code>。又<code>a == b</code>比較的是兩物件存取的所在的記憶體位置，也就是參考(reference)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">b</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &lt; b);<span class="comment">// false,&#x27;[object Object]&#x27; &lt; &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &gt; b);<span class="comment">// false,其實是比較 b &lt; a，即&#x27;[object Object]&#x27; &lt; [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b);<span class="comment">// false,其實是比較兩物件的reference</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &gt;= b);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a &lt;= b);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>這裡要注意的是…</p>
<ul>
<li><code>a &lt;= b</code>其實是<code>!(b &gt; a)</code>，因此<code>!false</code>得到true。</li>
<li><code>a &gt;= b</code>其實是<code>b &lt;= a</code>也就是<code>!(a &gt; b)</code>等同於<code>!false</code>得到true。</li>
</ul>
<h4 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h4><p>看完這文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>強制轉型(coercion)分為兩種，分別是「明確的」強制轉型(explicit coercion)和「隱含的」強制轉型(implicit coercion)，只要是程式碼中刻意寫出的明顯的型別轉換的動作，就是明確的強制轉型；反之，在程式碼中沒有明確指出要轉換型別卻轉型的，就是隱含的強制轉型。</li>
<li>明確的強制轉型規則與範例說明。</li>
<li>隱含的強制轉型規則與範例說明。</li>
<li>Symbol的強制轉型的規則與範例說明。</li>
<li>隱含的強制轉型的心酸血淚？各動令人崩潰的範例。</li>
<li>抽象的關係式比較。</li>
</ul>
<h3 id="你懂JavaScript嗎？文法-Grammar"><a href="#你懂JavaScript嗎？文法-Grammar" class="headerlink" title="你懂JavaScript嗎？文法(Grammar)"></a>你懂JavaScript嗎？文法(Grammar)</h3><blockquote>
<p>JavaScript的文法是描述其語法(syntax)例如：運算子、關鍵字等，如何結合在一起，形成格式正確的有效程式的一種結構化方式。</p>
</blockquote>
<p>主要會談到</p>
<ul>
<li>述句與運算式、述句完成值和其產生的副作用、解法和好處。</li>
<li>運用運算子優先序與結合性的規則，並顧及程式碼的可讀性。</li>
<li>依賴ASI還是手動加入分號？</li>
<li>錯誤-編譯時期的錯誤、執行時期的錯誤、暫時死亡區域(TDZ)。</li>
<li>try…finally與switch的特殊狀況。</li>
</ul>
<h4 id="述句與運算式-Statements-Expressions"><a href="#述句與運算式-Statements-Expressions" class="headerlink" title="述句與運算式(Statements&amp;Expressions)"></a>述句與運算式(Statements&amp;Expressions)</h4><p>運算式類似片語，經由運算子(類似標點符號或連接詞)將多個運算式組成一個完成的述句。𪞈個運算式都可各自估算其值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span> + <span class="number">2</span>;<span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">const</span> b = a + <span class="number">3</span>;<span class="comment">//(2)</span></span><br><span class="line">b;<span class="comment">//(3)</span></span><br></pre></td></tr></table></figure>

<p>說明</p>
<ul>
<li>運算式有：<code>1 +2</code>(經個算偌3)、<code>a + 3</code>(經估算得到6)、<code>b</code>(經估算得到6)。</li>
<li>(1)和(2) 稱為「宣告述句」(declaration statement)</li>
<li>(1)當中的<code>a = 1 + 2</code>和(2)當中的<code>b = a + 3</code>稱為「指定運算式」(assignment expression)</li>
<li>(3)稱為「運算式述句」(expression statement)</li>
</ul>
<h4 id="述句完成值-Statement-Completion-Values"><a href="#述句完成值-Statement-Completion-Values" class="headerlink" title="述句完成值(Statement Completion Values)"></a>述句完成值(Statement Completion Values)</h4><p>只要是述句都有完成值，就算是undefined。我們常在console頁籤看到最近一次執行結果的述句完成值。</p>
<img src="statement_completion_values.png" style="zoom:85%;" />

<p>由上圖中你可能會觀察到一個有趣的問題，為什麼「<code>const a = 1 + 2;</code>」是得到undefined而非3？</p>
<p>這是因為在<a href="https://es5.github.io/#x12.2">規格</a>中的種種複雜規則運作下，變數的𠍐句(例如:<code>const a</code>)會強制回傳undefined作為完成值。</p>
<p>依此類推，我們也會得到區塊完成值(目前指每個區塊的最後一個述句的完成值)，而為了能真正實現區塊也能得到其回傳值，有興趣的可以看這個提案-<a href="https://github.com/tc39/proposal-do-expressions"><code>do</code> expressions</a>，這樣就可將區塊視為運算式而得到回傳值了。</p>
<p>理解這個「述句完成值」有什麼好處？它可以幫助我們…</p>
<ul>
<li>解決運算式副作用(side effect)的問題</li>
<li>精算程式碼。</li>
</ul>
<h4 id="運算式副作用-Side-Effects"><a href="#運算式副作用-Side-Effects" class="headerlink" title="運算式副作用(Side Effects)"></a>運算式副作用(Side Effects)</h4><p>「述句完成值」的第一個好處是解決運算式副作用的問題，所謂「運算式副作用」其實就是經由運算式而得到的一些非預期結果，來看<code>--a++</code>這個例子。</p>
<p><code>--a++</code>???</p>
<p>這是同時遞增與遞減嗎？</p>
<p>別緊張，當然不是。</p>
<p>由於運算子的優先順序的關系，我們可以想成是這樣的<code>--(a++)</code>，先做遞增，再做遞減。</p>
<p>然而，執行這個運算式是會出錯的，得到ReferenceError，貼到Google翻譯上是說「未捕獲的ReferenceError：前綴操作中的左側表達式無效」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = --a++;</span><br><span class="line">b;<span class="comment">// Uncaught ReferenceError: Invalid left-hand side expression in prefix operation</span></span><br></pre></td></tr></table></figure>

<p>蛤，什麼意思？？</p>
<p>先來看<code>++</code>作為前綴(prefix)與後綴(postfix)的差異，<code>a++</code>和<code>++a</code>的差異是在於這個運算式的結果(意即述句完成值)的回傳動作是在運算前還是後發生的，<code>a++</code>表示是先回傳再運算，而<code>++a</code>是表示先運算再回傳。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">a++ <span class="comment">// 1，先回傳再運算</span></span><br><span class="line">--b <span class="comment">// 9，先運算再回傳</span></span><br></pre></td></tr></table></figure>

<p>因此，<code>--a++</code>可看成<code>--(a++)</code>，會先得到<code>a++</code>的結果1，接著再做<code>--1</code>，但<code>--</code>只能在變數上運作，而無法用在一個值上，因此丟出了ReferenceError。</p>
<p>救星來了！</p>
<p>幸好，述句序𦕁逗號算子(<code>,</code>)救了我們，<code>,</code>可串起多個述句並回傳最後一個述句的結果作為述句完成值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = (a++, --a);</span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="精簡程式碼"><a href="#精簡程式碼" class="headerlink" title="精簡程式碼"></a>精簡程式碼</h4><p>「述句完成值」的第二個好處是能精簡程式碼</p>
<p>範例如下，以下是一個確認輸入字串到底有哪些字母是母音的函式，並回傳是母音的字母所構成的陣列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkVowels</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> matches;</span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">        matches = str.<span class="title function_">match</span>(<span class="regexp">/[aeiou]/g</span>);</span><br><span class="line">        <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">            <span class="keyword">return</span> matches;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkVowels</span>(<span class="string">&#x27;Hello World&#x27;</span>));<span class="comment">// [&quot;e&quot;, &quot;o&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure>

<p>從述句完成值中得知，述句<code>matches = str.match(/[aeiou]/g);</code>會得到一個回傳值，因此可直接將此值拿來做判斷，精簡程式碼如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkVowels</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> matches;</span><br><span class="line">    <span class="keyword">if</span> (str &amp;&amp; (matches = str.<span class="title function_">match</span>(<span class="regexp">/[aeiou]/g</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> matches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkVowels</span>(<span class="string">&#x27;Hello World&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkVowels</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> matches;</span><br><span class="line">    <span class="keyword">return</span> str &amp;&amp; (matches = str.<span class="title function_">match</span>(<span class="regexp">/[aeiou]/g</span>)) ? matches : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkVowels</span>(<span class="string">&#x27;Hello World&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="取決於上下文的規則-Contextual-Rules"><a href="#取決於上下文的規則-Contextual-Rules" class="headerlink" title="取決於上下文的規則(Contextual Rules)"></a>取決於上下文的規則(Contextual Rules)</h4><p>這部份我們來看一些「語法相同，但在不同環境中有不同意義」的狀況。</p>
<h4 id="大括號-Curly-Braces"><a href="#大括號-Curly-Braces" class="headerlink" title="大括號({..}Curly Braces)"></a>大括號(<code>&#123;..&#125;</code>Curly Braces)</h4><p>大括號(<code>&#123;..&#125;</code>Curly Braces)在不同環境中有不同意義的狀況有-物件字面值(object literal)、區塊(block)、物件解構(object destructuring)，以下分別述之。</p>
<ul>
<li><p>物件字面值(object literal):將值<code>&#123;..&#125;</code>指定給某個變數。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>區塊(block):𢥢用<code>&#123;..&#125;</code>標示程試碼的區塊範圍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前有一個範例</p>
<p><code>[] + &#123;&#125;</code> 與 <code>&#123;&#125; + []</code>。</p>
<p>先猜猜看結果是什麼？</p>
<p>皆為<code>[object Object]</code>?</p>
<p>公佈答案</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125; <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">&#123;&#125; + [] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><code>[]+&#123;&#125;</code>中，<code>[]</code>會轉為空字串，而<code>&#123;&#125;</code>會轉為字串<code>&quot;[object Object]&quot;</code>。<code>&#123;&#125; + []</code>中，<code>&#123;&#125;</code>被當成空區塊而無作用，<code>+[]</code>被𡮝成強制轉型為數字<code>Number([])</code>（由於陣列是物件，中間會先使用<code>toString</code>轉成空字串，導致變成<code>Number(&#39;&#39;)</code>而得到0。</p>
</li>
<li><p>物件解構(object destructuring):這裡的<code>&#123;..&#125;</code>表示解構指定式(destructuring assignment)的物件的解構。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">&#123; name &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);<span class="comment">// Hi, I am Jack</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="else-if-與選擇性區塊"><a href="#else-if-與選擇性區塊" class="headerlink" title="else if 與選擇性區塊"></a>else if 與選擇性區塊</h4><p><code>else if</code>這樣的語法並不存在！</p>
<p>那這是什麼？？？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b) &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>else if</code>其實只是因為if或else後若只接㽞一述句，就可以省略大括號<code>&#123;..&#125;</code>的緣故。因此，上例的程式碼其實是這樣的…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="運算子優先序-Operator-Precedence"><a href="#運算子優先序-Operator-Precedence" class="headerlink" title="運算子優先序(Operator Precedence)"></a>運算子優先序(Operator Precedence)</h4><p>了解運算子優先序有助於我們理解程式碼什麼時候會執行(短路)、怎麼分批執行(結合性)。</p>
<h5 id="Operator-Precedence-Table"><a href="#Operator-Precedence-Table" class="headerlink" title="Operator Precedence Table"></a>Operator Precedence Table</h5><p>MDN整理了一份<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">「運算子優先序」清單</a>，截圖如下。</p>
<p>運算子優先順序由高(20)至低(1)排列</p>
<img src="operator_precedence_table.png" style="zoom:85%;" />

<p>圖片來源：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">Operator precedence table</a></p>
<h5 id="短路-Short-Circuited"><a href="#短路-Short-Circuited" class="headerlink" title="短路(Short Circuited)"></a>短路(Short Circuited)</h5><p>之蠕提過「選擇器運算子」(operand selector operator)的<code>&amp;&amp;</code>(and)和<code>||</code>(or)的功用，其中，若運算子左手邊的運算元可估算出結果，右手邊的運算元更不會被估算，此情況稱為「短路」(shot circuited)。</p>
<p>應用這重短路的行為的範例如下，若flag條件成立(true)，就執行函式foo;反之，就不執行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;try me&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">flag &amp;&amp; <span class="title function_">foo</span>();<span class="comment">// try me</span></span><br></pre></td></tr></table></figure>

<p>短路其實某方面和if述句滿像的，如果判斷的條件不複雜或執行的工作不多，𠞽路可說是更為精簡易懂的寫法。</p>
<h4 id="結合性-Associativity"><a href="#結合性-Associativity" class="headerlink" title="結合性(Associativity)"></a>結合性(Associativity)</h4><p>說到運算子優先順序研一定會談到結合性，這牽涉到執行複雜運算時要怎麼幫運算式分組，有多個相同優先順序的運算子時該怎麼處理的議題。</p>
<p>結合性分為</p>
<ul>
<li><p>左結合，意即由左至右處理，例如：<code>&amp;&amp;</code>、<code>||</code>。</p>
</li>
<li><p>右結合，意即由右至左處理，例如：三元運算子<code>條件 ？ 值1 ： 值2</code>、指定運算子<code>var a = b = c = 123 </code>。</p>
<p>猜猜看以下這段式碼要怎麼分組。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c ? d : e</span><br></pre></td></tr></table></figure>

<p>是<code>(a ? b : c) ? d: e</code>或<code> a ? b :(c ? d: e)</code>?</p>
<p>答案是後者<code> a ? b :(c ? d: e)</code>，因為三元運算子是右結合，從右到左來分組。</p>
<p>了解運算子優先順序與結合性的規則，開發者在撰寫程式碼才能「清除歧義」，建議在運用運算優覺順序與結合性的甸時，也手動使用小括號<code>(..)</code>歸組以顧及程式碼可讀性。</p>
<h4 id="自動分號插入-Automatic-Semicolon-Insertion-ASI"><a href="#自動分號插入-Automatic-Semicolon-Insertion-ASI" class="headerlink" title="自動分號插入(Automatic Semicolon Insertion,ASI)"></a>自動分號插入(Automatic Semicolon Insertion,ASI)</h4><p>JavaScript引擎中的剖析器(parser)會在以下情況下，自動幫程式碼補上分號，以避免剖析失敗。</p>
<ul>
<li>換行，即述句結尾處與下一行之間，除了空白和註解外，沒有其他的程式碼。</li>
<li>break、continue、return、yield之後。</li>
</ul>
<p>不需要ASI的情況是</p>
<ul>
<li>區塊(<code>&#123;...&#125;</code>)不需要分號做終結。</li>
</ul>
<p>範例如下。</p>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    a--</span><br><span class="line">&#125; <span class="keyword">while</span> (a &gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>說明</p>
<ul>
<li><code>a--</code>後需要一個分號<code>;</code></li>
<li><code>while (a &gt; 1)</code>後需要一個分號<code>;</code></li>
</ul>
<p>關於到底要不要加分號這個議題，真的有非常非常多的討論…像是</p>
<ul>
<li><a href="http://oldblog.eddychang.me/blog/javascript/97-js-semicolon.html">JavaScript 裡的語句用分號結尾是個選項嗎</a></li>
<li><a href="https://github.com/airbnb/javascript#semicolons">Airbnb JavaScript Style Guide: Semicolons</a></li>
</ul>
<p>就我個人而言，都是會好好如上分號的, 因為不加分號的意思不就是「我弄壞了但要別人幫我擦屁股」的意思嗎？…</p>
<p>並且，邀請大定加入<a href="https://eslint.org/">ESLint</a> 的行列，使用工具自動檢視程式碼中微小但重要的問題！</p>
</li>
</ul>
<h4 id="錯誤-Errors"><a href="#錯誤-Errors" class="headerlink" title="錯誤(Errors)"></a>錯誤(Errors)</h4><h5 id="編譯時期的錯誤"><a href="#編譯時期的錯誤" class="headerlink" title="編譯時期的錯誤"></a>編譯時期的錯誤</h5><p>編譯或剖析時期丟出來的錯誤，由於程式尚未執行，因此無法以<code>try...catch</code>捕捉。</p>
<ul>
<li>SyntaxError，例如：無效的正規表達式<code>var a = /+foo/;</code></li>
<li>ReferenceError，例如：不合法的指定運算式<code>var a; 42 = a;</code></li>
</ul>
<h4 id="執行時期的錯誤"><a href="#執行時期的錯誤" class="headerlink" title="執行時期的錯誤"></a>執行時期的錯誤</h4><ul>
<li><p>TypeError，例如：重新設正已宣告為const變數<code>const a = 2; a = 4; </code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);<span class="comment">//TypeError: Assignment to constant variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="暫時死亡區域-Temporal-Dead-Zone-TDZ"><a href="#暫時死亡區域-Temporal-Dead-Zone-TDZ" class="headerlink" title="暫時死亡區域(Temporal Dead Zone, TDZ)"></a>暫時死亡區域(Temporal Dead Zone, TDZ)</h4><p>ES6定義了「暫時死亡區域」(Temporal Dead Zone,TDZ)，意思是程式碼中某個部份的變數的參考動作還不能執行的地方，這是因為該變數尚未被初始化的綠故。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a href="#%E6%9C%AA%E5%AE%9A%E7%BE%A9-undefined-vs%E6%9C%AA%E5%AE%A3%E5%91%8A-uneclared">之前</a>提到typeof對於尚未宣告的變數可有保護機制，但在這裡是無效的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    typeof a;</span><br><span class="line">    typeof b;</span><br><span class="line">    let b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h4><p>try區塊的內容vs finally區壞的內容，到底是誰會先執行?誰會後執行?</p>
<p>先來看第一個例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br></pre></td></tr></table></figure>

<p>顯示結果為</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>從結果看起來，似手難以判斷???</p>
<p>再來看第二個例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br></pre></td></tr></table></figure>

<p>顯示結果為</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>從執行順序來看，的確是先執行try區壞，再來才是finally區塊，但「述句完成值」會決定結果的「顯示」順序。首先，會先執行區塊的內容，像是<code>console.log(..)</code>，再來才是執行函式<code>foo()</code>回傳完成值，因此，在第一 個例子中，會先顯示「Hello World」，再顯示「12345」。而在第二個例子中，的確會覆寫try內的回傳伹，而成為這個函式最後的完成值因此得到12345</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch述句等同於if-else的縮寫，依靠break來決定是否要持續進行下一個case述句，若沒有break磺會「落穿而過」。</p>
<p>範例如下，這裡有一個檢測庫存的簡易範例，假設目前庫存數曉為50，當庫存為0～2時提示要趕快進貨補庫存，庫存到達50時顯示庫存充裕，庫存到達100時提示貨品是不是賣不掉，其化狀況都顯示為運作正常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">switch</span> (count) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;快賣完了！趕快進貨！&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;庫存充裕&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是不是賣不掉了！？&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;運作正常&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但出乎意料的是，結果印出「庫存充裕、是不是賣不掉了！？」。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">庫存充裕</span><br><span class="line">是不是賣不掉了！？</span><br></pre></td></tr></table></figure>

<p>這是因為如果沒有如入break，一旦某個符合條件了，接下來的case無論符合與否都會被執行，也就是剛才所提到的「落穿而過」。</p>
<p>加入break修改正下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">switch</span> (count) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;快賣完了！趕快進貨！&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;庫存充裕&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是不是賣不掉了！？&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;運作正常&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>結果印出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">庫存充裕</span><br></pre></td></tr></table></figure>

<p>另外，switch所做的比對是嚴格相等(<code>===</code>)，若希望能使用寬鬆相等(<code>==</code>)而能有強制轉制的功能，就需要改變一下寫法，像是…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;12345&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> a == <span class="number">10</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10 or &#x27;10&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> a == <span class="number">12345</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;12345 or &#x27;12345&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">//不會到達這裡的</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>結果得到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345 or <span class="string">&#x27;12345&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最後，default不一定要放在最後，順序是什麼並不重要喔！</p>
<h4 id="回顧-1"><a href="#回顧-1" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li><p>述句與運算式，述句完成值和其產生的副作用，解法和好處。</p>
</li>
<li><p>運用運算升優先序與結合性的規性的規則，並顧及程式碼的可讀性。</p>
</li>
<li><p>依賴ASI還是手動加入分號？我個入偏好要加分號！也𩏑薦大家使用ESLint！</p>
</li>
<li><p>錯誤-編譯時期的錯誤、執行時期的錯誤、暫時死亡區域(TDZ)。</p>
</li>
<li><p>try…finally與switch的特特殊狀況。</p>
<h5 id="References"><a href="#References" class="headerlink" title="References"></a>References</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/types%20%26%20grammar/ch5.md">You Don’t Know JS: Types &amp; Grammar, Chapter 5: Grammar</a></li>
</ul>
</li>
</ul>
<h3 id="你懂JavaScript嗎-範疇（Scope）"><a href="#你懂JavaScript嗎-範疇（Scope）" class="headerlink" title="你懂JavaScript嗎?範疇（Scope）"></a>你懂JavaScript嗎?範疇（Scope）</h3><p>本文會提到</p>
<ul>
<li>什麼是「範疇」?範疇的功用是？</li>
<li>編譯器怎麼理解程式碼？</li>
<li>什麼是巢狀範疇？</li>
<li>從LHS與RHS來理解JavaScript查找變數的報錯機制。</li>
</ul>
<h4 id="範疇（Scope）"><a href="#範疇（Scope）" class="headerlink" title="範疇（Scope）"></a>範疇（Scope）</h4><p>範疇（Scope）是指編繹器或JavaScript引擎藉由識別字名稱(identifier name)查找變數的一組規則。</p>
<h4 id="編譯器怎麼理解程式碼"><a href="#編譯器怎麼理解程式碼" class="headerlink" title="編譯器怎麼理解程式碼?"></a>編譯器怎麼理解程式碼?</h4><p>編譯器會在程式執行前將程碼由上到下逐行轉為電腦可懂的命令，稍後會執行這個編譯後的結果。注意，JavaScript引擎會在每次執行前即時編譯程式（約幾毫秒(ms)而已），接著立刻執行編譯後的指令。</p>
<p>編譯有三𦂇驟</p>
<ul>
<li><p>語法基本單元化與語彙分析（tokenizing&#x2F;lexing）：將字串解析成token，例如：<code>var a=2;</code>就會解析<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。</p>
</li>
<li><p>剖析或稱語法分析（parsing）：承上，將這些token（<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>）組成抽象語法樹（abstract syntax tree，AST）</p>
<img src="ast.png" style="zoom:50%;" />

<ul>
<li>產生目的程式碼（code-generation）：承上，將AST轉為可執行的程式碼，通常是機器語言，在這裡也會做最佳化。</li>
</ul>
</li>
</ul>
<h4 id="範疇的功用是？"><a href="#範疇的功用是？" class="headerlink" title="範疇的功用是？"></a>範疇的功用是？</h4><p>  在編譯的過程中，JavaScript引擎，編譯器和範疇會互相溝通以完成工作，它們各自負責的任睥有</p>
<ul>
<li>JavaScript引擎：負責整個編譯過程並執行程式碼。</li>
<li>編譯器：負責編譯三步驟-語法基本單元化與語彙分析，剖析或稱語法分析，產生目的程式碼</li>
<li>範疇：負責維護變數清單。</li>
</ul>
<p>  範例如下，這裡有一段程式碼，在編譯這段程式碼時，JavaScript引擎，𤚴譯器和範疇三者會做什麼呢？</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>在編譯的時候，編譯器會先到範疇詢問變數a是否存在，若不存在就宣告這個a變數。</li>
<li>接著，在執行階段，JavaScript引擎先到範疇詢問變數a是否存在，若存在就將2設定給它；若a不存在就報錯。</li>
</ol>
<p>  其中，引擎對範疇的查找變數的動作，可分為兩種類型</p>
<ul>
<li>LHS（left-hand side）：要查找的變數在指定動作的左邊，例如：<code> a = 2</code>的a在等號的左邊，就是執行LHS查找動作。</li>
<li>RHS（right-hand side）：變數不在指定動作的左邊，例如：<code>console.log(a)</code>，就是執行RHS查找動作。</li>
</ul>
<p>  備註：函式宣告（例如：<code>function foo() &#123;...&#125;</code>）並不是LHS！這是因為在做函式宣告時，就同時做了宣告和值的定義，而非在執行階段設定其值。</p>
<h4 id="巢狀範疇（Nested-Scope）"><a href="#巢狀範疇（Nested-Scope）" class="headerlink" title="巢狀範疇（Nested Scope）"></a>巢狀範疇（Nested Scope）</h4><p>若在目前執行的範疇找貨到這個變數的時候，就會往外層的範疇搜尋，持續搜尋直到找到為止，或直到最外層的全域範疇（global scope）; 而這樣一層又一層的範疇就稱為「巢狀範疇」(nested scope)。</p>
<p>如下。<code>conole.log(a + b)</code>中，b的RHS無法在foo中解析完成，但可到全域範疇解析出來。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="錯誤（Error）"><a href="#錯誤（Error）" class="headerlink" title="錯誤（Error）"></a>錯誤（Error）</h4><p>為什麼需要理解LHS和RHS呢？這是因為要看懂JavaScript報錯的原因。</p>
<p>當解析identifier失敗時</p>
<ul>
<li>若是RHS，則會丟出ReferrenceError的訊息</li>
<li>若是LHS，就會分為是否在嚴格模式(strict mode)的情況<ul>
<li>在非嚴格模式下，會在全域建立這個變數。</li>
<li>在嚴格模式下，會丟出ReferrenceError的訊息。</li>
</ul>
</li>
</ul>
<p>還有一種狀況，不論在LHS和RHS下，操作不合法的行為時，就會丟出TypeError的訊息。</p>
<ul>
<li>LHS：重新設定已宣告為const變數，<code>const a = 2; a = 4;</code>的<code>a = 4</code>會導致TypeError。</li>
<li>RHS：執行不是function的變數，<code>const b = 2; b();</code>的<code>b()</code>會導致TypeError。</li>
</ul>
<p><strong>範例</strong></p>
<p>這裡有一個小範例，判斷哪裡發生了LHS？哪裡發生了RHS？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="title function_">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>LHS</strong></p>
<ol>
<li><code>const c= ...</code></li>
<li><code>const b=...</code></li>
<li>隱點的參數設定<code>a = 2</code></li>
</ol>
<p><strong>RHS</strong></p>
<ol>
<li><code>const b = a</code>其中的<code>... = a</code>對a取值</li>
<li><code>return a + b</code>其中要對a取值</li>
<li><code>return a + b</code>其中要對b取值</li>
<li><code>foo(a)</code>其中要對foo取得其函數</li>
</ol>
<h4 id="回顧-2"><a href="#回顧-2" class="headerlink" title="回顧"></a>回顧</h4><p>我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>範疇是指編讀器或JavaScirpt引擎藉由識別字名稱查找變數的一組規則。</li>
<li>編譯器會在程式執行前將程式碼由上到下逐行轉為電腦可懂的命令，而稍後執行的即是這個編譯後的結果。編譯有三步驟：語法基本單元化夷語彙分析、剖析或稱語法分析、產生目的程式碼。並且，在編譯的過程中，JavaScript引擎、和範疇會互相溝通以完成工作。</li>
<li>在查找變數的過程中，若在目前執行的範疇找不到這個變數的時候，就會往外層的範疇搜尋，持續搜尋直到找到為止，或直到最外層的全域範疇。</li>
<li>從LHS與RHS來理解JavaScript查找變數的報錯機制。</li>
</ul>
<h4 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch1.md">You Don’t Know JS: Scope &amp; Closures, Chapter 1: What is Scope?</a></li>
</ul>
<h3 id="你懂JavaScript？語彙範疇（Lexical-Scope）"><a href="#你懂JavaScript？語彙範疇（Lexical-Scope）" class="headerlink" title="你懂JavaScript？語彙範疇（Lexical Scope）"></a>你懂JavaScript？語彙範疇（Lexical Scope）</h3><p>本文會提到</p>
<ul>
<li>什麼是語彙範疇？這階段要做什麼事情？</li>
<li>什麼會改變語彙範疇？有什麼影響？</li>
</ul>
<h4 id="語彙範疇（Lexical-Scope）"><a href="#語彙範疇（Lexical-Scope）" class="headerlink" title="語彙範疇（Lexical Scope）"></a>語彙範疇（Lexical Scope）</h4><p>範疇的運作方式有兩種-語彙範疇（Lexical scope）和動態範疇（dynamic scope），在這裡先來探討「語彙範疇」。</p>
<p>語彙分析階段會將字串解析成token，例如：<code>var a = 2;</code>會解析為<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。語彙範疇是在語彙分析時期所定義的範疇，剛範疇的劃分在程式碼撰寫時就決定好了，之後任何企圖修改的行為都是不恰當的。</p>
<p>參考以下程式碼，試著區分有幾個範疇？誰是誰的巢狀範疇？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">c</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bar</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>);<span class="comment">// 2 4 12</span></span><br></pre></td></tr></table></figure>

<img src="fig2.png" style="zoom:85%;" />

<p>圖片來源：[You Don’t Know JS: Scope &amp; Closures, Chapter 2: Lexical Scope](<a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope">https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope</a> %26 closures&#x2F;ch2.md)</p>
<p>這裡有三個範疇…</p>
<ul>
<li>(1)最外面的範疇即全域範疇，識別字有foo。</li>
<li>(2)中間的範疇是在foo裡面，識別字有a、b、bar。</li>
<li>(3)最裡面的範疇是在bar裡面，識別字只有c。</li>
</ul>
<h4 id="查找識別字"><a href="#查找識別字" class="headerlink" title="查找識別字"></a>查找識別字</h4><p>從上例可知，範疇的劃分說明了JavaScript引擎如何尋找識別字的所在之處。</p>
<p>這裡還要談兩個觀念「遮蔽（shadowing）」和「全域變數（global variable）」。</p>
<ul>
<li>遮蔽（shadowing）：若相同的識別字同時出現在不同的巢狀範疇中，那麼只履在巢狀範疇內層找偌第一個符合的識別字就會停止搜尋。</li>
<li>全域變數（global variable）：全域變數會自動變成全堿物件的屬性，因此能使用<code>window.a</code>來避免a被巢狀範疇內層的同名變數遮蔽。</li>
</ul>
<p>備註：範疇的查找只適用於一級識別字，例如：a、b這樣單層的名稱。如果是要找foo.bar.a的話，範疇的查找冬會找到foo，之後的bar和a就會由物件存萬規則（object property-access rules）來繼續解析。</p>
<h4 id="什麼會變變語彙範疇？有什麼影響？"><a href="#什麼會變變語彙範疇？有什麼影響？" class="headerlink" title="什麼會變變語彙範疇？有什麼影響？"></a>什麼會變變語彙範疇？有什麼影響？</h4><p>取兩個方法會在執行時修變語彙範疇-eval和with。</p>
<h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5><p>範例如下，在foo內執行eval，導致<code>console.log(...)</code>時JavaScript引擎尋找b時在foo這範疇找偌(其值為3)，而遮蔽了全域的b(其值為2)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">str, a</span>) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;var b=3;&#x27;</span>, <span class="number">1</span>);<span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<p>eval很邪惡，好孩子不要用！</p>
<h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5><p>with會在執行時創建新的語彙範疇，這裡來看一個全域值外𣼣的例子。</p>
<p>當with區塊執行時，with將物件參考當成範疇來看，𫍇個物件的特性就會成為該範疇內的識別字。因此，<code>a = 2</code>其實是在做LHS的動作，若在o2和foo的範疇找到a，就會往全域範疇來找，由於在此並非嚴格模式，因此在找不到的情況下，就會生一個全域變數a並設定其值為2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>(o1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(o2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">a</span>);<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 2,全域值外𣼣</span></span><br></pre></td></tr></table></figure>

<p>幸好，with已被禁止使用了。</p>
<h4 id="為什麼eval和with會導致效能不佳？"><a href="#為什麼eval和with會導致效能不佳？" class="headerlink" title="為什麼eval和with會導致效能不佳？"></a>為什麼eval和with會導致效能不佳？</h4><p>JavaScript引擎會編譯時期進行最佳化，例如，靜態分析程碼，確定變數和函式的宣告，這樣在執行時期就能節省解析識別字的成本。</p>
<p>但若在程式碼中有eval或with，剛剛在編譯時期所確認的變數和函式的所式位置的結果都無效了，因為JavaScript引擎無法在編譯時期確認到底傳入什麼東西給eval或有什麼內容會讓with創建新的語彙範疇，所以也就不知道有什麼會改變誥彙範疇了，也就是說，剛剛所做的最佳化都沒有意義了，JavaScript引擎可考慮乾脆不要最佳化，因此程式碼就會跑得比較慢。效能比較差。</p>
<h4 id="回顧-3"><a href="#回顧-3" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>語彙範疇是在語彙分析時期定義的範疇，而範疇的劃分在程碼撰寫時就決定好了，之後任何企圖修改行為都是不恰當的。</li>
<li>範疇是編譯器或JavaScript引擎藉由識別字名稱查找變數的三組規則。其中，「遮蔽」是指只要找到巢狀範疇內第一個符合的識別字就會停籍搜尋； 「全域變數」必須使用<code>window.x</code>來避免被內層變數遮蔽； 範疇的查找只適用於單層的識別字名稱，若為多層則是由物件存取規則來做解析。</li>
<li>eval和with由於會修改語彙範疇，讓編譯時期所做的工都白費，因此效能不佳，應避免使用。</li>
</ul>
<h4 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch2.md">You Don’t Know JS: Scope &amp; Closures, Chapter 2: Lexical Scope</a></li>
</ul>
<h3 id="你懂JavaScript？函式範疇與區塊範疇（Function-vs-Block-Scope）"><a href="#你懂JavaScript？函式範疇與區塊範疇（Function-vs-Block-Scope）" class="headerlink" title="你懂JavaScript？函式範疇與區塊範疇（Function vs Block Scope）"></a>你懂JavaScript？函式範疇與區塊範疇（Function vs Block Scope）</h3><p>本文會提到</p>
<ul>
<li>範疇的劃分單位可分為兩種-函式範疇與區塊範疇，它們有什麼不同？各有什麼優點？</li>
<li>函式範疇的重要觀念與相關應用-函式宣告與函式運算式、匿名與具名函式、即刻調用函式運算式。</li>
<li>區塊範疇的重要觀念與相關應用-const與let、垃圾回收。</li>
</ul>
<h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>「範疇」（scope）是指編譯器或JavaScript引擎藉由識別字名稱查找變數的一組規則，而劃分範疇的單位可分為兩種-函式範疇與區塊範疇，也就是說，每個「函式」或「區塊」是可以建立各自的範疇，在ES6以前，只有函式能建立範疇，而在ES6之後，可用大括號<code>&#123;...&#125;</code>定義區塊範疇，讓const和let宣告以區塊為範疇的變數。</p>
<h4 id="函式範疇（Function-Scope）"><a href="#函式範疇（Function-Scope）" class="headerlink" title="函式範疇（Function Scope）"></a>函式範疇（Function Scope）</h4><p>函式會建立自已的範疇，其內的識別字（不管是變數、函式）僅能在這個函式裡面使用。</p>
<p>範例如下，在全域範疇底下，是無法存取foo內a、b、c和bar，否則會導致ReferrenceError；但在foo自已的函式範疇內，可以存取a、b、c和bar。</p>
<p>foo可自由存其內的a、b、c和bar</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//3</span></span><br><span class="line">    <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>全域範疇之下是無法存取foo內的a、b、c和bar的，但可存取foo喔！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferrenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferrenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferrenceError</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferrenceError</span></span><br></pre></td></tr></table></figure>

<h4 id="使用「函式範疇」有什麼好處？"><a href="#使用「函式範疇」有什麼好處？" class="headerlink" title="使用「函式範疇」有什麼好處？"></a>使用「函式範疇」有什麼好處？</h4><p>使用「函式範疇」有什麼好處？或說解決什麼問是呢？大致上有這兩點…</p>
<ul>
<li>維持最小權限原則，以避免變數或函式被不當存取。</li>
<li>避免同名識別字所造成的衝突，這當中包含了避免污染全域命名空間和模組的管理。</li>
</ul>
<h4 id="最小權限原則"><a href="#最小權限原則" class="headerlink" title="最小權限原則"></a>最小權限原則</h4><p>函式範疇能維挫「最小權限原則」（principle of least privilege），或稱為「最小授權」（least authority）、「最小暴露」（least exposure），可防止變數或函式被不當存取。</p>
<p>範例如下，secretData是foo的私有變數，可能是儲存了foo之外其他程式碼不需要知道的資料，因此對於其他地方（包含全域範疇）的程式碼來說，是無法直接存取到secretData的，只能透過foo公開的API「bar」取得經過處理後的資料，如publicData。這樣的好處是，除了foo之外是無法經由任何管道修改它的私有變數secretData的，可防止其伳地方的程式碼的不當存取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secretData = <span class="string">&#x27;HelloWorld&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> secretData.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"><span class="keyword">var</span> publicData = baz.<span class="title function_">bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(publicData);<span class="comment">// H-e-l-l-o-W-o-r-l-d</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secretData);<span class="comment">// Uncaught ReferenceError: secretData is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="避免衝突"><a href="#避免衝突" class="headerlink" title="避免衝突"></a>避免衝突</h4><p>避免同名變數或函式所造成的衝突。</p>
<p>如下範例，這裡有兩個函式doSomething與doSomethingElse。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    b = a + <span class="title function_">doSomethingElse</span>(a * <span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="number">2</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>若此時還有一個同名的函doSomethingElse，就會導致衝突，回傳的答案就不是原本預期的15，而是12。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    b = a + <span class="title function_">doSomethingElse</span>(a * <span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="number">2</span>); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改寫如下，將doSomething私有的細節（也就是第一個doSomethingElse函式）藏在其範疇中，這樣兩個doSomethingElse函式就不會造成衝突了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    b = a + <span class="title function_">doSomethingElse</span>(a * <span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="number">2</span>); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一個例子，如下，函式bar內的 i 是個全域變數，它無意間修改的 foo loop 的 i，導致 i 永遠都是 3，而進入了無窮迴圈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">bar</span>(i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>解法是將bar內的 i 宣告為區域變數，這樣就會將這個 i 包在bar的範疇裡面，避免被其他不相干的程式碼存取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">3</span>;<span class="comment">// 將 bar 內的 i 宣告為區域變數</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">bar</span>(i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h4 id="全域命名空間（Global-Namespace）"><a href="#全域命名空間（Global-Namespace）" class="headerlink" title="全域命名空間（Global Namespace）"></a>全域命名空間（Global Namespace）</h4><p>通常我們使用的函式庫都適當的隱藏自已內部所使用的變數和函式，意即將它們做成某物件屬性和方法而非暴露在全域底下，而物件即是它們的命名空間（namespace），這樣就可以避免在全域範疇中因同名而產生的衝突。</p>
<p>範例如下，物件MyReallyCoolLibrrary內含有屬性awesome和方法doSomething與doAnotherThing，可避免全域範疇中也有同名的變數awesome或函式doSomething或doAnotherThing。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyReallyCoolLibrary</span> = &#123;</span><br><span class="line">    <span class="attr">awesome</span>: <span class="string">&#x27;stuff&#x27;</span>,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">doAnotherThing</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="模組管理（Module-Management）"><a href="#模組管理（Module-Management）" class="headerlink" title="模組管理（Module Management）"></a>模組管理（Module Management）</h4><p>除了使用前面提到的命名空間來避免衝突外，另一個解法是使用模組（module），藉由工具（例如：webpack）產生相依管理機制，避免函式衷新增依何識別字到全域範疇，而是要求函式庫將識別字匯入（import）至特定的範疇，模組管理機級並沒有跳脫範疇的掌控，而是巧妙地避免污全域範疇，將函式庫的識別字保持在私有範疇中，解決了衝突的問題。若不使用工具，也可在撰寫程式碼時使用模組模式（module pattern）。</p>
<h4 id="即刻調用函式運算式Immediately-Invoked-Function-Expression-IIFE）"><a href="#即刻調用函式運算式Immediately-Invoked-Function-Expression-IIFE）" class="headerlink" title="即刻調用函式運算式Immediately Invoked Function Expression,IIFE）"></a>即刻調用函式運算式Immediately Invoked Function Expression,IIFE）</h4><p>IIFE是可立即執行的函式運算式，主要好處是不污染全域範疇，並且匿名或具名皆合法。</p>
<p>在談論IIFE前，先來看幾個重要觀念</p>
<ul>
<li>函式宣告 vs 函式運算式</li>
<li>匿名 vs 具名</li>
</ul>
<h4 id="函式宣告（Function-Declaration）vs-函式運算式（Function-Expression）"><a href="#函式宣告（Function-Declaration）vs-函式運算式（Function-Expression）" class="headerlink" title="函式宣告（Function Declaration）vs 函式運算式（Function Expression）"></a>函式宣告（Function Declaration）vs 函式運算式（Function Expression）</h4><p>函式宣告（function declaration）就像是其他資料型別所宣告的字面值一樣，利用關鍵字function宣告一個函式，後接函式名稱與其本體，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>函式運算式（function expression）是指將一個函式指定給特定變數的過程，範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>廣義上來說，只要函式述句並非以function開頭，而是以<code>var foo = functon ...</code>或<code>(function foo()) ...</code>起始的（像是稍後提到的IIFE），都是函式運算式。</p>
<h4 id="匿名-vs-具名（Anonymous-vs-Named）"><a href="#匿名-vs-具名（Anonymous-vs-Named）" class="headerlink" title="匿名 vs 具名（Anonymous vs Named）"></a>匿名 vs 具名（Anonymous vs Named）</h4><p>承上，函式運算式可分為具名和匿名的範例如下。</p>
<p>具名的函式運算式，具有名稱識別字bar. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>匿名的函式運算式，匿名就沒有名稱識別字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>再看一另一個例子，我們很習慣在callback中使用匿名運算式，<del>這好嗎？</del></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等一秒後執行&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>或寫成 arrow function</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等一秒後執行&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>而匿名的函運算式有以下缺點</p>
<ul>
<li>stack trace 因報錯時沒有具體名稱會較難追踨。</li>
<li>沒有名稱會難以遞迴（解法是必須使用已廢棄的<code>arguments.callee</code>），且無法指定名稱做自身的unbind。</li>
<li>無法立即知道該匿名函式的功能，可讀性較差。</li>
</ul>
<p>解法𣄵是給它一個名字，例如timeoutHandler，百利而無一害，用吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeoutHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等一秒後執行&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">timeoutHandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等一秒後執行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(timeoutHandler, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>先前提到的例子中，不管是函式宣告或函式運算式，都污染到全域範疇，因此可能會遇到剛才所提到的問題…像是避免變數或函式被不當存取、同名識別字所造成的衝突等。因此，我們可使用「即刻調用函式運算式」（Immeidately Invoked Function Expression,IIFE）來解決這個問題。</p>
<p>IIFE是可立即執行的函式運算式，主要好處是不污染全域範疇，並且匿名或具名皆合法。</p>
<p>具名為foo的IIFE</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>匿名的IIFE。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IIFE還有一些功能，例如：指定範疇，確保undefined的正確性與反轉順序。</p>
<h4 id="指定範疇"><a href="#指定範疇" class="headerlink" title="指定範疇"></a>指定範疇</h4><p>將傳入的參數當作範疇。</p>
<p>如下，將window傳入以作為具名的IIFE的範疇，並指名為global，這樣的命名方式有助於程式的可讀性，簡單易懂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"><span class="variable language_">global</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="確保undefined的正確性"><a href="#確保undefined的正確性" class="headerlink" title="確保undefined的正確性"></a>確保undefined的正確性</h4><p>有些程式碼會因為錯誤的撰寫方式，導致污染了undefined的值，因此可指定一個參數，但不傳入值，以維扲undefined的正確性。</p>
<p>如下，IIFE雖然有設定參數undefined，但<code>()</code>卻是空的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"><span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Undefined 在這裡很安全！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="反轉順序"><a href="#反轉順序" class="headerlink" title="反轉順序"></a>反轉順序</h4><p>前方放置呼叫的參數並執行未來傳入的函式，而後方放置將要執行的函式。這種寫法常用UMD（universal module definition）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params">def</span>) &#123;</span><br><span class="line">  <span class="title function_">def</span>(<span class="variable language_">window</span>);</span><br><span class="line">&#125;)(<span class="keyword">function</span> <span class="title function_">def</span>(<span class="params"><span class="variable language_">global</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>把上面這段程式碼拆開來，可當成這裡有兩個變數a和def，其中def是待會要執行的函式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> def = <span class="keyword">function</span>(<span class="params"><span class="variable language_">global</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用IIFE結構，前方將要執行的函式當成參數func傳入，並且func代入window這個參數。接著，由後方傳入要執行的函式def。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="title function_">func</span>(<span class="variable language_">window</span>);</span><br><span class="line">&#125;)(def);</span><br></pre></td></tr></table></figure>

<p>不過呢，自從有了ES6的let與var搭配區塊範疇<code>&#123;...&#125;</code>之後，我們再也不需要IIFE了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>剛剛的例子就可以改成…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 做一些運算...</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="區塊範疇（Block-Scope）"><a href="#區塊範疇（Block-Scope）" class="headerlink" title="區塊範疇（Block Scope）"></a>區塊範疇（Block Scope）</h4><p>在ES6以前，只有函式能建立範疇，而在ES6之後，可用大括號<code>&#123;...&#125;</code>定義區塊範疇，讓const和let宣告以區塊為範疇的變數。</p>
<p>如下，i 屬於函式foo的範疇，而非假想的 for loop的區塊範疇。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而ES6的const 與 let可宣告以區塊為範疇的變數。</p>
<p>const。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">const</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>const 表示常數（constant），宣告時就必須賦值，賦值後不可修改其值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">bar = <span class="number">3</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>let。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>當let宣告於for迴圈內時：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面這段程式砠可以看成是這樣…i是屬於第一個大括號所包含的區壞的，因此i一但出了第一個大括號所包含的範圍就會報錯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>注意，迴圈的每次迭代都會對 i 重新綁定（rebind），這樣就能確保重新賦值。</p>
<p>const 與 let不會有拉升（hoisting）的狀況。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="垃圾回收（Garbage-Collection）"><a href="#垃圾回收（Garbage-Collection）" class="headerlink" title="垃圾回收（Garbage Collection）"></a>垃圾回收（Garbage Collection）</h4><p>一但變用不到了，JavaScript引擎就可能會將它回收，但由於範疇的緣故，仍須保留這些變數存取值的能力，而區塊塊疇明確表達資料不再用到，而解決這個不需要被保留的狀況，可釋出更多記憶體空間。這部份與閉包（closure）有關，待續詳細說明閉包的機制。</p>
<p>範例如下，雖然clickHandler用入到變數someReallyBigData，因此函式process處理完someReallyBigData應該就可回收someReallyBigData的記憶體空間，但由於clickHandler擁有對整個範疇的閉包（後續會提到，閉包是函式記得並存取語彙範疇的能力，可說是指向特定範疇的參考，因此當函式是在其語彙範疇之外執行時也能正常運作），因此 JavaScript 就不會把它回收了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 做一些有趣的事情...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">process</span>(someReallyBigData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;this_button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>), <span class="keyword">function</span> <span class="title function_">clickHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按鈕按下去了&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是呢，區壞範疇能幫我們解決這個問題，區塊範疇告訴JavaScript引擎這些內容僅在這一塊範圍內用到而已，之後就能讓JavaScript引擎順利把用不到的資料回收掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 做一些有趣的事情...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在這個區塊內宣告的任何資料在處理完後就可被丟棄！</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">  <span class="title function_">process</span>(someReallyBigData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;this_button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>), <span class="keyword">function</span> <span class="title function_">clickHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按鈕按下去了&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="回顧-4"><a href="#回顧-4" class="headerlink" title="回顧"></a>回顧</h4><p>我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>函式會建立自已的範疇，其內的識別字（不管是變數、函式）僅能在這個函式裡面使用。函式範疇可避免變數或函式被不當存取的問題，並避免同名識別字所造成的衝突，通常應用於命名間與模組管理。</li>
<li>函式範疇的重要觀念與目關應用-函式宣告與函式運算式、匿名與具名函函式、即刻調用函式運算式。</li>
<li>在ES6之後，可用大括號<code>&#123;...&#125;</code>定義區壞範疇，讓const和let宣告以區塊為範疇的變數。</li>
<li>區塊範疇的相關觀念與應用-垃圾回收、for迴圈中let的變數宣告等。</li>
</ul>
<h5 id="References-3"><a href="#References-3" class="headerlink" title="References"></a>References</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch3.md">You Don’t Know JS: Scope &amp; Closures, Chapter 3: Function vs. Block Scope</a></li>
</ul>
<h3 id="你懂JavaScript嗎？拉升（Hoisting）"><a href="#你懂JavaScript嗎？拉升（Hoisting）" class="headerlink" title="你懂JavaScript嗎？拉升（Hoisting）"></a>你懂JavaScript嗎？拉升（Hoisting）</h3><p>主要會談到</p>
<ul>
<li><p>什麼是拉升（hoisting）</p>
</li>
<li><p>變數與函式的拉升有什麼不同？</p>
</li>
<li><p>怎麼處理在<code>&lt;script&gt;</code>宣告的全域變數？是否也有拉升的狀況？</p>
</li>
<li><p>拉升 vs 重複宣告變數與函式，要怎麼處理？</p>
</li>
</ul>
<h4 id="什麼是拉升（Hoisting）"><a href="#什麼是拉升（Hoisting）" class="headerlink" title="什麼是拉升（Hoisting）?"></a>什麼是拉升（Hoisting）?</h4><p>你有遇到這重狀況嗎？明明變數尚未被宣告，但用的時候居然沒被報錯，還得到值undefied???咦？等等、怎麼不是得到2？？？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>我真的被這個問題嚇到惹，到底發生了什麼事？</p>
<p>「這是hoisting」好嗎？</p>
<p>先來看編譯器怎麼看待這段程式碼。</p>
<p>一開始，編譯器在編譯時期會先找出所有的變數並綁定所屬範疇，但不賦值，所以此刻變數所帶的值是undefined; 而在執行階段，JavaScript引擎才會處理給值的事情。</p>
<p>因此，上面這段程碼，在編譯器的眼中，其實是這樣的…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;<span class="comment">// 編譯時期確認 a 屬於全域範疇，但不賦值，所以此刻變數所帶的值是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 得到 unddefined</span></span><br><span class="line">a= ？;<span class="comment">// 執行時期才會知道 a 的值是什麼</span></span><br></pre></td></tr></table></figure>

<p>console的結果是undefined，而非RHS解析失敗「ReferenceError:a is not defined」，畢竟變數已經被定義了，只是不知道真正的值是什麼是什麼而已。</p>
<p>通常，我們可想像成這是因為編譯會掃過程式碼中的宣告的變數函式，而巴這些變數和函式「提升」到程式碼的最頂端，因此當印出a的值的時候，會是已宣告但還沒賦值的狀態，也就是有這個變數，但其值是undefined。</p>
<p>結合編譯和執行時期的分工狀況，可想成是這樣…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;<span class="comment">// 編譯時期的工作</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 執行時期的工作</span></span><br><span class="line">a = <span class="number">2</span>;<span class="comment">// 執行時期的工作</span></span><br></pre></td></tr></table></figure>

<p>又，以下有幾點需要注意的議題…</p>
<h4 id="拉升是逐範疇的！"><a href="#拉升是逐範疇的！" class="headerlink" title="拉升是逐範疇的！"></a>拉升是逐範疇的！</h4><p>也就是說，在函式內宣告變數，不會被拉升到全域範疇而成為全域變數。</p>
<h4 id="函式運算式不會被提升"><a href="#函式運算式不會被提升" class="headerlink" title="函式運算式不會被提升"></a>函式運算式不會被提升</h4><p>函式運算式（function expression）不會被提升。如下，foo此時的值是undefined，所以當執行<code>undefined()</code>就會得到TypeError。而bar這個識別字是屬於foo的範疇的，所以在這裡會報錯ReferenceError。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// TypeError</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo=<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>實際上應該看成…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// TypeError</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bar =...self...</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這是因為拉升只會有變數宣告的部份，後續的指定等運算都不會跟著提升。</p>
<h4 id="變數-vs-函式的拉升"><a href="#變數-vs-函式的拉升" class="headerlink" title="變數 vs 函式的拉升"></a>變數 vs 函式的拉升</h4><p>變數與函式的拉升的不同之處在於，變數的拉升只有宣告部份，而函式的拉升是整個函式，因此函式在宣告前是可以執行的。</p>
<h4 id="多個中的全域變數並不會被拉升"><a href="#多個中的全域變數並不會被拉升" class="headerlink" title="多個&lt;script&gt;中的全域變數並不會被拉升"></a>多個<code>&lt;script&gt;</code>中的全域變數並不會被拉升</h4><p>在不同<code>&lt;script&gt;</code>包圍，即視為隊同的檔案，因此某支檔案中的變數宣告不會被拉升到另一支檔案的頂端。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;<span class="title function_">foo</span>();&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">..</span>) &#123; &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是呢，以下兩種情況是允許的，可正常執行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">..</span>) &#123; &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; .. &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>foo();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上例與拉升無關，而是因為在同一支HTML檔案中嵌入的<code>&lt;script&gt;</code>共用同一個全域範疇，因此在第一個<code>&lt;script&gt;</code>中宣告了foo函而成為全域物件的屬性，在第二個<code>&lt;script&gt;</code>中就可以使用這個屬性了。</p>
<h4 id="重複宣告"><a href="#重複宣告" class="headerlink" title="重複宣告"></a>重複宣告</h4><p>若函式和變數同名，則函式會優先； 若同時有多個函式同名，則後面的會覆寫前面的宣告。</p>
<p><strong>範例1：若函式和變數同名，則函式會優先</strong></p>
<p>範例如下，同名函式foo和變數foo。由於函式優先，因此<code>foo()</code>得到1而非<code>undefined()</code>的結果TypeError。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();<span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>這是因為要看成…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>範例2：若同時有多個函式同名，則後面的會覆寫前面的宣告</strong></p>
<p>範例如下，三個同𪨘函式foo，最後一個foo會覆寫前面的宣告，因此得到3。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">//3 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回顧-5"><a href="#回顧-5" class="headerlink" title="回顧"></a>回顧</h4><p>可以理解到</p>
<ul>
<li><p>編譯器在鍽譯時期會先找出所有的變數並綁定所屬範疇，但不賦值，所以此刻變數所帶的值是undefined； 而在執行階段，JavaScript引擎才會處理給值的事情。 可以想成是這些變數和函示「提升」到程式碼的最項端，這就是所謂的拉升（hoisting）。</p>
</li>
<li><p>拉升是逐範疇的，在函式內宣告變數，不會被拉升到全域範疇而成為全域變數。</p>
</li>
<li><p>函式運算式不會被提升。</p>
</li>
<li><p>變數與函式的拉升的不同之處在於，變數的拉升只有宣告部份，而函式的拉升是整個函式，因此函式在宣告前是可被執行的。</p>
</li>
<li><p>同一支HTML檔案中嵌入的多個<code>&lt;script&gt;</code>時，不同<code>&lt;script&gt;</code>包圍的即視為不同的檔案，因此某支檔案中的變數宣告不會被拉升到另一支檔案的頂端。</p>
</li>
<li><p>若函式和變數同名，則函式會優先； 若同時有多個函式同名，則後面的會覆寫前面的宣告。</p>
</li>
</ul>
<h5 id="References-4"><a href="#References-4" class="headerlink" title="References"></a>References</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch4.md">You Don’t Know JS: Scope &amp; Closures, Chapter 4: Hoisting</a></li>
</ul>
<h3 id="你懂JavaScript嗎-動態範疇（Dynamic-Scope）"><a href="#你懂JavaScript嗎-動態範疇（Dynamic-Scope）" class="headerlink" title="你懂JavaScript嗎?動態範疇（Dynamic Scope）"></a>你懂JavaScript嗎?動態範疇（Dynamic Scope）</h3><p>本文主要是比較動態範疇與語彙範疇的差異。</p>
<h4 id="動態範疇（Dynamic-Scope）-vs-語彙範疇（Lexical-Scope）"><a href="#動態範疇（Dynamic-Scope）-vs-語彙範疇（Lexical-Scope）" class="headerlink" title="動態範疇（Dynamic Scope） vs 語彙範疇（Lexical Scope）"></a>動態範疇（Dynamic Scope） vs 語彙範疇（Lexical Scope）</h4><p>先前提過範疇是指編譯器或JavaScript引擎藉由識別字名稱（identifier name）查找變數的一組規則；而「語彙範疇」是指在語彙分枉時期所定義的靜態範疇，且不經由eval或with在執行時的修改。語彙範疇考量的是變數「如何和何處被宣告」，其查找的範疇串鏈是以程試式碼的巢狀結構為基礎。</p>
<p>範例如下，在foo 中的a由於無法在所在函式foo內經由RHS解析得到的值，因此會往全域範疇查找，因而得到3。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>

<p>範例如下，同樣的， a 在 foo 中無法解析其值，因此循著 call stack 找到 foo 被呼叫的地方 bar，在 bar 內找到 a 的值為 2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 3  (not 2!)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>

<p>事實上，<strong>JavaScript 並沒有動態範疇</strong>，但 this 的查找規則是類似動態範疇的，在後續關於 this 的篇章會再詳細說明。</p>
<h4 id="回顧-6"><a href="#回顧-6" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什𫐤收穫呢？藉由本文可以理解到…</p>
<p>語彙範疇與動態範疇的主要差異在於，前者查找範疇串鏈是以程式碼的巢狀結構為基礎，而後都則是以呼叫堆疊（call stack 為基礎）。</p>
<h5 id="References-5"><a href="#References-5" class="headerlink" title="References"></a>References</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/apA.md">You Don’t Know JS: Scope &amp; Closures, Appendix A: Dynamic Scope</a></li>
</ul>
<h3 id="你懂JavaScript-閉包（Closure）"><a href="#你懂JavaScript-閉包（Closure）" class="headerlink" title="你懂JavaScript?閉包（Closure）"></a>你懂JavaScript?閉包（Closure）</h3><p>本文主要會談到</p>
<ul>
<li>閉包是什麼？有什麼功用？</li>
<li>迴圈與閉包搭配使用時的謬誤與陷阱。</li>
<li>模組模是什麼？</li>
<li>如何管理模組？探討模組依存性載入器&#x2F;管理器與ES6模組。</li>
</ul>
<h4 id="閉包（Closure）"><a href="#閉包（Closure）" class="headerlink" title="閉包（Closure）"></a>閉包（Closure）</h4><p>閉包是函式記得並存取語彙範疇的能力，可說是指向特定範疇的參考，因此當函式是在其宣告的語彙範疇之外執行時也能正常運作。</p>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">baz</span>();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>說明</p>
<ul>
<li>函式能夠存取的範疇即是其被內嵌後往外推的範圍，例如bar被內嵌於foo之內，因此bar內變數可存取的範圍就是foo和全域範疇。因此，基於語彙範疇的變數查找規則，bar內的a在自已的函式範疇內找不到定義的話，可往外層的範疇查找，於是在foo內找到了，得到a為2，其中，<code>console.log(a)</code>是執行RHS查找。</li>
<li>JavaScript引擎的垃圾回收機制會釋收不再使用的記憶體，但閉包為了保留函式記得和存取其語彙範疇的能力，就會以予保留，不做記憶體回收。因此<strong>bar仍保留指向foo的內層範疇的參考，這個參考就是閉包。</strong></li>
<li>最後，雖然baz位於bar所定義的範疇之外，但由於閉包的緣故，bar仍能正常執行，而得到a的值。</li>
</ul>
<p>閉包在callback上的應用尤其常見，如下所示，在程式碼的最後一行<code>wait(&#39;Hello, 閉包！&#39;);</code>中傳入字串「Hello,閉包！」給函式wait時，儘管timer已離開了所宣告的範疇之內，但仍保留了timer存取wait傳入參數的值的能力，而印出結果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">wait</span>(<span class="string">&#x27;Hello,閉包！&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>閉包可說是仰賴語彙範疇來撰寫程式碼而得到的必然結果。</p>
<p>有一種一但承諾了就永遠分不開的feelXD</p>
<h4 id="迴圈與閉包"><a href="#迴圈與閉包" class="headerlink" title="迴圈與閉包"></a>迴圈與閉包</h4><p>如果今天要實作一個每秒依序印出數字1,2,3…,5的功能，你會怎麼做呢？</p>
<p>是這樣嗎?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好像有點怪怪的？</p>
<p>這的確是錯誤的。由於<code>console.log(i)</code>中的i會存取的範疇是for所在的範疇（目前看起來是全域範疇，因為var宣告的變數不具區塊範疇的特性），因此當1秒、2秒、…5秒後執行<code>console.log(i)</code>就會去取i的值，而此時for迴圈已跑完，i 變成6，因此就會每隔一秒印出一個「6」。</p>
<p>若希望每隔一秒印出1、2、…5，可使用IIFE加入新的範疇來修改，意即為每次迭代都建立一個新的函式範疇（但其實我們想要的是建立一個區塊範疇）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">        &#125;, j * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即然是要為每次迭代建立區壞範疇，更好的解法就是使用<strong>let</strong>，let會在每次迭代時重新宣告變數i，並將上一次迭代的結果作為這一次的初始值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模組模式（Module-Pattern）"><a href="#模組模式（Module-Pattern）" class="headerlink" title="模組模式（Module Pattern）"></a>模組模式（Module Pattern）</h4><p>模組模式（module pattern）又稱為揭露模組（revealing module），經由建立一個模組實體（module instance，如下範例的foo），來調用內層函式doSomethong和doAnother。而內層函由於具有閉包的特性，因此可存取外層的變數和函式（something與another）。透過模組模式，可隱藏私密資訊，並選擇對外公開的API。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&#x27;cool&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(angother.<span class="title function_">join</span>(<span class="string">&#x27; ! &#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">        <span class="attr">doAnother</span>: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">CoolModule</span>();</span><br><span class="line">foo.<span class="title function_">doSomething</span>();<span class="comment">// cool</span></span><br></pre></td></tr></table></figure>

<p>以上這個例子並不難理解，它等於就是本文開頭foo、bar和baz的變形而已。</p>
<p>又，模組模式的另一個變形是singleton-包上IIFE，用於只想要產生單一實體的時候，修改上例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&#x27;cool&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&#x27; ! &#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">        <span class="attr">doAnother</span>: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">doSomething</span>();<span class="comment">// cool</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>

<h4 id="模組依存性載入器（Module-Dependency-Loader）"><a href="#模組依存性載入器（Module-Dependency-Loader）" class="headerlink" title="模組依存性載入器（Module Dependency Loader）"></a>模組依存性載入器（Module Dependency Loader）</h4><p>既然我們知道了怎麼撰寫模組，那麼，要怎麼管理多個模組呢？像是模組中引用其他模組時，可能會因程式碼放置的順序不對、產生相依性問題剛導致出鏌，該怎麼辦呢？</p>
<p>這裡提出兩個解法-使用模組依存性載入器或ES6模組，先來看前者。</p>
<p>模組依存載入器或管理器（module dependency loader&#x2F;manager）是指將模組定義的模式包裝成一個友善的API。範例如下，這是一個簡單的模組依存性載入器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyModules</span> = (<span class="keyword">function</span> <span class="title function_">Manager</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">define</span>(<span class="params">name, deps, impl</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];<span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.<span class="title function_">apply</span>(<span class="literal">null</span>, deps);<span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">define</span>: define,</span><br><span class="line">        <span class="attr">get</span>: get</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>說明如下，在Manager這個IIFE裡面包含了一些變數和函式…</p>
<ul>
<li>變數modules存放各個模組所公開的API，例如：bar 的hello、foo的awesome。</li>
<li>函式define輸入的個參數-name、deps與impl，name是模組名稱； deps是與此模組相依的模組，以陣式方式傳入； impl是用於定義一個外層包裏函式以建立範疇。讓其內的函式能指向這個範疇而產生閉包，最後這個函式impl會回傳公開API。<ul>
<li>標註（1）的部份：deps本來是儲存相依模組名稱的陣列，在這裡改為存放這個相依模組名稱公開API。例如：deps的內容是<code>[&#39;bar&#39;]</code>，<code>deps[0]</code>的內容是<code>&#39;bar&#39;</code>，因此<code>deps[0] = modules[deps[0]]</code>可看成是<code>bar = modules[&#39;bar&#39;]</code>，moudels[‘bar’]以物件方式儲存bar的公開API，例如：hello和world，即是<code>bar = modules[&#39;bar&#39;]=&#123; hello: f, world: f&#125;</code>。</li>
<li>標註（2）的部分：這裡為模組呼叫定義了一個包裹函式，用來將回傳值（這個值是指模組的API）存入以名稱來當作參考的一個模組清單。此模組impl會傳入兩個參數，第一個參數是這個函式所要使用的this的值，因為在這裡不爭this所以傳入null也是可以的；第二個參數是將相依的模組（與𨦋公開API）都傳進去，讓這個模能夠使用其他模組的公開API。</li>
</ul>
</li>
<li>get會依照輸入的模組名稱以物件形式取得其公開的API，之後就可以指定給特定變數，然後利用這個變數使用存取屬性的方式呼叫這些API。</li>
</ul>
<p>以下是示範如何定義模組…關於模組foo與bar，就依照以上規格分別定義之，即可使用這樣的模組依存性載入器管理多個模組了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar 沒有需要任何其他的模組…</span></span><br><span class="line"><span class="title class_">MyModules</span>.<span class="title function_">define</span>(<span class="string">&#x27;bar&#x27;</span>, [], <span class="keyword">function</span> <span class="title function_">barImpl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">who</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Let me introduce: &#x27;</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">world</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">hello</span>: hello</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 需要 bar 模組…</span></span><br><span class="line"><span class="title class_">MyModules</span>.<span class="title function_">define</span>(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;bar&#x27;</span>], <span class="keyword">function</span> <span class="title function_">fooImpl</span>(<span class="params">bar</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">&#x27;hippo&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">awesome</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">hello</span>(hungry).<span class="title function_">toUpperCase</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">awesome</span>: awesome</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title class_">MyModules</span>.<span class="title function_">get</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">MyModules</span>.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">hello</span>(<span class="string">&#x27;hippo&#x27;</span>));<span class="comment">// Let me introduce: hippo</span></span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">awesome</span>();<span class="comment">//LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>

<p>這樣就可以要用什麼就指定什麼，不斛擔心順序問題了。</p>
<h4 id="ES6模組（ES6-Module）"><a href="#ES6模組（ES6-Module）" class="headerlink" title="ES6模組（ES6 Module）"></a>ES6模組（ES6 Module）</h4><p>在ES6中可將個別載入的檔案視為一個模組，每個模組都能匯入（import）其他模組或指定特定的API成員，也能匯出（export）自已公開的API成員。而瀏覽器或JavaScript引擎會經由其內建的模組載入匯入這個模組檔案。這些模組檔案的內容可視為被包覆在一個閉包內，當被另一個檔案引入和使用時即可在非原先語彙範疇定義處正常運作。</p>
<p>範例如下，在foo,js中載入bar module 的 hello，並利用於其內的awesome中，以將結果字串轉為大寫；在baz,js載救foo與 bar的完整模組，分別執行<code>bar.hello</code>與<code>foo.awesome()</code>。</p>
<p>bar.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Let me introduce: <span class="subst">$&#123;who&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> hello;</span><br></pre></td></tr></table></figure>

<p>foo.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 只會載入 bar module 的 hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hungry = <span class="string">&#x27;hippo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">awesome</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="title function_">hello</span>(hungry).<span class="title function_">toUpperCase</span>()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> awesome;</span><br></pre></td></tr></table></figure>

<p>baz.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 載入 foo 與 bar 的完整模組</span></span><br><span class="line"><span class="variable language_">module</span> foo <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">module</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  bar.<span class="title function_">hello</span>(<span class="string">&#x27;rhino&#x27;</span>)</span><br><span class="line">); <span class="comment">// Let me introduce: rhino</span></span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">awesome</span>(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>

<p>這樣就可以要用什麼就載入什麼，不用擔心同名、順序等問題。</p>
<p>注意！模組模式是以函式為基礎來實作的，因此其API是在執行時期才能被識別，所以可在執行時期修改模組內的私有變數和函俞； 而ES6的模組是靜態的，意即在編譯時期而非執行時期被識別，因此可在編譯時檢查API是否存在而丟出錯誤訊息，並且無法在執行時修改模組內的私有變數和函式。</p>
<h4 id="回顧-7"><a href="#回顧-7" class="headerlink" title="回顧"></a>回顧</h4><p>看完文章，我們到底有什麼收獲呢？藉由本文可以理解到…</p>
<ul>
<li>閉包是函式記得並存取語彙範疇的能力，可說是指向特定範疇的參考，因此當函式是在其宣告的𣁎彙範疇之外執行時也能正常運作。</li>
<li>迴圈與閉包搭配使用時的謬誤與陷阱。</li>
<li>模組模式可經由建立一個模組實體來調用內層函式，而內層函式由於具有閉包的特性，因此可存取外層的變數和函式。透過模組模式，可隱藏私密資訊。並選擇對外公開的API。</li>
<li>利用模組依存性載入器或管理器或ES6模組來管理模組。</li>
</ul>
<h5 id="References-6"><a href="#References-6" class="headerlink" title="References"></a>References</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch5.md">You Don’t Know JS: Scope &amp; Closures, Chapter 5: Scope Closure</a></li>
</ul>
<h3 id="你㯵JavaScript嗎？This"><a href="#你㯵JavaScript嗎？This" class="headerlink" title="你㯵JavaScript嗎？This"></a>你㯵JavaScript嗎？This</h3><p>本文主要會談到</p>
<ul>
<li>this是什麼？判斷this的值的四個規則與例外。</li>
<li>語彙的this，這裡會箭頭函數中的this的不同之處。</li>
</ul>
<h4 id="this是什麼？"><a href="#this是什麼？" class="headerlink" title="this是什麼？"></a>this是什麼？</h4><p>this是函式執行時所屬的物件，其值是在執行時期做綁定，可大致歸納為四個規則以供判斷。</p>
<h4 id="判斷this的四固規則"><a href="#判斷this的四固規則" class="headerlink" title="判斷this的四固規則"></a>判斷this的四固規則</h4><p>this的值可用四種規則判斷：預設綁定、隱含綁定、明確綁定和new綁定，以下分別述之。</p>
<h5 id="預設綁定（Default-Binding）"><a href="#預設綁定（Default-Binding）" class="headerlink" title="預設綁定（Default Binding）"></a>預設綁定（Default Binding）</h5><p>當其他規則都不適用時，意即不屬於任何物件的方法、沒有使用bind、call、apply或new，就套用預設綁定。此時this的值就是預設值全域物件，在瀏覽器環境底下是windows。</p>
<p>範例如下，sayHello不是某個物件的方法，也沒有使用bind、call、apply或new，因此this的值即winodw。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHello</span>();<span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>再看下面一個例子…在函式sayHello內嘗試印出<code>this.hello</code>，由於此時this的值是window，因此等同於查找<code>window.hello</code>的值，就會找到全域範疇所定義的hello了，最後就會印出「Hello World」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">hello</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hello = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="title function_">sayHello</span>();<span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>注意，若在函式內使用<code>&#39;use strict&#39;</code>宣告成嚴格模式，則this的值會改為undefined, 而非原本預設的全域物件window。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="嚴格模式（Strict-Mode）"><a href="#嚴格模式（Strict-Mode）" class="headerlink" title="嚴格模式（Strict Mode）"></a>嚴格模式（Strict Mode）</h4><p>在上一個例子中，我們看到了由於在函式內使用<code>&#39;use strict&#39;</code>宣告成嚴格模式，this的值變成undefined，而非原本預設的全域物件window，那麼，什麼是「嚴格模式」呢？</p>
<p>嚴格模式簡單說就是為了預防開發者的一些不小心或錯誤的行為，JavaScript引擎協助做了一些檢測的工作，當開發都誤用時就把錯誤丟出來，可參考-<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode">MDN</a>。</p>
<p>範例如下，在未宣告變數而賦值的狀況下，會無預警的產生一個全域變粓，但若使用嚴格模式（<code>user strict</code>）則會禁止這行為外， 還會報鏌，告知開發都變數尚未被定義。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;user strict&#x27;;</span><br><span class="line">a = 1;// Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>

<h4 id="隱含綁定（Implicit-Binding）"><a href="#隱含綁定（Implicit-Binding）" class="headerlink" title="隱含綁定（Implicit Binding）"></a>隱含綁定（Implicit Binding）</h4><p>當函式為物件的方法（method）時，在執行階段this就會被綁定至該物件。</p>
<p>範例如下，函式prompt為物件user方法，在執行階段this被綁至user，因此console時會到user查找其屬性name。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: prompt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prompt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">user.<span class="title function_">sayHi</span>();<span class="comment">// &#x27;Jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意，只有最頂層（或說是最終層）的物件才是有用的。如下，prompt的this是最終層的物件anotherUser。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anotherUser = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Not Jack!&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: prompt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">anotherUser</span>: anotherUser</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prompt</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">user.<span class="property">anotherUser</span>.<span class="title function_">sayHi</span>();<span class="comment">// &#x27;Not Jacke!&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="隱含的物去（implicitly-Lost）"><a href="#隱含的物去（implicitly-Lost）" class="headerlink" title="隱含的物去（implicitly Lost）"></a>隱含的物去（implicitly Lost）</h4><p>隱含綁定也同時會有「隱含失去」的問題-隱含失去是指函式失去綁定的物件，退回到預設綁定的狀態，意即this是全域物件windows或嚴格模式下的undefined。</p>
<p>什麼時候會造成隱含的失法呢？</p>
<ul>
<li>函式只是另一個函式的參考</li>
<li>參數傳遞中的callback</li>
<li>DOM element的事件綁定（event binding）</li>
</ul>
<p>Case1：函式是另一個函式的參考</p>
<p>範例如下，bar是<code>obj.foo</code>的參考，並且bar的呼叫地點是在𠔃域範疇，因此會套用預設綁定的規則。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>;</span><br><span class="line"><span class="title function_">bar</span>();<span class="comment">// &#x27;oops, global&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Case 2：參數傳遞中的callback</p>
<p>範例如下，<code>doFoo(fn)</code>的fn依舊是<code>obj.foo</code>的參考，並且fn的呼叫地點是在全域範疇，因此會套用預設綁定的規則。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>);<span class="comment">// &#x27;oops, global&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Case3：DOM delement的事件綁定</p>
<p>範例如下，事件中的callback的this是觸發事件的元素（DOM element）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>點擊按鈕「Click Me!」後，console出目前this的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &quot;&lt;button id=&#x27;button&#x27;&gt;Click Me!&lt;/button&gt;&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>關於解法…雖然說this有可能會無預警的失去了原先預期綁定的this的值，但我們還是可以經由一些方法強制綁定，例如使用call、apply、bind，明確指出要綁定給this的物件，又或者，可使用軟綁定當this退化為全域物件時就給以預設值。</p>
<h4 id="明確綁定（Explicit-Binding）"><a href="#明確綁定（Explicit-Binding）" class="headerlink" title="明確綁定（Explicit Binding）"></a>明確綁定（Explicit Binding）</h4><p>使用 call、apply、bind，明確指出要綁定給this的物件。</p>
<h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><p>將第一個參數設定為函式內的context，意即設定第一個參數為函式內this的值。與apply的差異只在於傳參數的方法-call將參數一一傳入，而apply將參數使用陣列傳入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Hello Kitty&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Snoopy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My number is &#x27;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line">sayHi.<span class="title function_">call</span>(cat, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">sayHi.<span class="title function_">call</span>(dog, <span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>結果如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello, I am Hello Kitty&quot;</span></span><br><span class="line"><span class="string">&quot;My number is 1&quot;</span></span><br><span class="line"><span class="string">&quot;Hello, I am Snoopy&quot;</span></span><br><span class="line"><span class="string">&quot;My number is 2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Hello Kitty&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Snoopy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My number is &#x27;</span> + args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">sayHi.<span class="title function_">apply</span>(cat, [<span class="string">&#x27;1&#x27;</span>]);</span><br><span class="line">sayHi.<span class="title function_">apply</span>(dog, [<span class="string">&#x27;2&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>結果如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello, I am Hello Kitty&quot;</span></span><br><span class="line"><span class="string">&quot;My number is 1&quot;</span></span><br><span class="line"><span class="string">&quot;Hello, I am Snoopy&quot;</span></span><br><span class="line"><span class="string">&quot;My number is 2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p>在執行函式前，綁定要指定的物件，這樣this就會是這個物件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Hello Kitty&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Snoopy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">ags</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHi.<span class="title function_">bind</span>(cat)();</span><br><span class="line">sayHi.<span class="title function_">bind</span>(dog)();</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;Hi!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">msg</span>);</span><br><span class="line">&#125;.<span class="title function_">bind</span>(obj), <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>硬綁定（Hard Binding）</p>
<p>硬綁定是指使用bind寫死要綁定的物件，可避免函式呼叫時退回到預設綁定，</p>
<p>如下，這裡有一個簡單的綁定this的helper，用來寫死要綁定的物件obj。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//簡易的綁定 this 的 helper</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">fn, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">bind</span>(foo, obj);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>);<span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>在<code>bind(foo,obj)</code>中，將foo的this強制指定為obj，並將結果指定給bar, 因此當執行<code>bar(3)</code>時，<code>this.a</code>對obj查找屬性a（找到為2，並非退回到全域範疇）且加上傳入的數字3，而得到結果b為5</p>
<p>call、apply、bind適用情境與方法， 整理如下。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">bind</th>
<th align="center">call</th>
<th align="center">apply</th>
</tr>
</thead>
<tbody><tr>
<td align="center">適用狀況</td>
<td align="center">函數在執𢓝前先綁定物件做為context</td>
<td align="center">context較常變動的埸景。依照呼叫時的需要帶不同的物件作為該function的this。在呼叫的當下就立即執行。</td>
<td align="center">與call相同</td>
</tr>
<tr>
<td align="center">傳參數的方式</td>
<td align="center">代入指定的物件做為context</td>
<td align="center">參數需要一個一個指定func.call(context,arg1,arg2,…)</td>
<td align="center">參數使用陣列傳入func.apple(context,[arg1,arge,…])</td>
</tr>
</tbody></table>
<p>API呼叫的情境（API Call “Contexts”）</p>
<p>許多函式庫的函式都會提供一個參數作為綁定的物件，這個參數通常稱為情境參數（context argument），目的是讓開發都不必再使用bind來綁定this的值。</p>
<p>如下，forEach傳入兩個參數，分別是要執行callback foo和情境參數obj，因此<code>console.log</code>中的this就是obj。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;awesome&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(foo, obj); <span class="comment">// 1 awesome  2 awesome  3 awesome</span></span><br></pre></td></tr></table></figure>

<h5 id="new綁定（new-Binding）"><a href="#new綁定（new-Binding）" class="headerlink" title="new綁定（new Binding）"></a>new綁定（new Binding）</h5><p>this會指向new出來的物件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi,I am &#x27;</span> + name);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === kitten);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> kitten = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Pusheen&#x27;</span>);<span class="comment">// &quot;Hi, I am Pusheen&quot;</span></span><br><span class="line">kitten.<span class="title function_">sayHi</span>();<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>如何利用以上的規則決定this的值呢？規則套用的優先順序，由高至低排列如下</p>
<ul>
<li>new 綁定</li>
<li>明確綁定</li>
<li>隱含綁定</li>
<li>預設綁定</li>
</ul>
<h4 id="綁定的例外"><a href="#綁定的例外" class="headerlink" title="綁定的例外"></a>綁定的例外</h4><p>雖然以上四個規則看起來很全面、很詳細，但有規則就有例外。</p>
<h5 id="忽略this"><a href="#忽略this" class="headerlink" title="忽略this"></a>忽略this</h5><p>若在使用apply、call、bind這些確綁定時，傳入null或undefined作為綁定的物件，則this的值會退回到預設綁定的全域物件window。若不在意this到底是什麼，只是要一個佔位值，那麼null看起來就是合理的選擇。</p>
<p>如下，可能只是想要攤開一個陣列，或利用bind能夠carry參數的特性分次傳入參數。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]);<span class="comment">//a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>);<span class="comment">//a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<p>備註：關於攤開陣𦕁以作為參數的方法，可使用ES6的擴展運算子（spread operator），例如<code>foo(...[1, 2])</code>其效果等同於<code>foo.apply(null,[1,2])</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(...[<span class="number">1</span>, <span class="number">2</span>]);<span class="comment">// a: 1, b: 2</span></span><br></pre></td></tr></table></figure>

<p>注意，傳入null可能會造成一些難解的bug。因此，比起null，傳入「空物件」-一個完全空的、無委派的物件作為this的值是更安全的作法，這樣至少將影響範圍限級制在這個空物件上，而不影響全域物件window，就能避免一些難以察覺和修正的錯誤。</p>
<p>在這裡使用<code>Object.create(null)</code>來建立空物件。比起<code>&#123; &#125;</code>來說，<code>Object.create(null)</code>不會與<code>Object.prototype</code>有委派關系，所以比<code>&#123;&#125;</code>來得更空，稍後會有詳細的篇章來說明原型與行為委派。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ø = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 建立空物件！</span></span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">apply</span>(ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(ø, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<h5 id="間接參考（Indirect-Reference）"><a href="#間接參考（Indirect-Reference）" class="headerlink" title="間接參考（Indirect Reference）"></a>間接參考（Indirect Reference）</h5><p>經由「指定」會產生間接參考，而當函式建立山間接參考時就會套用預設綁定。</p>
<p>例如，<code>p.foo = o.foo</code>這個指定運算式產生了間接參考，於是套用預設綁定後，this的值為window。對照前面提到的四種規則，前三種規則都不符合，當然就只能套用預設綁定了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.<span class="title function_">foo</span>();<span class="comment">// 3</span></span><br><span class="line">(p.<span class="property">foo</span> = o.<span class="property">foo</span>)();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h5 id="軟綁定（Soft-Binding）"><a href="#軟綁定（Soft-Binding）" class="headerlink" title="軟綁定（Soft Binding）"></a>軟綁定（Soft Binding）</h5><p>當this退化成全域物件時，是否可給定預設值？</p>
<p>硬綁定可避免函式呼叫時不小心退回到預設綁定狀態，但也減低了設定this的值的彈性。因此，這裡提出一個解法，讓函式能經由隱含綁定或明確綁定的方式設定this的值，而當this退化成全域物件時，又能給予一個預設值而非全域物件，這種不寫死而動態設定預設值的方式，稱之為「軟綁定」。</p>
<p>建立一個工具來達到軟綁定的目的- 若this是global、window或undefined就給予預設值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">    <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="variable language_">this</span>,</span><br><span class="line">            curried = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">            bound = <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">                    <span class="comment">/** </span></span><br><span class="line"><span class="comment">                    這裡判斷三種狀況…</span></span><br><span class="line"><span class="comment">                      - this 沒有值嗎？例如：undefined</span></span><br><span class="line"><span class="comment">                      - this 的值是 window 嗎？</span></span><br><span class="line"><span class="comment">                      - this 的值是 global 嗎？</span></span><br><span class="line"><span class="comment">                      任一狀況為 true 的話，則就回傳預設要綁定為 this 物件，也就是 obj</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    (!<span class="variable language_">this</span> ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">this</span> === <span class="variable language_">window</span>) ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">this</span> === <span class="variable language_">global</span>)</span><br><span class="line">                    ) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">                    curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>)</span><br><span class="line">                );</span><br><span class="line">            &#125;;</span><br><span class="line">        bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Function.prototype掛一個方法softBind，這個方法輸入一個物件作為當函式呼叫時不小心退回到預設綁定狀態時的預設綁定物件，輸出是回傳一個函式，之後會依照這個函式 當時執行情況的this值來決定是否已退回到全域物件而去綁定預設傳入的物件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">    <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="variable language_">this</span>,</span><br><span class="line">            curried = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">            bound = <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">                    <span class="comment">/** </span></span><br><span class="line"><span class="comment">                    這裡判斷三種狀況…</span></span><br><span class="line"><span class="comment">                      - this 沒有值嗎？例如：undefined</span></span><br><span class="line"><span class="comment">                      - this 的值是 window 嗎？</span></span><br><span class="line"><span class="comment">                      - this 的值是 global 嗎？</span></span><br><span class="line"><span class="comment">                      任一狀況為 true 的話，則就回傳預設要綁定為 this 物件，也就是 obj</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    (!<span class="variable language_">this</span> ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">this</span> === <span class="variable language_">window</span>) ||</span><br><span class="line">                        (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">this</span> === <span class="variable language_">global</span>)</span><br><span class="line">                    ) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">                    curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>)</span><br><span class="line">                );</span><br><span class="line">            &#125;;</span><br><span class="line">        bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.<span class="title function_">softBind</span>(obj);</span><br><span class="line"><span class="title function_">fooOBJ</span>();<span class="comment">// (1) name: obj &lt;---- 退回到 obj</span></span><br><span class="line">obj2.<span class="property">foo</span> = foo.<span class="title function_">softBind</span>(obj);</span><br><span class="line">obj2.<span class="title function_">foo</span>();<span class="comment">// (2) name:obj2</span></span><br><span class="line">fooOBJ.<span class="title function_">call</span>(obj3);<span class="comment">//(3) name:obj3</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.<span class="property">foo</span>, <span class="number">10</span>);<span class="comment">//(4) name:obj &lt;---- 退回到 obj</span></span><br></pre></td></tr></table></figure>

<p>說明</p>
<ul>
<li>（1）<code>fooOBJ()</code>的this是window，因此是退回到預設的綁定狀態，在此套用軟綁定工具幫我們設定的this的預設值obj。</li>
<li>（2）<code>obj2.foo()</code>的this是obj2，因此印出「name:obj2」。</li>
<li>（3）<code>fooOBJ.call(obj3)</code>使用call明確綁定this的值為obj3，因此印出「name:obj3」。</li>
<li>（4）<code>setTimeout(obj2.foo, 10)</code>中的<code>obj2.foo</code>由於參數傳遞中的callback會讓函式失去綁定的物件，因此this是window而退回到預設定綁定狀態，在此套用軟綁定工具幫我們設定的this的預設值obj。</li>
</ul>
<h4 id="語彙的this（Lexical-this）"><a href="#語彙的this（Lexical-this）" class="headerlink" title="語彙的this（Lexical this）"></a>語彙的this（Lexical this）</h4><p>所謂的「語彙的this」是指this的值不適用於以上提到的四重種規則來做判斷，而是回歸到語彙範疇的查找，其this的值並非源自執行時的綁定，而是定義時包含它的範疇或全域範疇，是無法被覆寫的，這裡即將要提偌的用箭頭函式（arrow function）來綁定this的值就是這樣的狀況。</p>
<p>這裡先放一個例子，待稍後解釋。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayHi</span>(); <span class="comment">// Hi, I am Jack</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">sayHi</span>, <span class="number">1000</span>); <span class="comment">// Hi, I am Apple</span></span><br></pre></td></tr></table></figure>

<p>其中，我們可以看到<code>obj.sayHo()</code>印出預期的「Hi,I am Jack」，但<code>setTimeout(obj.sayHi, 1000);</code>卻因為前面提過的隱含的失去中的函式是另一個函式的參考而失去了原先this的綁定。</p>
<p>先來談一些常用的改變this的方法</p>
<ul>
<li>透過變數儲存目前this的值。</li>
<li>使用bind、call或apply，綁定特定的物件作為this的值。</li>
</ul>
<p>透過變數儲存目前this的值…這其實不算是「改變」，只能說是「保留」。如果希望存到外部的this，可用一個變數<code>_this</code>儲存起，稍後再用。</p>
<p>修改上例如下，一秒後確是印出「Hi,I am Jack」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;_this.name&#125;</span>`</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>當然我們也可以用bind、call或apply來綁定特定的物件作為this的值。關於bind、call或apply的範例可參考之前提過的[明確綁定](# 明確綁定（Explicit Binding）)的部份。</p>
<p>修改上例如下，一秒後的確是印出「Hi,I am Jack」。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>();<span class="comment">// Hi, I am Jack</span></span><br></pre></td></tr></table></figure>

<p>即然箭頭函數會自動綁定所在範疇，那也就可以這麼修改了…經由箭頭函數就會把this綁在obj上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>();<span class="comment">// Hi, I am Jack</span></span><br></pre></td></tr></table></figure>

<p>但箭頭並不是一個所有狀況都適用的超級為敵通用解…</p>
<p>箭頭函數不適用於…</p>
<ul>
<li>䈟頭函數會將this強制綁定為執行環境。因此，若不希望this被綁定為執行環境，基本上都是不適用的，不需要為了少寫幾個字而硬要使用箭頭函數。</li>
<li>箭頭函數內的callback是匿名的，匿名函式的缺點請看[這裡](# 匿名 vs 具名（Anonymous vs Named）)。</li>
</ul>
<h4 id="回顧-8"><a href="#回顧-8" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>this是function執行所屬的物件，this是在執行時期做綁定其值和函式在哪裡被呼叫有關。</li>
<li>判斷this的值的四個規則，並以匹配的優先順序由高至低排列<ul>
<li>new 綁定：this會指向new出來的物件。</li>
<li>明確綁定：使用call、apply、bind，明確指出要綁定給this的物件。</li>
<li>隱含綁定：當函式為物件的方法時，在執行階段this就會被綁定至該物件。</li>
<li>預設綁定： 當以上規則都不適用時，就套用預設綁定，在非嚴格模式下，瀏覽器環境this的值是預設全域物件window，而在嚴格模式下，this的值是undefined</li>
</ul>
</li>
<li>箭頭函數（arrow function）的this的值並不適用上面提到的四種規則，this強制綁定為執行環境，例如在瀏覽器中就是windwo。</li>
</ul>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch1.md">You Don’t Know JS: this &amp; Object Prototypes, Chapter 1: this Or That?</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch2.md">You Don’t Know JS: this &amp; Object Prototypes, Chapter 2: this All Makes Sense Now!</a></li>
<li><a href="http://javascript.info/object-methods#four-scents-of-this">Object methods, “this”</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/apC.md">You Don’t Know JS: Scope &amp; Closures, Appendix C: Lexical-this</a></li>
</ul>
<h4 id="推薦閱讀"><a href="#推薦閱讀" class="headerlink" title="推薦閱讀"></a>推薦閱讀</h4><p>推薦閱讀 Kuro 大大關於 this 的好文…</p>
<ul>
<li>[What’s THIS in JavaScript ? <a href="https://kuro.tw/posts/2017/10/12/What-is-THIS-in-JavaScript-%E4%B8%8A/">上</a></li>
<li>[What’s THIS in JavaScript ? <a href="https://kuro.tw/posts/2017/10/17/What-s-THIS-in-JavaScript-%E4%B8%AD/">中</a></li>
<li>[What’s THIS in JavaScript ? <a href="https://kuro.tw/posts/2017/10/20/What-is-THIS-in-JavaScript-%E4%B8%8B/">下</a></li>
</ul>
<h3 id="你懂JavaScript嗎？物件（Object）"><a href="#你懂JavaScript嗎？物件（Object）" class="headerlink" title="你懂JavaScript嗎？物件（Object）"></a>你懂JavaScript嗎？物件（Object）</h3><p>關於物件，本文會提到</p>
<ul>
<li>語法：宣告式與建構形式。</li>
<li>型別：再次複習typeof、使用instanceof判定物件子型別。</li>
<li>內容：屬性值的存取、物件的複製（淺拷貝與深拷貝）、屬性描述器、不可變的物件、取值器與設值器、檢視屬性是否存在、屬性列舉。</li>
<li>迭代：一些迭代出陣列的值的方法。</li>
</ul>
<h4 id="語法（Syntax）"><a href="#語法（Syntax）" class="headerlink" title="語法（Syntax）"></a>語法（Syntax）</h4><p>建立物件有兩種方式</p>
<ul>
<li>宣告式（declarative）或稱字面值（literal），例如：<code>const obj = &#123; name: &#39;Jack&#39;&#125;;</code>。</li>
<li>建構形（constructed form），例如：<code>const obj= new Object(); obj.name = &#39;Jack&#39;;</code>，也就是原生功能，但由於一些些雷區，這種方式其實很少用。</li>
</ul>
<p>簡單來說，兩者主要的差別是新增屬性時，字面值可在物件建立時一次全部加入，但建構形式必須在物件建立後一筆一筆新增。</p>
<h4 id="型別（Type）"><a href="#型別（Type）" class="headerlink" title="型別（Type）"></a>型別（Type）</h4><p>JavaScript的資料型態有七種-字串（string）、數字（number）、布林值（boolean）、null、undefined 、物件（object）與symbol。其中函式（function）和陣列（array）、日期（date）皆為物件的一種，function是可呼叫的物件，而array是結構較嚴謹的物件。</p>
<h4 id="typeof-2"><a href="#typeof-2" class="headerlink" title="typeof"></a>typeof</h4><p>關於型別就會想到型別檢測，想到型檢測就不得不提一下typeof的議題…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;Hello World&#x27;</span>);<span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1234567</span>);<span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>());<span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;);<span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);<span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>);<span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>這裡看到幾個有趣的（奇怪的）地方</p>
<ul>
<li>null是基本型別之一，但<code>typeof null</code>卻得到object，而非null!這可說是一個bug，可是若因為修正了這個bug則可能會導致很多網站壞掉，因此就不修了！</li>
<li>雖然說function是物件的子型別，但<code>typeof function() &#123;&#125;</code>是得到function而非object，和陣𦕁依舊得到object是不一樣的。</li>
<li>NaN表示是無效的數字，但依舊還是數字，因此在資料型別的檢測<code>typeof NaN</code>結果就是number，不要被字面上的意思「不是數字」（not a number）給弄糊塗了。另外，NaN與任何數字運算都會得到NaN，並且NaN不大於、不小於也不等於任何數字，包含NaN它自已。</li>
</ul>
<p>另外，如果想知道這個物件到底是屬於哪個子型別，則可使用<code>Object.prototype.toString</code>來檢視<code>[[Class]]</code>這個內部屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));<span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; &#125;));<span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/hellowrold/i</span>));<span class="comment">//[object Regexp]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));<span class="comment">//[object Date]</span></span><br></pre></td></tr></table></figure>

<h4 id="內建物件（Built-in-Objects）"><a href="#內建物件（Built-in-Objects）" class="headerlink" title="內建物件（Built-in Objects）"></a>內建物件（Built-in Objects）</h4><p>內建物件指的是使用內建函式所建立的物件，這些物件都屬於物件子型別的一種，除了上面提到的陣列、函式與日期外，這裡列出物件所有的子型別：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error，它們的用途是給予開發者取得屬性或方法的使用，也就是我們常聽到的原生的功能。因此，當使用建構式建立字串、布林或數字等值時，建立的其實不是基本型別值而是物件，因此可用instanceof來檢查是由哪個建構式建立，也就是來判斷是否為指定的物件型別。</p>
<p>如下，使用字串字面值宣告了一個字串str，當我們使用str進行<code>.length</code>的操作以取得其長度時，JavaScript就會將這個字串基本型別的值強制轉成對應的物件子型別，也就是上面提到的String。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str <span class="keyword">instanceof</span> <span class="title class_">String</span>)<span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);<span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strObj <span class="keyword">instanceof</span> <span class="title class_">String</span>);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strObj.<span class="property">length</span>);<span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>null和undefined只有基本資料型別，沒有物件包裹形式，意即沒有對應的物件子型別，所以無法使用new來產生。</li>
<li>Date、RegExp、Error沒有基本資料型別的形式，所以只能使用物件子型別new來產生。</li>
</ul>
<h4 id="內容（Contents）"><a href="#內容（Contents）" class="headerlink" title="內容（Contents）"></a>內容（Contents）</h4><p>物件的內容是由屬性組成的，而屬性是由key-valur pair構成，value 可為任意資料型別的值，並且值是以參考（reference）的方式（存位置）儲存。</p>
<p>如何存取物件的屬性？有兩種方式</p>
<ol>
<li>特性存取（property access），意即<code>.</code></li>
<li>鍵值存取（key access），意即<code>[]</code></li>
</ol>
<p>其中，特性存取<code>.</code>必須符合<a href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier">識別字的規範</a>，簡單的說就是只能是字母、數字、<code>$</code>（錢字號）或<code>_</code>（底線），並且不能以數字開頭，之後可加上a-z、A-Z、<code>$</code>、<code>_</code>和數字0-9，可為關鍵字或保留字。</p>
<p>讓我們來看一些疑難雜症吧！</p>
<h4 id="Q1-如果屬性名稱是特殊字符或動態產生的，該怎麼存取它的值呢？"><a href="#Q1-如果屬性名稱是特殊字符或動態產生的，該怎麼存取它的值呢？" class="headerlink" title="Q1:如果屬性名稱是特殊字符或動態產生的，該怎麼存取它的值呢？"></a>Q1:如果屬性名稱是特殊字符或動態產生的，該怎麼存取它的值呢？</h4><p>若要使用一些包含特殊或動態產生的字串作為屬性名稱，就必須使用鍵值存取<code>[]</code>的方式。</p>
<p>包含特殊字符的屬性名稱</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="string">&#x27;!!12345!!&#x27;</span>: <span class="string">&#x27;Hello Wrold&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.!!<span class="number">12345</span>!!; <span class="comment">//Uncaught SyntaxError: Unexpected token !</span></span><br><span class="line">obj[<span class="string">&quot;!!12345!!&quot;</span>]<span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>ES6新增動態產生的字串作為屬性名稱功能，讓key的值可經由運算得出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prefix = <span class="string">&#x27;fresh-&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fruits = &#123;</span><br><span class="line">    [prefix + <span class="string">&#x27;apple&#x27;</span>]: <span class="number">100</span>,</span><br><span class="line">    [prefix + <span class="string">&#x27;orange&#x27;</span>]: <span class="number">60</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits[<span class="string">&#x27;fresh-apple&#x27;</span>]);<span class="comment">//100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits[<span class="string">&#x27;fresh-orange&#x27;</span>]);<span class="comment">//60</span></span><br></pre></td></tr></table></figure>

<h4 id="Q2-屬性真的只能是字串嗎？可以是數字、物件等其他型別的值嗎？"><a href="#Q2-屬性真的只能是字串嗎？可以是數字、物件等其他型別的值嗎？" class="headerlink" title="Q2:屬性真的只能是字串嗎？可以是數字、物件等其他型別的值嗎？"></a>Q2:屬性真的只能是字串嗎？可以是數字、物件等其他型別的值嗎？</h4><p>屬性名稱只能是字串，若不是𡪤串則會被強制轉為字串。</p>
<p>如下，<code>obj[obj]</code>的key值被強制轉為字串<code>&#39;[object Object]&#39;</code>，同理，<code>obj[999]</code>的key值999也被轉為字串<code>&#39;999&#39;</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="title class_">Qoo</span>: <span class="string">&#x27;有種果汁真好喝&#x27;</span> &#125;;</span><br><span class="line">obj[obj]=<span class="string">&#x27;喝的時候酷兒&#x27;</span>;</span><br><span class="line">obj[<span class="number">999</span>]=<span class="string">&#x27;喝完臉紅紅！&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;[object Object]&#x27;</span>]);<span class="comment">//喝的時候酷兒</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;999&#x27;</span>]);<span class="comment">//喝完臉紅紅！</span></span><br></pre></td></tr></table></figure>

<h4 id="函式（Function）vs方法（Method）"><a href="#函式（Function）vs方法（Method）" class="headerlink" title="函式（Function）vs方法（Method）"></a>函式（Function）vs方法（Method）</h4><p>闢謠…澄清…!!??</p>
<p>在其它語言中，屬於某個物件的函式稱為方法，但在JavaScript中，函式並不會特別屬於某個物件，物件充其量也只是儲存對某個函式的參考而已，並非真的「屬於」這個物件，因此，在JavaScript中，函式與方法是同義的，並沒有區別。除了在ES6新增的super參考，super與class一起使用時super會靜態綁定函式，經由這樣所綁定的函式就比較接近一般在其他語言所看到的方法了。</p>
<h4 id="陣列（Array）"><a href="#陣列（Array）" class="headerlink" title="陣列（Array）"></a>陣列（Array）</h4><p>陣列使用非負整數作為索引，注意…</p>
<ul>
<li><p>若使用具名特性（named property）作為索引，則不會增加陣列的長度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line">array[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">length</span>); <span class="comment">// 4</span></span><br><span class="line">array[<span class="string">&#x27;foo&#x27;</span>] = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">length</span>); <span class="comment">// 4, 陣列的長度不變！</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>具名特性（named property）若以字串格式存在，就會轉為數字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">array[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);<span class="comment">//[1, 2, 3, &quot;foo&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="複製物件"><a href="#複製物件" class="headerlink" title="複製物件"></a>複製物件</h4><p>  複製物件的方式分為淺拷貝與深拷貝兩種。</p>
<p>  為什麼要探討淺拷貝與深拷貝呢？這是根本於基本型別值是傳值而物件是傳參考的緣故，既然物件是傳參考，就要考慮是把整份資料都複製一份，還是複製參考就好？淺拷貝是複製參考，深拷貝是把整份資料都複制一份，常用於考慮物件資料是否要其用的狀況。</p>
<h5 id="淺拷貝（Shallow-Copy）"><a href="#淺拷貝（Shallow-Copy）" class="headerlink" title="淺拷貝（Shallow Copy）"></a>淺拷貝（Shallow Copy）</h5><p>  除了基本的資料型中純值（非物件）的資料會真的複製另外一份值之外，其他的都只是複製一份參考而已，例如：<code>Object.assign</code>在處理超過一層的物件時就只能做偮淺拷貝，只有一層的話是可以做偌深拷貝的。</p>
<h5 id="深拷貝（Deep-Copy）"><a href="#深拷貝（Deep-Copy）" class="headerlink" title="深拷貝（Deep Copy）"></a>深拷貝（Deep Copy）</h5><p>  複製整個物件，通常會使用JSON-safe的物件，先經由序列化為JSON字串後再剖析回物件。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(oldobj));</span><br></pre></td></tr></table></figure>

<p>  範例如下。</p>
<p>  單層物件時，<code>Object.assign</code>與「先序列化再剖析」的方法都可以做完全的拷貝。也就是深拷貝，由於物件的比對的是比較儲存位置，因此當比較拷貝結果特，兩者是不相等的。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> simpleObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newSimpleObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, simpleObj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newSimpleObj === simpleObj);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSimpleObj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newSimpleObj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newSimpleObj2 === simpleObj);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>  那麼，物件再多層的狀況下，又是怎樣的狀況呢？如下，由於<code>Object.assign</code>只能做單層的拷貝，因此第二層開始就只是複製參考而已，儲存位置不變，故為true；而「先序列化再剖析」的方法則是完整地把整個資料複製起來，存到另一個地方，因此儲存位置不同，得到false。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">d</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj.<span class="property">b</span> === obj.<span class="property">b</span>);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(newObj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj2.<span class="property">b</span> === obj.<span class="property">b</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="屬性描述器（Property-Descriptor）"><a href="#屬性描述器（Property-Descriptor）" class="headerlink" title="屬性描述器（Property Descriptor）"></a>屬性描述器（Property Descriptor）</h4><p>  屬性描述器可用來檢視屬性的特徵，例如：可入寫入（writable）、可否配置（configurable）與可否列舉（enumerable）。</p>
<p>  例如，檢視object.a這個屬性的特徵。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>  得到結果。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>, </span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>  使用defineProperty定義物件的屬性與特性。通常使用這種方法的目的是…</p>
<ul>
<li>新增屬性，通常是為了修改預設特徵的值。</li>
<li>若特性是configurable的話。則可用來修改屬性的特徵值。</li>
</ul>
<p>  範例如下，為物件obj定義一個新的屬性name，並設定其特徵值。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// Apple</span></span><br></pre></td></tr></table></figure>

<h5 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h5><p>屬性的值是否「可被寫入」。</p>
<p>例如，設定name這個屬性是不可寫入的，因此當嘗試更新這個值的時候，發現無法更新，並且在strict mode之下會丟出TypeError的錯誤訊息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//不可寫入！</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// Apple</span></span><br><span class="line">obj.<span class="property">name</span>=<span class="string">&#x27;Grape&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// Apple，屬性name的值無法被變更</span></span><br></pre></td></tr></table></figure>

<h5 id="Configurable"><a href="#Configurable" class="headerlink" title="Configurable"></a>Configurable</h5><p>屬性是否是「可配置的」，意即當configurable為false的時候，為法再使用defineProperty更新特徵的值，否則會丟出TypeError，但有一個例外，當configurable為false的時候，writable仍可由true改為false，但不能從false改為true。</p>
<p>當configurable為false的時候，無法再使用defineProperty更新特徵的值，否則會丟出TypeError。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,<span class="comment">// false -&gt; true</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: name</span></span><br></pre></td></tr></table></figure>

<p>當configurable無false的時候，writable仍可由true改為false，但不能從false改為true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,<span class="comment">//</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 這是可行的</span></span><br></pre></td></tr></table></figure>

<p>當configurable為false的時候，writable仍可由true改為false，但不能從false改為true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,<span class="comment">//</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: name</span></span><br></pre></td></tr></table></figure>

<p>除了是否可更新特徵的設定外，configurable另一個作用就是是否可被delete刪除該屬性。</p>
<p>configurable設為false，屬性不可刪除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,<span class="comment">//</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// Apple，name屬性未被刪除</span></span><br></pre></td></tr></table></figure>

<p>configurable設為true，屬性可被刪除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h5><p>特徵是否為「可列舉的」，例如：此物件的特性是否可在for…in中被列舉，若設定enumerable為false表示不會被列舉出來。</p>
<p>如下（1）印出hello和name，（2）由於name被設定為不可列舉的，因此只會印出hello。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">hello</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop);<span class="comment">//（1）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop);<span class="comment">//（2）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<p>題外話，會用到 defineProperty 這個東西是為了寫雙向綁定的小工具而追 Vue.js 的原始碼的時候玩到的，推薦閱讀<a href="https://github.com/DMQ/mvvm">這篇</a>文章。</p>
<h4 id="不可變性（Immutability）"><a href="#不可變性（Immutability）" class="headerlink" title="不可變性（Immutability）"></a>不可變性（Immutability）</h4><p>如何實作無法被變更的特性或物件？以下會介紹幾種作法，但都只能做到淺層的不可變性（shallow immutablility），意即若此物件有指向其他物件的參考，這個被指到的物件的內容就仍是可變的。</p>
<p>如下，假設foo是不可變的，但foo.list指向一個陣列，這個陣列的內容是可變的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.<span class="property">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">foo.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">list</span>);<span class="comment">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="物件常數（Object-Constant）"><a href="#物件常數（Object-Constant）" class="headerlink" title="物件常數（Object Constant）"></a>物件常數（Object Constant）</h4><p>使用defineProperty設定writable為false且configurable為false，即可建立一個特性等同於常數的物件屬性，無法被更新、重新定義和刪除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;CONST_PI&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">CONST_PI</span>);<span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<h4 id="避免擴充（Prevent-Extensions）"><a href="#避免擴充（Prevent-Extensions）" class="headerlink" title="避免擴充（Prevent Extensions）"></a>避免擴充（Prevent Extensions）</h4><p>使用<code>Object.preventExtensions</code>防止物件被加入新屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line">obj.<span class="property">hello</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">hello</span>);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>備註，在嚴格模式下，加入新屬性會丟出TypeError。</p>
<h4 id="密封（Seal）"><a href="#密封（Seal）" class="headerlink" title="密封（Seal）"></a>密封（Seal）</h4><p>使用<code>Objet.seal</code>來達到密封的作用，意即物件不可再新增屬性、重新配置特徵或刪除屬性，但可能可以修改屬性值。</p>
<p><code>Object.seal</code>會做兩件事</p>
<ul>
<li><p>將物件設定為<code>Object.preventExtensions</code>防止物件被加入新屬性。</p>
</li>
<li><p>將物件的屬性特性configurable設定為fals，物件的屬性不能被刪除，其特徵的值不能被更新。屬性值是否可被更新要看writable的值而定，若writable為true則可更新，若為false則不可更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj);</span><br><span class="line"><span class="comment">//嘗試加入新的屬性 hello</span></span><br><span class="line">obj.<span class="property">hello</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">hello</span>);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//嘗試刪除屬性name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">delete</span> obj.<span class="property">name</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//Jack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//嘗試重新設定特徵值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="凍結（Freeze）"><a href="#凍結（Freeze）" class="headerlink" title="凍結（Freeze）"></a>凍結（Freeze）</h4><p>使用<code>Object.freeze</code>建立一個已凍結的物件，意即這個物件不能新增屬性、更新屬性的值，刪除屬性和重新配置特徵值。</p>
<p><code>Object.freeze</code>會做以下的事情</p>
<ul>
<li>對物件呼叫<code>Object.seal</code>，讓物件不可再新增屬性、重新配置特徵或刪除屬性。</li>
<li>將物件的屬性時性writable設定為false，物件屬性的值不可被更改。</li>
</ul>
<p>回顧前面提到的，以上四種解法都只能做到淺層的不可變性（shallow immutability），因此若希望能將整個物件（包含屬性參考的物件）都凍結，可遞迴呼叫<code>Object.freeze</code>，但可能有副作用，像是凍結了共用的物件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">favFruits</span>: list,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> anotherObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">    <span class="attr">favFruits</span>: list,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj.<span class="property">favFruits</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//共用的物件被凍結！</span></span><br><span class="line">list.<span class="title function_">push</span>(<span class="string">&#x27;orange&#x27;</span>);<span class="comment">//Uncaught TypeError: Cannot add property 2, object is not extensible</span></span><br></pre></td></tr></table></figure>

<h4 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a><code>[[Get]]</code></h4><p><code>[[Get]]</code>的功用是取得屬性值，例如：<code>obj.a</code>時會呼叫<code>[[Get]]()</code>這個函式呼叫，它會先在此物件內尋找是否有符合名稱的屬性，若無就順著原型串鏈繼續尋找，如果都沒有找偌，<code>[[Get]]</code>就會回傳undefined。注意，這和之前提到的在語彙範疇中查找變數（的名稱是否被定義）是不同的，若在語彙範疇中找到該變數，會丟出ReferrenceError。</p>
<h4 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a><code>[[Put]]</code></h4><p><code>[[Put]]</code>的功用是…</p>
<p>若此屬性不存在，則新增此屬性並設定其值。但若此屬性存在，則做以下的事情…</p>
<ul>
<li><p>若此屬性是存取器描述器的取值器與設值器嗎？若是，則呼叫其設值器（setter）。</p>
</li>
<li><p>若此屬性是不可寫入的，在非嚴格模式下會無聲的失敗，但在嚴格模式下會丟出TypeError。</p>
</li>
<li><p>若屬性是可寫入的，就將值設定給這個屬性。</p>
<p>備註：上面提到的兩個名詞，這裡來做解釋…</p>
</li>
<li><p>資料描述器（data descriptor）：定義一個屬性時，此屬性不含取值器或設值器。</p>
</li>
<li><p>存取描述器（access descriptor）:存取器描述器是指當定義一個屬性時，若此屬性擁有取值器或設值器，這個定義就會成為存取器描述器。注意，此時屬性的value和特徵writable都會被忽略，而只需考慮set、get、configurable和enumerable。</p>
</li>
</ul>
<h4 id="取值器-Getter-與設值器（Setter）"><a href="#取值器-Getter-與設值器（Setter）" class="headerlink" title="取值器(Getter)與設值器（Setter）"></a>取值器(Getter)與設值器（Setter）</h4><p>物件預設的<code>[[Get]]</code>與<code>[[Put]]</code>掌控了屬性的建立、設定和更新、取得值的方式。若要複寫這兩種預設<code>[[Get]]</code>與<code>[[Put]]</code>行為，可透過取值器與設值器來達成。</p>
<p>方法一，使用物件字面值的方式定義屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name_</span> = <span class="string">`Hi, I am <span class="subst">$&#123;val&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//Hi, I am Jack</span></span><br></pre></td></tr></table></figure>

<p>方法二，使用defineProperty的方式定義屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name_</span> = <span class="string">`Hi, I am <span class="subst">$&#123;val&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//Hi, I am Jack</span></span><br></pre></td></tr></table></figure>

<h4 id="存在（Existence）"><a href="#存在（Existence）" class="headerlink" title="存在（Existence）"></a>存在（Existence）</h4><p>既然屬性不存在的時候，會回傳undefined，但若屬性值原本就設定為undefined是不是就為法判定這個屬性到底存不存在了？</p>
<p>解法是使用hasOwnProperty，若想進一進確認該屬性是否可在其他物件中找偌，可搭配<code>prop in obj</code>檢查這個屬性是否存在於原型串鏈中。兩者差異是<code>prop in obj</code>會檢查原型串鏈，而hasOwnProperty只會檢查該物件。</p>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">job</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);<span class="comment">// 邁立 obj 與 obj1的連結</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>屬性name其值雖然為undefined，但它直的存在於obj。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>屬性job真的存在於obj嗎？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">job</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;job&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> obj);<span class="comment">// true,但在原型串鏈中可找到</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;job&#x27;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>屬性job其值雖然為undefined且不存在於obj中，但可在原型串鏈中可找偌，因此進一𦂇檢視obj1，確定為obj1的屬性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">hello</span>);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;hello&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> obj);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>雖然hello的值是undefined，似乎與前面的例子無異，但使用hadOwnProperty檢視，發現在在obj物件中，且經由<code>prop in obj</code>確認後發現也無法在原型串鏈中找到，因此屬性不存在。</p>
<p>總結…</p>
<ul>
<li>hasOwnProperty可檢測這個屬性是否存在於某個物件。</li>
<li><code>prop in obj</code>可檢查這個屬性是否可在原型串鏈中找到，讓我們能確認是否需要再往其他物件查找。</li>
</ul>
<h4 id="列舉（Enumeration）"><a href="#列舉（Enumeration）" class="headerlink" title="列舉（Enumeration）"></a>列舉（Enumeration）</h4><p>檢視屬性是否可被列舉的方法。</p>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in運算子只會帶出可列舉的屬性。</p>
<p>例如，obj有兩個屬性name和hello，其中name為可列舉的，hello為不可列舉的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k, obj[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name Jack</span></span><br></pre></td></tr></table></figure>

<h5 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a>propertyIsEnumerable</h5><p>propertyIsEnumerable檢視屬性是否可被列舉。</p>
<p>例如，obj有兩個屬性name和hello，其中name為可列舉的，hello為不可列舉的。檢視name是否為可列舉的，會回傳true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-keysvsObject-getOwnPropertyNames"><a href="#Object-keysvsObject-getOwnPropertyNames" class="headerlink" title="Object.keysvsObject.getOwnPropertyNames"></a><code>Object.keys</code>vs<code>Object.getOwnPropertyNames</code></h5><p><code>Object.keys</code>與<code>Object.getOwnPropertyNames</code>都只回傳此物件的屬性，且皆不檢視原型串鏈，兩者差異在於</p>
<ul>
<li><code>Object.keys</code>:回傳所有可列舉的屬性。</li>
<li><code>Object.getOwnPropertyNames</code>:回傳所有屬性，不管是否可被列舉。</li>
</ul>
<p>例如，obj有兩個屬性name和hello，其中name為可列舉的，hello為不可列舉的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">//[ &#x27;name&#x27; ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj));<span class="comment">//[ &#x27;name&#x27;, &#x27;hello&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="迭代（Iteration）"><a href="#迭代（Iteration）" class="headerlink" title="迭代（Iteration）"></a>迭代（Iteration）</h4><p>迭代出陣列的值的方法。</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>迭代陣列中所有的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cathy&#x27;</span>, <span class="string">&#x27;Doll&#x27;</span>];</span><br><span class="line">list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index, array);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Apple 0 [ &#x27;Apple&#x27;, &#x27;Bob&#x27;, &#x27;Cathy&#x27;, &#x27;Doll&#x27; ]</span></span><br><span class="line"><span class="comment">//Bob 1 [ &#x27;Apple&#x27;, &#x27;Bob&#x27;, &#x27;Cathy&#x27;, &#x27;Doll&#x27; ] </span></span><br><span class="line"><span class="comment">//Cathy 2 [ &#x27;Apple&#x27;, &#x27;Bob&#x27;, &#x27;Cathy&#x27;, &#x27;Doll&#x27; ] </span></span><br><span class="line"><span class="comment">//Doll 3 [ &#x27;Apple&#x27;, &#x27;Bob&#x27;, &#x27;Cathy&#x27;, &#x27;Doll&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>檢查陣列中的每個值是否符條件，若是則回傳true。持續進行直到結束，或callback中回傳false就停止迭代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">20</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;corn&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;grape&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">50</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;pieapple&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">80</span>,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = list.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index, array);</span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">cout</span> &gt; <span class="number">50</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;apple&#x27;, count: 20 &#125; 0 [ &#123; name: &#x27;apple&#x27;, count: 20 &#125;,   &#123; name: &#x27;corn&#x27;, count: 100 &#125;,   &#123; name: &#x27;grape&#x27;, count: 50 &#125;,   &#123; name: &#x27;pieapple&#x27;, count: 80 &#125; ]</span></span><br><span class="line"><span class="comment">//result: false</span></span><br></pre></td></tr></table></figure>

<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>檢查陣列中的是否有值符合條件，若是則回傳true。持續進行直到結束，或callback中回傳true就停止迭代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">20</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;corn&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;grape&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">50</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;pieapple&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">80</span>,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = list.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index, array);</span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">count</span> &gt; <span class="number">50</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//&#123; name: &#x27;apple&#x27;, count: 20 &#125; 0</span></span><br><span class="line"><span class="comment">//&#123; name: &#x27;corn&#x27;, count: 100 &#125; 1</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>若想看更多陣列處理方法，可參考<a href="https://wcc723.github.io/javascript/2017/06/29/es6-native-array/">這裡</a></p>
<h5 id="for-of"><a href="#for-of" class="headerlink" title="for...of"></a><code>for...of</code></h5><p>使用ES6的<code>for...of</code>迭代陣列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="回顧-9"><a href="#回顧-9" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>建立物件有兩種方式-宣告式與建構形式，前都較常用，而後者有一些雷區，非必要不建議使用。</li>
<li>typeof可檢查資料型別； 當使用建構式建立字串、布林或數字等值時，建立的其實不是基本型別而是物件，因此可用instanceof來檢查是由哪個建構式建立的，也可檢視該物件是屬於哪個子型別。</li>
<li>物件的內容是由屬性組成的，而屬性是由key-value pari構成，value可為任意資料型別的值，並且值是以參考的方式儲存。</li>
<li>物件的屬性若包含特殊字符為動態產生的字串，則必須使用鍵值<code>[]</code>的方法存取。</li>
<li>複製物件的方法分為淺拷貝與深拷貝兩種，<code>Object.assign</code>只能處理一層內的深拷貝，而直正的深貝通常是由JSON-safe的物件先經由序列化為JSON字串後再剖析回物件來達成。</li>
<li>屬性描述器可用來檢視屬性的特徵，例如：是否可寫入、是否可配置、是否可列舉。</li>
<li>實作不可變的物件的方法，例如：設定屬性描述器、避免擴充、密封、凍結。</li>
<li>物件預設的<code>[[Get]]</code>與<code>[[Put]]</code>掌控了屬性的建立、設定和更新、取得值的方式，若要複寫這兩種預設<code>[[Get]]</code>與<code>[[Put]]</code>行為，可透過取值器與設值器來達成。</li>
<li>hasOwnProperty與<code>prop in obj</code>可判斷屬性是否存在。</li>
<li>判斷屬性是否可列舉的方法-in運算子帶出此物件可列舉的屬性、propertyIsEnumerable檢視屬性是否可被列舉、<code>Object.keys</code>與<code>Object.getOwnPropertyNames</code>都只回傳此物件的屬性，差異在於前都只列出可列舉的屬性，而後者會列出所有此物件的屬性。</li>
<li>迭代出陣列中的值的方法，例如：forEach、every、some、<code>for...of</code>。</li>
</ul>
<h5 id="References-7"><a href="#References-7" class="headerlink" title="References"></a>References</h5><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch3.md">You Don’t Know JS: this &amp; Object Prototypes, Chapter 3: Objects</a></p>
<h3 id="你懂JavaScript嗎？（簡易版）物件導向概念"><a href="#你懂JavaScript嗎？（簡易版）物件導向概念" class="headerlink" title="你懂JavaScript嗎？（簡易版）物件導向概念"></a>你懂JavaScript嗎？（簡易版）物件導向概念</h3><p>本文主要會談到簡單的物件導向概念，作為後續「原型」（Prototypes）的暖身。</p>
<h4 id="類別（Class）、邁構子（Constructor）、實體（Instance）"><a href="#類別（Class）、邁構子（Constructor）、實體（Instance）" class="headerlink" title="類別（Class）、邁構子（Constructor）、實體（Instance）"></a>類別（Class）、邁構子（Constructor）、實體（Instance）</h4><p>「類別」可想像成是建構某特定物體的藍圖或模具，而「實體」就是按照這藍圖或模具製造出來的成品。這當中需要使用類別的一個特殊方法「建構子」來做初始化的動作。</p>
<p>虛擬碼如下，Person是一個類別，利用與類別同名的建構子Person做初始化，進而建立出實體Jack。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span> &#123;</span><br><span class="line">    career = <span class="literal">null</span>;</span><br><span class="line">    <span class="title class_">Persion</span>(job) &#123;</span><br><span class="line">        career = job;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&#x27;Hello, I am a/n &#x27;</span>, <span class="variable language_">this</span>.<span class="property">career</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Jack</span> = <span class="keyword">new</span> <span class="title class_">Persion</span>(<span class="string">&#x27;engineer&#x27;</span>);</span><br><span class="line"><span class="title class_">Jack</span>.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>在真實的世界裡，JavaScript用什麼方式呈現呢？舉個最簡單的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);<span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>String是個類別方法，在這裡當建構子用，任何給定的字串都是這個類別的實體，它幫我們包裝了可在這個字串上執行的各種功能。因此，str是String的實體，可執行<code>str.length</code>取得字串長度。</p>
<p>不過，在JavaScript的世界中，並沒有真正的類別的概念，只能使用設計模式（design pattern）來模擬，我們在稍後的原型中會看到各種解法與優劣討論。</p>
<h4 id="繼承（Inheritance）"><a href="#繼承（Inheritance）" class="headerlink" title="繼承（Inheritance）"></a>繼承（Inheritance）</h4><p>定義一個類別，其特性繼承（也可說是擴充extend）自另外一個類別，稱它們為「父類別」與「子類別」，其中，子類別繼承父類別的特性。</p>
<p>如下，CoolPersion繼承自Person，其中sayHi繼承了來自Person的方法並做覆寫。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span> &#123;</span><br><span class="line">  career = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Persion</span>(job) &#123;</span><br><span class="line">    career = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pring</span>(<span class="string">&#x27;Hello, I am a/n&#x27;</span>, career);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoolPerson</span> inherits <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">inherited</span>: <span class="title function_">sayHi</span>();</span><br><span class="line">    <span class="title function_">pring</span>(<span class="string">&#x27;I love my job!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params">food</span>) &#123;</span><br><span class="line">    <span class="title function_">pring</span>(<span class="string">&#x27;I am eating...&#x27;</span>, food);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>「多重繼承」（multiple inheritance）是指子類別可繼承一個以上的父類別，但由於JavaScript並沒有提供原生機制來處理這重情況，因此不做討論。</p>
<h4 id="多型（Polymorphism）"><a href="#多型（Polymorphism）" class="headerlink" title="多型（Polymorphism）"></a>多型（Polymorphism）</h4><p>「多型」是指子類別除了擁有自己的方法外，這個方法還能覆寫來特化父類別的同名方法，以賦予其更特殊的行為，</p>
<p>如上，CoolPersion的sayHi與其父類別Persion的sayHi同名，它使用<code>inherited:sayHi()</code>參考它所繼承且未被覆寫的父類別同名方法並作呼叫，接著加上<code>pring(&#39;I love my job!&#39;)</code>這個屬於它自已的功能。其中，不指定參考哪一層父類別（可能是袓父類別XD）的方式稱為「相對多型」，而若有指名是哪層父類別的方法，那就是「絕對多型」了。</p>
<h4 id="回顧-10"><a href="#回顧-10" class="headerlink" title="回顧"></a>回顧</h4><p>看完這篇文章，我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li>「類別」可想像成是建構某特定物體的藍圖或模具，而「實體」就是按照這監圖或模具製造出來的成品，並使用「建構子」來建立和初始化實體。</li>
<li>定義一個類別，其特性繼承於另外一個類別，稱它們為「父類別」與「子類別」，而子類別「繼承」了父類別的特性。</li>
<li>「多型」是指子類別除了擁有自已的方法外，這個方法還能覆寫來特化父類別的同名方法，以賦予其更特殊的行為。</li>
</ul>
<h5 id="References-8"><a href="#References-8" class="headerlink" title="References"></a>References</h5><p>[You Don’t Know JS: this &amp; Object Prototypes, Chapter 4: Mixing (Up) “Class” Objects](<a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this">https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this</a> %26 object prototypes&#x2F;ch4.md)</p>
<h3 id="你懂JavaScript？原型（Prototype）"><a href="#你懂JavaScript？原型（Prototype）" class="headerlink" title="你懂JavaScript？原型（Prototype）"></a>你懂JavaScript？原型（Prototype）</h3><p>本文主要會談到</p>
<ul>
<li>類別、建構子與實體</li>
<li>什麼是原型串鏈？原型串鏈的功用是？</li>
<li>什麼是原型式繼承？</li>
<li>疑難雜症大解惑-如何分辨屬性是位於該物件或原型串鏈上的？如何分辨誰是誰的實體？誰是誰的建搆子？原型串鏈有終點嗎？如何建立兩物件的連結？物件屬性的設定與遮蔽規則有哪些？</li>
</ul>
<h4 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h4><p>JavaScript並不像Java、C++這些知名的物件導向語言具有「類別」（class）來區分概念與實體（instance）或天生具有繼承的能力，而只有「物件」，因此只能利用設計模式來模擬這些功能。本文就來探討在JavaScript世界中，到底是㤰麼實現物件導向的概念的？</p>
<p>首先要有個模子，我們稱它為類別，而當前面有new的時候，可看成是建構子（constructor），接著用這個建構子做初始化，進而建立（new）實體。</p>
<p>如下，建構子Book產出實體ydkjs_1和ydkjs_2</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ydkhs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="keyword">var</span> ydkhs_2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;範疇與閉包 / this 與物件原型&#x27;</span>, <span class="number">251</span>);</span><br><span class="line"></span><br><span class="line">ydkhs_1.<span class="title function_">setComments</span>(<span class="string">&#x27;好書！&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkhs_1.<span class="property">comment</span>);<span class="comment">//好書！</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkhs_1.<span class="property">setComments</span> === ydkhs_2.<span class="property">setComments</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>共用的屬性或方法，不用每次都幫實體建立一份，提出來放到prototype即可。承上，將setComments這個共用的方法放到<code>Book.prototype</code>，暫且稱它為Book原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = <span class="literal">null</span>;<span class="comment">//評等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ydkhs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="keyword">var</span> ydkhs_2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;範疇與閉包 / this 與物件原型&#x27;</span>, <span class="number">251</span>);</span><br><span class="line"></span><br><span class="line">ydkhs_1.<span class="title function_">setComments</span>(<span class="string">&#x27;好書！&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkhs_1.<span class="property">comment</span>);<span class="comment">//好書！</span></span><br><span class="line"></span><br><span class="line">ydkhs_2.<span class="title function_">setComments</span>(<span class="string">&#x27;超好書！&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkhs_2.<span class="property">comment</span>);<span class="comment">//超好書！</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkhs_1.<span class="property">setComments</span> === ydkhs_2.<span class="property">setComments</span>);<span class="comment">// true，確認是同一個函式</span></span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h5 id="請勿修改原生原型"><a href="#請勿修改原生原型" class="headerlink" title="請勿修改原生原型"></a>請勿修改原生原型</h5><p>在這裡都是在設定自已建立的物件的原型！不要嘗試修改預設的原生原型（例如：<code>String.prototype</code>），也不要無條件地擴充原生原型，若要擴充也應該撰寫符合規格的測試程式，另外不要使用原生原型當成變數的初始值，以避免無意間的修改。</p>
<h5 id="關於建構子…"><a href="#關於建構子…" class="headerlink" title="關於建構子…"></a>關於建構子…</h5><ul>
<li><p>在JavaScript中，除了沒有類別外，其實也沒有建構子，因此</p>
<ul>
<li>只要函式前有new，這個函式就是建構子。</li>
<li>只要函式前有new來個呼叫，就叫做建構子呼叫。</li>
</ul>
</li>
<li><p>new關鍵字要做哪些事情呢？它的工作就是</p>
<ol>
<li>建立一個新的物件。</li>
<li>將物件的<code>.__proto__</code>指向建構子的prototype，形成原型串鏈。</li>
<li>將建構子的this指向new出來的新物件。</li>
<li>回傳這個物件。</li>
</ol>
</li>
</ul>
<h4 id="原型串鏈（Prototype-Chain）"><a href="#原型串鏈（Prototype-Chain）" class="headerlink" title="原型串鏈（Prototype Chain）"></a>原型串鏈（Prototype Chain）</h4><p>在前面[巢狀範疇](# 巢狀範疇（Nested Scope）)的部份提到「若在目前執行的範疇找不到這個變數的時候，就往外層的範疇搜尋，持續搜尋直到找到為止，或直到最外層的全域範疇」，同理， 當查找物件的屬性或方法時，若在本身這個物件找不到的時候，就會往更上一層物件尋找，直到串鏈尾端<code>Object.prototype</code>，若無法找到就回傳undefined，而這個尋找的脈絡就是依循著<code>.__proto__</code>這個原型串鏈（prototype chain）來找–每個物件在建立之初都會個<code>.__proto__</code>（dunder proto）內部屬性，它可用存取另一個相連物件內部屬性<code>[[prototype]]</code>的值，而<code>[[prototype]]</code>存放其建構子原型的位置。</p>
<p>如下範例，<code>ydkjs_1.__proto__</code>所存的參考即指向<code>Book.prototype</code>的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = <span class="literal">null</span>;<span class="comment">//評等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ydkjs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="property">__proto__</span> === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>模型圖。</p>
<img src="ydkjs-book-prototype.png" style="zoom:85%;" />

<p>由於在ydkjs_1是找不到方法setComments的，因此就會循著<code>.__proto__</code>找到Book.prototype而找到方法setComments，也因為原型串鏈，讓JavaScript可達到類似其他物件導向語言般的使用類別、繼承的功能。</p>
<p>備註，使用<code>.__proto__</code>來取得<code>[[Prototype]]</code>似乎太暴力了（畢竟人家是內部屬性嘛），還是改用<code>Object.getPrototypeOf(..)</code>來得優雅，其中<code>Object.getPrototypeOf(..)</code>會回傳<code>.__proto__</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="property">__proto__</span> === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(ydkjs_1) === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>接著來看幾個疑難雜症。</p>
<h5 id="Q1：到底是誰的屬性？"><a href="#Q1：到底是誰的屬性？" class="headerlink" title="Q1：到底是誰的屬性？"></a>Q1：到底是誰的屬性？</h5><p>可用<code>hasOwnProperty</code>檢查屬性是屬於當前物件，還是位於原型串錄中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;setComments&#x27;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>name的確是存在於物件ydkjs_1中的，而setComments並不在物件ydkjs_1中，是在原型串鏈中。</p>
<p>注意</p>
<ul>
<li>hasOwnProperty只會檢查該物件，而不會檢查整條原型串鏈。</li>
<li>for loop <code>prop in obj</code>會檢查整個原型串鏈且為可列舉的屬性。</li>
<li><code>prop in obj</code>會檢查整個原型串鏈，不管屬性是否可列舉。</li>
</ul>
<p>範例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = <span class="literal">null</span>;<span class="comment">//評等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ydkjs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="keyword">var</span> ydkjs_2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;範疇與閉包 / this 與物件原型&#x27;</span>, <span class="number">251</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(ydkjs_1, <span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="comment">//設定 hello 為不可列舉的屬性</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由於for loop <code>prop in obj</code>會檢查整個原型串鏈且為可列舉的屬性，因此除了hello之外，其它的屬性都會被列出來。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> ydkjs_1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>結果得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//pNum </span></span><br><span class="line"><span class="comment">//comment </span></span><br><span class="line"><span class="comment">//setComments </span></span><br></pre></td></tr></table></figure>

<p>承上，<code>prop in obj</code>會檢查整個原型串鏈，不管屬性是否可列舉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> ydkjs_1);<span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> ydkjs_1);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="Q2：到底是誰的實體？"><a href="#Q2：到底是誰的實體？" class="headerlink" title="Q2：到底是誰的實體？"></a>Q2：到底是誰的實體？</h5><p><code>instanceof</code>檢查物件是否為指定的建構子所建立的實體，位於<code>instanceof</code>左邊的運算元是物件，右邊的是函式，若左邊的物件是由右邊函式所產生的，則會回傳true，否則為false。<code>instanceof</code>可檢查整修原型串鏈的繼承世系，這在傳統的物件導向環境中稱為「內省」（introspection）或「反思」（reflection）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = <span class="literal">null</span>;<span class="comment">//評等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ydkjs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="keyword">var</span> ydkjs_2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;範疇與閉包 / this 與物件原型&#x27;</span>, <span class="number">251</span>);</span><br></pre></td></tr></table></figure>

<p>ydkjs_1與ydkjs_2都是由Book建立出來的實體，而Book也是由Object與Function建立出來的。因此都會得到true，最後舉個反例，window不是由Book建立出來的，因此得到false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1 <span class="keyword">instanceof</span> <span class="title class_">Book</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_2 <span class="keyword">instanceof</span> <span class="title class_">Book</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1 <span class="keyword">instanceof</span> <span class="title class_">Function</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_2 <span class="keyword">instanceof</span> <span class="title class_">Function</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span> <span class="keyword">instanceof</span> <span class="title class_">Book</span>);<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span> <span class="keyword">instanceof</span> <span class="variable language_">window</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>另外一個方法是使用<code>isPrototypeOf</code>，它可檢視運算子左邊的物件是否出現於右邊物件的原型串鏈中。與<code>instanceof</code>不同之處只在於運算元的資料型別不同而已，但功能是相同的。</p>
<p>再看一次這個相似的範例，Novel繼承了Book，並建立實體novel。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">name, pNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">//書名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pNum</span> = pNum; <span class="comment">//頁數</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = <span class="literal">null</span>;<span class="comment">//評等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setComments</span> = <span class="keyword">function</span> (<span class="params">comment</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">comment</span> = comment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Novel</span>(<span class="params">name, pNum, price</span>) &#123;</span><br><span class="line">    <span class="title class_">Book</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [name, pNum]);<span class="comment">//Novel 繼承 Book</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Novel</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Novel</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">printPrice</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="variable language_">this</span>.price&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ydkjs_1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;導讀，型別與文法&#x27;</span>, <span class="number">257</span>);</span><br><span class="line"><span class="keyword">var</span> ydkjs_2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&#x27;範疇與閉包 / this 與物件原型&#x27;</span>, <span class="number">251</span>);</span><br><span class="line"><span class="keyword">var</span> novel = <span class="keyword">new</span> <span class="title class_">Novel</span>(<span class="string">&#x27;最近沒在看小說 &gt;&lt;&#x27;</span>, <span class="number">500</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure>

<p>我們來檢視幾個問題…</p>
<ul>
<li>在ydkjs_1的整個原型串鏈中，是否出現過Book.prototype？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(ydkjs_1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在novel的整個原型串鏈中，是否出現過Book.prototype？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(novel));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在ydkjs_1的整個原型串鏈中，是否出現過Novel.prototype？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Novel</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(ydkjs_1));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在novel的整個原型串鏈中，是否出現過Novel.prototype？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Novel</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(novel));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>看模型圖會更清楚</p>
<img src="prototype_example.png" style="zoom:85%;" />

<p>注意，這裡的繼承是指原型式繼承（prototypal inheritance）。</p>
<p>「原型式繼承」是指使用連結相連兩個物件而能共用屬性的方式，又稱為「差異式繼承」（differential inheritance），它模仿了傳統物件導向語言的類別方法，而達到繼承的功能。</p>
<p>說明</p>
<ul>
<li><code>Novel.prototype = Object.Create(Book.prototype);</code>的<code>Object.create</code>建立了一個新物件（稱呼它為O），並將<code>O.__proto__</code>設定為Book.prototype，因此我們可以想成藉由O這個橋樑，讓<code>Novel.prototype.constructor === Book</code>。</li>
<li>承上，也可改用ES6的<code>setPrototypeof</code>來設定<code>[[Prototype]]</code>內部屬性的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre-ES6</span></span><br><span class="line"><span class="comment">// throws away default existing `Novel.prototype`</span></span><br><span class="line">Novel.prototype = Object.create(Book.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6+</span></span><br><span class="line"><span class="comment">// modifies existing `Novel.prototype`</span></span><br><span class="line">Object.setPrototypeOf(Novel.prototype, Book.prototype);</span><br></pre></td></tr></table></figure>

<p><code>Object.getPrototypof</code>。</p>
<p>ydkjs_1的<code>[[Prototype]]</code>的值是？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(ydkjs_1) === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>或等同直接使用<code>.__proto__</code>取得<code>[[Prototype]]</code>的值，也是可行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="property">__proto__</span> === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h6 id="備註-1"><a href="#備註-1" class="headerlink" title="備註"></a>備註</h6><ul>
<li><p>雖然剛才說「<code>instanceof</code>檢查物件是否為指定的建構子所建立的實體」，但其實<code>instanceof</code>所檢視的是物件的內部屬性<code>[[Prototype]]</code>(或說是<code>__proto__</code>)所形成的整條原型串鏈中，是否能找到其建構子原型。例如：ydkjs_1與ydkjs_2的<code>__proto__</code>屬性是否為<code>Book.prototype</code>？（答案是肯定的）</p>
</li>
<li><p>Object與Functon互為彼此的實體，意即<code>Function.__proto__</code>指向<code>Object.prototype</code>，而<code>Object.__proto__</code>也指向<code>Function.prototype</code>。</p>
</li>
<li><p>在下一篇文章「行為委派」中，我們會將「繼承世系」改稱為「委派連結」（delegation link），這會比較符合JavaScript的現況。</p>
</li>
</ul>
<h5 id="Q3：原型串鏈的終點是？"><a href="#Q3：原型串鏈的終點是？" class="headerlink" title="Q3：原型串鏈的終點是？"></a>Q3：原型串鏈的終點是？</h5><p>承上範例，針對這整條原型串鏈，我們就拿它來檢看看…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ydkjs_1.<span class="property">__proto__</span> === <span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Book</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);<span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>因此，Object.prototype物件就是整條串鏈的最頂端了。我們可想像成，在查找變數時，最後的終點就是全域範疇了。</p>
<p>Object.prototype這個物件含有很多常用的屬性和方法，例如：toString、valueOf等這也就是為什麼所有的物件都能使用這些功能的原因。</p>
<h5 id="Q4：屬性的設定與遮蔽"><a href="#Q4：屬性的設定與遮蔽" class="headerlink" title="Q4：屬性的設定與遮蔽"></a>Q4：屬性的設定與遮蔽</h5><p>查找物件的屬性或方法時要注意設定與遮蔽的問題。</p>
<p>我們可能遇過以下這種狀況…</p>
<p>物件obj有屬性counter作為計數器，而anotherObj無此屬性且原型串列的參考指向obj。可能是一時手誤吧，居然將<code>anotherObj.counter</code>當計數器做遞增，之後在程式某處分別印出<code>obj.count</code>與<code>anotherObj.count</code>，發現居然所存的值是不一樣的！這到底發生了什麼事呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> anotherObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line">anotherObj.<span class="property">counter</span>++;<span class="comment">// 一時手誤，應改為obj.counter++</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">counter</span>);<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherObj.<span class="property">counter</span>);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">counter</span>++;</span><br><span class="line">anotherObj.<span class="property">counter</span>++;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">counter</span>);<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherObj.<span class="property">counter</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>目前已知，anotherObj並無counter屬性，而counter屬性位於原型串鏈<code>[[Prototype]]</code>更上一層的obj之內。當使用指定運算子更新counter屬性值的時候，會依照以下規則來決定處理的方式</p>
<ol>
<li>此屬性可被寫入（writable為true），則anotherObj會新增此屬性，而產生遮蔽（shadowing）的效果。</li>
<li>此屬性不可被寫入（writable為false），則在嚴格模式下會被報錯，而在非嚴格模式下，會忽略這個設定&#x2F;更新。</li>
<li>此屬性有設定setter、因此會回傳setter所設定的預設值。</li>
</ol>
<p>在上面的這個例子中，是屬於狀況「1」，因此目前obj與anotherObj兩物件上都具有counter屬性了。解法是小心一點。不要再手誤了！</p>
<h5 id="Q5：一定要用「類別」的概念才能建立兩物件的連結嗎？"><a href="#Q5：一定要用「類別」的概念才能建立兩物件的連結嗎？" class="headerlink" title="Q5：一定要用「類別」的概念才能建立兩物件的連結嗎？"></a>Q5：一定要用「類別」的概念才能建立兩物件的連結嗎？</h5><p>答案是「不必」。</p>
<p><code>Object.create(..)</code>可將兩個物件連結起來，如下<code>Object.create(..)</code>可建立一個新物件coolPerson，連結到指定的物件person，意即設定<code>coolPerson.__proto__</code>指向person。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coolPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);<span class="comment">// coolPerson.__proto__ === person</span></span><br><span class="line">coolPerson.<span class="title function_">sayHi</span>(<span class="string">&#x27;Jack&#x27;</span>);<span class="comment">// Hi, I am Jack</span></span><br></pre></td></tr></table></figure>

<p>備註，若使用<code>Object.create(null)</code>建立一個空物件，那它就直的非常空，裡面不含依何屬性，因此也就沒有<code>.__proto__</code>或<code>.constructor</code>可用了，通常會單純當成存資料用的物件而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">empty;<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(empty.<span class="property">__proto__</span>);<span class="comment">// undefined--很空，什麼都沒有</span></span><br></pre></td></tr></table></figure>

<h5 id="Q6-連結作為備援之用？"><a href="#Q6-連結作為備援之用？" class="headerlink" title="Q6:連結作為備援之用？"></a>Q6:連結作為備援之用？</h5><p>原型串鏈的功用只是當備援(fallback)之？用意即，當查找的屬性無法在當前物件找到時，就往更上一層的物件尋找。</p>
<p>但其實沒這麼簡單，我們在下一篇文章「行為委派」會看到它的強大之處，例如，讓物件建立平等的委派關係以取得屬性和方法，實作更簡單物懂的設計模式。</p>
<h4 id="回顧-11"><a href="#回顧-11" class="headerlink" title="回顧"></a>回顧</h4><p>我們到底有什麼收穫呢？藉由本文可以理解到…</p>
<ul>
<li><p>原型串錄是指經由物件的內部屬性<code>.__proto__</code>而形成的物件到物件的連結串連，當查找物件屬性時，若在本身這個物件找不到，就往更上一層物件尋找，直到串鏈尾端，若無法找到就回傳undefined。<code>.__proto__</code>存放的即為其建構子原型的參考。</p>
</li>
<li><p>JavaScript沒有類吸，也沒有建構子，因此</p>
<ul>
<li>只要函式前有new，這個函就是建構子</li>
<li>只要函式前有new來個呼叫，就叫做建構子呼叫。</li>
</ul>
</li>
<li><p>JavaScript中的繼承是指原型式繼式或差異式繼承，意即使用連結兩個物件而能共用屬性的方式來模擬物件導向語言的類別與繼承功能。</p>
</li>
<li><p>hasOwnProperty可用來檢查屬性是屬於當前物件，還是位於原型串鏈中。</p>
</li>
<li><p>instanceof與isPrototypeOf可用來檢查物件是否為指定的建構子所建立的實體；</p>
<p><code>Object.getPrototypeOf</code>可取得物件的<code>[[Prototype]]</code>的值；</p>
<p><code>Object.setPrototypeOf</code>可設定物件的<code>[[Prototype]]</code>的值；</p>
</li>
<li><p><code>Object.prototype</code>就整條原型串鏈的終點。</p>
</li>
<li><p>物件屬性的設定與遮蔽規則。</p>
</li>
<li><p><code>Object.create(..)</code>可將兩個物件連結起來。</p>
</li>
</ul>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ithelp.ithome.com.tw/users/20092232/ironman/1612">你懂 JavaScript 嗎？</a></p>
<p><a href="https://github.com/getify/You-Dont-Know-JS/tree/1st-ed">You Don’t Know JS 1st Edition</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%A8%98%E9%8C%84Flask-SocketIO%E7%9A%84%E5%9D%91/%E8%A8%98%E9%8C%84Flask-SocketIO%E7%9A%84%E5%9D%91/" rel="prev" title="記錄Flask-SocketIO的坑">
                  <i class="fa fa-angle-left"></i> 記錄Flask-SocketIO的坑
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E8%A8%98%E9%8C%84Flask%E5%A4%9A%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E7%94%A8%E6%B3%95/%E8%A8%98%E9%8C%84Flask%E5%A4%9A%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E7%94%A8%E6%B3%95/" rel="next" title="記錄Flask多資料庫的用法">
                  記錄Flask多資料庫的用法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Tom Tang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '60px',
  right: 'unset',
  left: '60px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
